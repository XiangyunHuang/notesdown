[{"path":"index.html","id":"welcome","chapter":"欢迎","heading":"欢迎","text":"Book early development. Planned release 202X.","code":""},{"path":"index.html","id":"sec-licenses","chapter":"欢迎","heading":"授权说明","text":"本书采用 知识共享署名-非商业性使用-禁止演绎 4.0 国际许可协议 许可，请君自重，别没事儿拿去传个什么新浪爱问、百度文库以及 XX 经济论坛，项目中代码使用 MIT 协议 开源","code":""},{"path":"index.html","id":"sec-session-welcome","chapter":"欢迎","heading":"运行信息","text":"书籍在 R version 4.2.0 (2022-04-22) 下编译，Pandoc 版本 2.16.2，最新一次编译发生在 2022-06-10 10:20:02。","code":""},{"path":"chap-preface.html","id":"chap-preface","chapter":"第 1 章 前言","heading":"第 1 章 前言","text":"荃者所以在鱼，得鱼而忘荃；蹄者所以在兔；得兔而忘蹄；言者所以在意，得意而忘言。吾安得夫忘言之人而与之言哉！— 摘自 《庄子·杂篇·物》庄子谈学习，余深以为然，故引之。fish trap exists fish; ’ve gotten fish, can forget trap. rabbit snare exists rabbit; ’ve gotten rabbit, can forget snare. Words exist meaning; ’ve gotten meaning, can forget words. can find man forgotten words can word ? 1— Chuang Tzu","code":""},{"path":"chap-preface.html","id":"sec-r-or-python","chapter":"第 1 章 前言","heading":"1.1 语言抉择","text":"\n行业内可以做统计分析和建模的软件汗牛充栋，比较顶级的收费产品有 SAS 和 SPSS，在科学计算领域的 Matlab 和 Mathematica 也有相当强的统计功能，而用户基数最大的是微软 Excel，抛开微软公司的商业手段不说，Excel 的市场份额却是既成事实。 Brian D. Ripley 20 多年前的一句话很有意思，放在当下也是适用的。Let’s kid : widely used piece software statistics Excel.— Brian D. Ripley [1]有鉴于 Excel 在人文、社会、经济和管理等领域的影响力，熟悉 R 语言的人把它看作超级收费版的 Excel，这实在是一点也不过分。事实上，我司就是一个很好的明证，一个在线教育类的互联网公司，各大业务部门都在使用 Excel 作为主要的数据分析工具。然而，Excel 的不足也十分突出，工作过程无法保存和重复利用，Excel 也不是数据库，数据集稍大，操作起来愈发困难，对于复杂的展示，需要借助内嵌的 VBA，由于缺乏版本控制，随着时间的推移，几乎不可维护。所以，我们还是放弃 Excel 吧，Jenny Bryan 更在 2016 年国际 R 语言大会上的直截了当地喊出了这句话2。Nathan Stephens 对 Excel 的缺陷不足做了全面的总结3。people familiar R describe supercharged version Microsoft’s Excel spreadsheet software.— Ashlee Vance 4另一方面，我们谈谈开源领域的佼佼者 — R (https://cran.r-project.org/)，Python (https://www.python.org/) 和 Octave (http://www.gnu.org/software/octave/)。Python 号称万能的胶水语言，从系统运维到深度学习都有它的广泛存在，它被各大主流 Linux 系统内置，语言风格上更接近于基数庞大的开发人员，形成了强大的生态平台。 Octave 号称是可以替代 Matlab 的科学计算软件，在兼容 Matlab 的方面确实做的很不错，然而，根据 Julia 官网给出的各大编程语言的测试 https://julialang.org/benchmarks/，性能上不能相提并论。\n图 1.1: R 语言扩展包生态系统\nR 提供了丰富的图形接口，包括 Tcl/Tk , Gtk, Shiny 等，以及基于它们的衍生品 rattle（RGtk2）、Rcmdr（tcl/tk）、radiant（shiny）。更多底层介绍，见 John Chamber 的著作《Extending R》。Eviews 时间序列和计量经济模型，相比于 Eviews， Stata 是综合型的统计软件，提供丰富的统计模型，\nSPSS 同 Stata 类似，Minitab，\nJASP 是开源的软件， Octave 是对标 Matlab 的工程计算软件，\n有丰富的优化功能，是一门编程语言兼软件，为求解统计模型的参数提供了广泛的基础能力。Tableau 提供强大的分析和打造数据产品的能力。TikZ 在绘制示意图方面有很大优势，特别是示意图里包含数学公式，这更是 LaTeX 所擅长的方面。JASP https://jasp-stats.org 是一款免费的统计软件，源代码托管在 Github 上 https://github.com/jasp-stats/jasp-desktop，主要由阿姆斯特丹大学 E. J. Wagenmakers 教授 https://www.ejwagenmakers.com/ 领导的团队维护开发，实现了很多贝叶斯和频率统计方法，相似的图形用户界面使得 JASP 可以作为 SPSS 的替代，目前实现的功能见 https://jasp-stats.org/current-functionality/，统计方法见博客 https://www.bayesianspectacles.org/。国内可视化分析平台，比如 hiplot 基于 R 语言实现可视化分析，各类图形的介绍见文档，极大地降低数据分析人员探索分析的门槛，节省了时间，同时非专业内的人也可借助其完成分析探索的过程，只需明白各类图形的含义即可。美团也建设了自己的可视化分析平台帮助运营人员，详见文档Patrick Burns 收集整理了 R 语言中奇葩的现象，写成 R Inferno 直译过来就是《R 之炼狱》。这些奇葩的怪现象可以看做是 R 风格的一部分，对于编程人员来说就是一些建议和技巧，参考之可以避开某些坑。 Paul E. Johnson 整理了一份真正的 R 语言建议，记录了他自己从 SAS 转换到 R 的过程中遇到的各种问题 http://pj.freefaculty.org/R/Rtips.html。Michail Tsagris 和 Manos Papadakis 也收集了 70 多条 R 编程的技巧和建议，力求以更加 R 范地将语言特性发挥到极致 [2]，Martin Mächler 提供了一份 Good Practices R Programming。 Python 社区广泛流传着 Tim Peters 的 《Python 之禅》，它已经整合进每一版 Python 软件中，只需在 Python 控制台里执行 import 可以获得。Beautiful better ugly.Explicit better implicit.Simple better complex.Complex better complicated.Flat better nested.Sparse better dense.Readability counts.Special cases aren’t special enough break rules.Although practicality beats purity.Errors never pass silently.Unless explicitly silenced.face ambiguity, refuse temptation guess.one– preferably one –obvious way .Although way may obvious first unless ’re Dutch.Now better never.Although never often better right now.implementation hard explain, ’s bad idea.implementation easy explain, may good idea.Namespaces one honking great idea – let’s !— Zen Python总之，编程语言到一定境界都是殊途同归的，对美的认识也是趋同的，道理更是相通的，Python 社区的 Pandas https://github.com/pandas-dev/pandas 和 Matplotlib https://github.com/matplotlib/matplotlib 也有数据框和图形语法的影子。Pandas https://github.com/pandas-dev/pandas 明确说了要提供与 data.frame 类似的数据结构和对应统计函数等，而 Matplotlib 偷了 ggplot2 绘图样式 https://matplotlib.org/3.2.2/gallery/style_sheets/ggplot.html。","code":""},{"path":"chap-preface.html","id":"sec-data-science","chapter":"第 1 章 前言","heading":"1.2 数据科学","text":"John M. Chambers 谈了数据科学的源起以及和 S、R 语言的渊源 [3]。","code":""},{"path":"chap-preface.html","id":"sec-r-help","chapter":"第 1 章 前言","heading":"1.3 获取帮助","text":"R 社区提供了丰富的帮助资源，可以在 R 官网搜集的高频问题 https://cran.r-project.org/faqs.html 中查找，也可在线搜索 https://cran.r-project.org/search.html 或 https://rseek.org/ ，更多获取帮助方式见 https://www.r-project.org/help.html。爆栈网问题以标签分类，比如 r-plotly、r-markdown、 data.table 和 ggplot2，还可以关注一些活跃的社区大佬，比如 谢益辉。","code":""},{"path":"chap-preface.html","id":"sec-writing-details","chapter":"第 1 章 前言","heading":"1.4 写作环境","text":"\n\n图 1.2: 书籍项目架构图\n本书 R Markdown 源文件托管在 Github 仓库里，本地使用 RStudio IDE 编辑，bookdown 组织各个章节的 Rmd 文件和输出格式，使用 Git 进行版本控制。每次提交修改到 Github 上都会触发 Travis 自动编译书籍，将一系列 Rmd 文件经 knitr 调用 R 解释器执行里面的代码块，并将输出结果返回，Pandoc 将 Rmd 文件转化为 md 、 html 或者 tex 文件。若想输出 pdf 文件，还需要准备 TeX 排版环境，最后使用 Netlify 托管书籍网站，和 Travis 一起实现连续部署，使得每次修改都会同步到网站。最近一次编译时间 2022年06月10日02时20分03秒，本书用 R version 4.2.0 (2022-04-22) 编译，完整运行环境如下：借助 bookdown [4] 可以将 Rmd 文件组织起来， rmarkdown [5]和 knitr [6] 将源文件编译成 Markdown 文件， Pandoc 将 Markdown 文件转化成 HTML 和 TeX 文件， TinyTeX [7] 可以将 TeX 文件进一步编译成 PDF 文档，书中大量的图形在用 ggplot2 包制作 [8]，而统计理论相关的示意图用 Base R 创作。得益于 Github Action 提供的测试服务，Github Pages、Bookdown 和 Netlify 提供的部署服务，鉴于国内的网络环境，本书托管在三个地方，分别是 https://xiangyunhuang.github.io/notesdown/， https://bookdown.org/xiangyun/notesdown/ ， https://notesdown.netlify.app/。","code":"\nxfun::session_info(packages = c(\n  \"knitr\", \"rmarkdown\", \"bookdown\"\n), dependencies = FALSE)## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-pc-linux-gnu (64-bit)\n## Running under: Ubuntu 20.04.4 LTS\n## \n## Locale:\n##   LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n##   LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n##   LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n##   LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n##   LC_ADDRESS=C               LC_TELEPHONE=C            \n##   LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n## \n## Package version:\n##   bookdown_0.26  knitr_1.39     rmarkdown_2.14\n## \n## Pandoc version: 2.16.2"},{"path":"chap-preface.html","id":"sec-conventions","chapter":"第 1 章 前言","heading":"1.5 记号约定","text":"正文中的代码、函数、参数及参数值以等宽正体表示，如 data(list = c('iris', 'BOD'))，\n其中函数名称 data()，参数及参数值 list = c('iris', 'BOD') ，R 程序包用粗体表示，如 graphics。","code":"\nruler()----+----1----+----2----+----3----+----4----+----5----+----6----+----7----+----8\n12345678901234567890123456789012345678901234567890123456789012345678901234567890"},{"path":"chap-preface.html","id":"sec-contribute","chapter":"第 1 章 前言","heading":"1.6 复现环境","text":"构建容器本书借助 Github Action 从 Dockerfile 构建容器镜像，然后将镜像文件推送到 Github Package。完成这些操作首先需要从 https://github.com/settings/tokens 新建拥有 GitHub Package 5 读写删的权限的 TOKEN（俗称访问令牌或密钥），命名为 GITHUB_PKG，并将此令牌保存到本地 TOKEN.txt 文件中，以备后用。镜像内默认暴露 8181 端口供外部连接使用，进入容器后，默认工作路径是 /home/docker/。创建好镜像后，要先登陆 GitHub Package 然后才有权限将镜像拉取下来读者可以先查看下容器内的信息运行容器下面从镜像创建一个叫 notesdown-book 的容器，并让它在后台运行，允许以真正的 root 账户权限交互式执行命令，停止容器后，自动销毁容器。 此处，不再介绍 Docker 容器的使用，用容器打包本书所有软件环境仅供读者完整复现本书之用，感兴趣的读者可以去参考书籍Docker 从入门到实践。接着登陆进入 notesdown-book 容器，一番骚操作后，用户退出容器，然后停止容器。使用 RStudio Server启动容器后，接着获取容器 notesdown-book 的 IP 地址，然后依据端口号 8282 从网页进入 RStudio Sever，比如 http://192.168.100.23:8282","code":"# 登陆 GitHub Package\ncat ~/TOKEN.txt | docker login https://docker.pkg.github.com -u XiangyunHuang --password-stdin\n# 拉取镜像\ndocker pull docker.pkg.github.com/xiangyunhuang/notesdown/notesdown-book:develdocker run --rm -u root -v \"/${PWD}://home/docker/\" \\\n  docker.pkg.github.com/xiangyunhuang/notesdown/notesdown-book:devel \\\n  bash -c \"locale; fc-list | sort\"docker run -itd -p 8282:8787 --rm --name=notesdown-book --privileged=true \\\n  docker.pkg.github.com/xiangyunhuang/notesdown/notesdown-book:devel /sbin/initdocker exec -it notesdown-book bashdocker stop notesdown-bookdocker inspect --format='{{.NetworkSettings.IPAddress}}' notesdown-book"},{"path":"chap-preface.html","id":"sec-help-me","chapter":"第 1 章 前言","heading":"1.7 如何发问","text":"phrase “work” helpful, can mean quite things including:computer exploded.explosion, smoke pouring back microsoft’s “NoSmoke” utility compatible power supply.computer stopped working.computer sits around couch day eating chips watching talk shows.computer started picketing house shouting catchy slogans demanding better working conditions increase memory.Everything went dark check cables back computer lights due power outage.R crashed, programs still working.R gave error message stopped processing code running .R gave error message without running code (waiting next command).R still running code time exceeded patience think hung.R completed returned result, also gave warnings.R completed command, gave incorrect answer.R completed command answer different expect (correct according documentation).probably others. Running code think answer last one.— Greg Snow 6","code":""},{"path":"chap-preface.html","id":"sec-about-author","chapter":"第 1 章 前言","heading":"1.8 作者简介","text":"热心开源事业，统计之都副主编，经常混迹于统计之都论坛、Github 和爆栈网。个人主页 https://xiangyun.rbind.io/","code":""},{"path":"chap-data-wrangling.html","id":"chap-data-wrangling","chapter":"介绍","heading":"介绍","text":"数据整理","code":""},{"path":"chap-data-structure.html","id":"chap-data-structure","chapter":"第 2 章 数据结构","heading":"第 2 章 数据结构","text":"网站 https://r-coder.com/ 主要介绍 Base R，特点是全面细致，排版精美可用于绘图的数据对象，向量 vector 等，只涉及基础操作和绘图，关键在入门引导式的介绍，点到即止数据类型：字符、数值：字符数据操作：按数据类型介绍各类数据操作，重复之处如前所述，数据处理的分类：按数据类型来，一共是 table matrix data.frame 和 vectorThe trouble nonstandard evaluation doesn’t follow standard\nevaluation rules…— Peter Dalgaard (nonstandard evaluation curve() function)\nR-help (June 2011)向量，列表，数据框 data frame 在 R 里面可以用三种不同类型的数据对象来表达从历史脉络来看，为什么会出现三种不同的东西，它们之间的区别和联系是什么，能否用一张表来描述data.frame 设计的历史，首次包含在 R 里面是什么时候，R 是否一发布就包含了这个数据类型The function data.frame() creates data frames, tightly coupled collections variables share many properties matrices lists, used fundamental data structure R’s modeling software.data.table 2006 年 4 月 15 日首次登陆 CRAN 发布 1.0 版本，差不多恰好 10 年后tibble 在 2016 年 3 月 23 日首次登陆 CRAN 发布 1.0 版本data.frame()， tibble() 和 data.table() 的区别，去看函数的帮助文档Provides ‘tbl_df’ class (‘tibble’) provides stricter checking better formatting traditional data frame.vctrs 和 rlang 包\nR 内置的 R Language Definition","code":""},{"path":"chap-data-structure.html","id":"subsec:typeof","chapter":"第 2 章 数据结构","heading":"2.1 类型","text":"表 2.1:  函数 typeof() 返回的数据类型 7表 2.2:  R/Rcpp 提供的基本数据类型","code":"\nx <- \"abc\" # 数据对象\ntypeof(x) # 数据类型## [1] \"character\"\nmode(x) # 存储模式## [1] \"character\"\nstorage.mode(x) # 存储类型## [1] \"character\""},{"path":"chap-data-structure.html","id":"sec-character","chapter":"第 2 章 数据结构","heading":"2.2 字符","text":"","code":""},{"path":"chap-data-structure.html","id":"sec-vector","chapter":"第 2 章 数据结构","heading":"2.3 向量","text":"","code":""},{"path":"chap-data-structure.html","id":"sec-matrix","chapter":"第 2 章 数据结构","heading":"2.4 矩阵","text":"","code":""},{"path":"chap-data-structure.html","id":"sec-array","chapter":"第 2 章 数据结构","heading":"2.5 数组","text":"更多数组操作 rray","code":""},{"path":"chap-data-structure.html","id":"sec-expression","chapter":"第 2 章 数据结构","heading":"2.6 表达式","text":"","code":"\n# %||% 中缀符\n# x 是空值或者长度为 0 则保留 y 否则保留 x\nfunction(x, y) if (is.null(x) || length(x) == 0) y else x## function(x, y) if (is.null(x) || length(x) == 0) y else x"},{"path":"chap-data-structure.html","id":"sec-list","chapter":"第 2 章 数据结构","heading":"2.7 列表","text":"","code":"\nx <- list(a = 1, b = 2, c = list(d = c(1, 2, 3), e = \"hello\"))\nprint(x)## $a\n## [1] 1\n## \n## $b\n## [1] 2\n## \n## $c\n## $c$d\n## [1] 1 2 3\n## \n## $c$e\n## [1] \"hello\"\nbase::print.simple.list(x)##      _    \n## a    1    \n## b    2    \n## c.d1 1    \n## c.d2 2    \n## c.d3 3    \n## c.e  hello"},{"path":"chap-data-structure.html","id":"sec-date","chapter":"第 2 章 数据结构","heading":"2.8 日期","text":"注意观察时间转化但是，下面这样会报错正确的姿势是首先将表示日期的字符串格式统一date-times 表示 POSIXct 和 POSIXlt 类型的日期对象format() 是一个泛型函数，此刻命名空间有 102 方法。\nformat.Date()， format.difftime()， format.POSIXct() 和 format.POSIXlt() 四个函数通过格式化不同类型的日期数据对象抽取指定部分。日期转化详见 [9], [10]上个季度最后一天本季度第一天类似地，本月第一天和上月最后一天timeDate 提供了很多日期计算函数，比如季初、季末、月初、月末等cut.Date() 是一个泛型函数，查看它的所有 S3 方法格式化输出日期类型数据获取当日零点从 POSIXt 数据对象中，抽取小时和分钟部分，返回字符串表 2.3:  日期表格本节介绍了 R 本身提供的基础日期操作，第??章着重介绍一般的时间序列类型的数据对象及其操作。Jeffrey . Ryan 开发的 xts 和 quantmod 包，Joshua M. Ulrich 开发的 zoo 是处理时间序列数据的主要工具Jeffrey . Ryan 在开设了一门免费课程教大家如何在 R 语言中使用 xts 和 zoo 包操作时间序列数据 8xts (eXtensible Time Series) 扩展的 zoo 对象Date，POSIX times，timeDate，chron 等各种各样处理日期数据的对象","code":"\nSys.Date()## [1] \"2022-06-10\"\nSys.time()## [1] \"2022-06-10 02:20:06 UTC\"\nc(Sys.time(), Sys.Date())## [1] \"2022-06-10 02:20:06 UTC\" \"2022-06-10 00:00:00 UTC\"\ndata.table::year(Sys.Date())## [1] 2022\ndata.table::year(Sys.time())## [1] 2022\ndata.table::year(c(Sys.time(), Sys.Date()))## [1] 2022 2022\nx <- Sys.time()\nclass(x)## [1] \"POSIXct\" \"POSIXt\"\nformat(x, format = \"%Y-%m-%d\")## [1] \"2022-06-10\"\nx <- c(\"2019-12-21\", \"2019/12/21\")\ndata.table::year(\"2019-12-21\")## [1] 2019\ndata.table::year(\"2019/12/21\")## [1] 2019\ndata.table::year(x)## Error in as.POSIXlt.character(x): character string is not in a standard unambiguous format\ngsub(pattern = \"/\", replacement = \"-\", x) %>% \n  data.table::year()## [1] 2019 2019\n(x <- Sys.time())## [1] \"2022-06-10 02:20:06 UTC\"\nclass(x)## [1] \"POSIXct\" \"POSIXt\"\ndata.table::second(x) # 取秒## [1] 6\nformat(x, format = \"%S\")## [1] \"06\"\ndata.table::minute(x) # 取分## [1] 20\nformat(x, format = \"%M\")## [1] \"20\"\ndata.table::hour(x) # 取时## [1] 2\nformat(x, format = \"%H\")## [1] \"02\"\ndata.table::yday(x) # 此刻在一年的第几天## [1] 161\ndata.table::wday(x) # 此刻在一周的第几天，星期日是第1天，星期六是第7天## [1] 6\ndata.table::mday(x) # 此刻在当月第几天## [1] 10\nformat(x, format = \"%d\")## [1] \"10\"\nweekdays(x)## [1] \"Friday\"\nweekdays(x, abbreviate = T)## [1] \"Fri\"\ndata.table::week(x) # 此刻在第几周## [1] 24\ndata.table::isoweek(x)## [1] 23\ndata.table::month(x) # 此刻在第几月## [1] 6\nformat(x, format = \"%m\")## [1] \"06\"\nmonths(x)## [1] \"June\"\nmonths(x, abbreviate = T)## [1] \"Jun\"\ndata.table::quarter(x) # 此刻在第几季度## [1] 2\nquarters(x)## [1] \"Q2\"\ndata.table::year(x) # 取年## [1] 2022\nformat(x, format = \"%Y\")## [1] \"2022\"\nformat(difftime(Sys.time(), x, units = \"secs\"))## [1] \"0.05133891 secs\"\n# https://d.cosx.org/d/421162/16\nas.Date(cut(as.Date(c(\"2020-02-01\", \"2020-05-02\")), \"quarter\")) - 1## [1] \"2019-12-31\" \"2020-03-31\"\nas.Date(cut(as.Date(c(\"2020-02-01\", \"2020-05-02\")), \"quarter\"))## [1] \"2020-01-01\" \"2020-04-01\"\n# 本月第一天\nas.Date(cut(as.Date(c(\"2020-02-01\", \"2020-05-02\")), \"month\"))## [1] \"2020-02-01\" \"2020-05-01\"\n# 上月最后一天\nas.Date(cut(as.Date(c(\"2020-02-01\", \"2020-05-02\")), \"month\")) - 1## [1] \"2020-01-31\" \"2020-04-30\"\nlibrary(timeDate) \n# 季初\nas.Date(format(timeFirstDayInQuarter(charvec = c(\"2020-02-01\", \"2020-05-02\")), format = \"%Y-%m-%d\")) \n# 季末\nas.Date(format(timeLastDayInQuarter(charvec = c(\"2020-02-01\", \"2020-05-02\")), format = \"%Y-%m-%d\"))\n# 月初\nas.Date(format(timeFirstDayInMonth(charvec = c(\"2020-02-01\", \"2020-05-02\")), format = \"%Y-%m-%d\")) \n# 月末\nas.Date(format(timeLastDayInMonth(charvec = c(\"2020-02-01\", \"2020-05-02\")), format = \"%Y-%m-%d\")) \nmethods(cut)## [1] cut.Date        cut.default     cut.dendrogram* cut.IDate*     \n## [5] cut.POSIXt     \n## see '?methods' for accessing help and source code\nformatC(round(runif(1, 1e8, 1e9)), digits = 10, big.mark = \",\")## [1] \"298,036,320\"\n# Sys.setlocale(locale = \"C\") # 如果是 Windows 系统，必须先设置，否则转化结果是 NA\nas.Date(paste(\"1990-January\", 1, sep = \"-\"), format = \"%Y-%B-%d\")## [1] \"1990-01-01\"\nformat(as.POSIXlt(Sys.Date()), \"%Y-%m-%d %H:%M:%S\")## [1] \"2022-06-10 00:00:00\"\nstrftime(x = Sys.time(), format = \"%H:%M\")## [1] \"02:20\"\nxts(x = NULL,\n    order.by = index(x),\n    frequency = NULL,\n    unique = TRUE,\n    tzone = Sys.getenv(\"TZ\"),\n    ...)\nlibrary(zoo)\nlibrary(xts)\nx = matrix(1:4, ncol = 2,nrow = 2)\nidx <- as.Date(c(\"2018-01-01\", \"2019-12-12\"))\n# xts = matrix + index\nxts(x, order.by = idx)##            [,1] [,2]\n## 2018-01-01    1    3\n## 2019-12-12    2    4"},{"path":"chap-data-structure.html","id":"sec-null","chapter":"第 2 章 数据结构","heading":"2.9 空值","text":"移除list() 列表里的为 NULL 元素","code":"\nrm_null <- function(l) Filter(Negate(is.null), l)"},{"path":"chap-data-transportation.html","id":"chap-data-transportation","chapter":"第 3 章 数据搬运","heading":"第 3 章 数据搬运","text":"导入数据与导出数据，各种数据格式，数据库处理 Excel 2003 (XLS) 和 Excel 2007 (XLSX) 文件还可以使用 WriteXLS 包，不过它依赖于 Perl，另一个 R 包 xlsx 与之功能类似，依赖 Java 环境。Jennifer Bryan 和 Hadley Wickham 开发的 readxl 包和 Jeroen Ooms 开发的 writexl 包专门处理 xlsx 格式并且无任何系统依赖。","code":""},{"path":"chap-data-transportation.html","id":"import-data","chapter":"第 3 章 数据搬运","heading":"3.1 导入数据","text":"Base R 针对不同的数据格式文件，提供了大量的数据导入和导出函数，不愧是专注数据分析20余年的优秀统计软件。 除了函数 write.ftable 和 read.ftable 来自 stats 包，都来自 base 和 utils 包","code":"\n# 当前环境的搜索路径\nsearchpaths()## [1] \".GlobalEnv\"                          \n## [2] \"/opt/R/4.2.0/lib/R/library/stats\"    \n## [3] \"/opt/R/4.2.0/lib/R/library/graphics\" \n## [4] \"/opt/R/4.2.0/lib/R/library/grDevices\"\n## [5] \"/opt/R/4.2.0/lib/R/library/utils\"    \n## [6] \"/opt/R/4.2.0/lib/R/library/datasets\" \n## [7] \"/opt/R/4.2.0/lib/R/library/methods\"  \n## [8] \"Autoloads\"                           \n## [9] \"/opt/R/4.2.0/lib/R/library/base\"\n# 返回匹配结果及其所在路径的编号\napropos(\"^(read|write)\", where = TRUE, mode = \"function\")##                  5                  5                  9                  5 \n##         \"read.csv\"        \"read.csv2\"         \"read.dcf\"       \"read.delim\" \n##                  5                  5                  5                  2 \n##      \"read.delim2\"         \"read.DIF\"     \"read.fortran\"      \"read.ftable\" \n##                  5                  5                  5                  9 \n##         \"read.fwf\"      \"read.socket\"       \"read.table\"          \"readBin\" \n##                  9                  5                  9                  9 \n##         \"readChar\" \"readCitationFile\"         \"readline\"        \"readLines\" \n##                  9                  9                  9                  5 \n##          \"readRDS\"     \"readRenviron\"            \"write\"        \"write.csv\" \n##                  5                  9                  2                  5 \n##       \"write.csv2\"        \"write.dcf\"     \"write.ftable\"     \"write.socket\" \n##                  5                  9                  9                  9 \n##      \"write.table\"         \"writeBin\"        \"writeChar\"       \"writeLines\""},{"path":"chap-data-transportation.html","id":"scan-file","chapter":"第 3 章 数据搬运","heading":"3.1.1 scan","text":"首先让我们用 cat 函数创建一个练习数据集 ex.data以此练习数据集，介绍 scan 函数最常用的参数从上面的报错信息，我们发现 scan 函数只能读取同一类型的数据，如布尔型 logical， 整型 integer，数值型 numeric(double)， 复数型 complex，字符型 character，raw 和列表 list。所以我们设置参数 skip = 1 把第一行跳过，就成功读取了数据如果设置参数 quiet = TRUE 就不会报告读取的数据量参数 nlines = 1 表示只读取一行数据默认参数 flush = TRUE 表示读取最后一个请求的字段后，刷新到行尾，下面对比一下读取的结果临时文件 ex.data 用完了，我们调用 unlink 函数将其删除，以免留下垃圾文件","code":"\nscan(file = \"\", what = double(), nmax = -1, n = -1, sep = \"\",\n     quote = if(identical(sep, \"\\n\")) \"\" else \"'\\\"\", dec = \".\",\n     skip = 0, nlines = 0, na.strings = \"NA\",\n     flush = FALSE, fill = FALSE, strip.white = FALSE,\n     quiet = FALSE, blank.lines.skip = TRUE, multi.line = TRUE,\n     comment.char = \"\", allowEscapes = FALSE,\n     fileEncoding = \"\", encoding = \"unknown\", text, skipNul = FALSE)\ncat(\"TITLE extra line\", \"2 3 5 7\", \"11 13 17\")## TITLE extra line 2 3 5 7 11 13 17\ncat(\"TITLE extra line\", \"2 3 5 7\", \"11 13 17\", file = \"data/ex.data\", sep = \"\\n\")\nscan(\"data/ex.data\")## Error in scan(\"data/ex.data\"): scan() expected 'a real', got 'TITLE'\nscan(\"data/ex.data\", skip = 1)## [1]  2  3  5  7 11 13 17\nscan(\"data/ex.data\", skip = 1, quiet = TRUE)## [1]  2  3  5  7 11 13 17\nscan(\"data/ex.data\", skip = 1, nlines = 1) # only 1 line after the skipped one## [1] 2 3 5 7\nscan(\"data/ex.data\", what = list(\"\", \"\", \"\")) # flush is F -> read \"7\"## Warning in scan(\"data/ex.data\", what = list(\"\", \"\", \"\")): number of items read\n## is not a multiple of the number of columns## [[1]]\n## [1] \"TITLE\" \"2\"     \"7\"     \"17\"   \n## \n## [[2]]\n## [1] \"extra\" \"3\"     \"11\"    \"\"     \n## \n## [[3]]\n## [1] \"line\" \"5\"    \"13\"   \"\"\nscan(\"data/ex.data\", what = list(\"\", \"\", \"\"), flush = TRUE)## [[1]]\n## [1] \"TITLE\" \"2\"     \"11\"   \n## \n## [[2]]\n## [1] \"extra\" \"3\"     \"13\"   \n## \n## [[3]]\n## [1] \"line\" \"5\"    \"17\"\nunlink(\"data/ex.data\") # tidy up"},{"path":"chap-data-transportation.html","id":"read-write-table","chapter":"第 3 章 数据搬运","heading":"3.1.2 read.table","text":"变量名是不允许以下划线开头的，同样在数据框里，列名也不推荐使用下划线开头。默认情况下，read.table 都会通过参数 check.names 检查列名的有效性，该参数实际调用了函数 make.names 去检查。如果想尽量保持数据集原来的样子可以设置参数 check.names = FALSE, stringsAsFactors = FALSE。 默认情形下，read.table 还会将字符串转化为因子变量，这是 R 的历史原因，作为一门统计学家的必备语言，在统计模型中，字符常用来描述类别，而类别变量在 R 环境中常用因子类型来表示，而且大量内置的统计模型也是将它们视为因子变量，如 lm 、glm 等","code":"\nread.table(file,\n  header = FALSE, sep = \"\", quote = \"\\\"'\",\n  dec = \".\", numerals = c(\"allow.loss\", \"warn.loss\", \"no.loss\"),\n  row.names, col.names, as.is = !stringsAsFactors,\n  na.strings = \"NA\", colClasses = NA, nrows = -1,\n  skip = 0, check.names = TRUE, fill = !blank.lines.skip,\n  strip.white = FALSE, blank.lines.skip = TRUE,\n  comment.char = \"#\",\n  allowEscapes = FALSE, flush = FALSE,\n  stringsAsFactors = default.stringsAsFactors(),\n  fileEncoding = \"\", encoding = \"unknown\", text, skipNul = FALSE\n)\n\nread.csv(file,\n  header = TRUE, sep = \",\", quote = \"\\\"\",\n  dec = \".\", fill = TRUE, comment.char = \"\", ...\n)\n\nread.csv2(file,\n  header = TRUE, sep = \";\", quote = \"\\\"\",\n  dec = \",\", fill = TRUE, comment.char = \"\", ...\n)\n\nread.delim(file,\n  header = TRUE, sep = \"\\t\", quote = \"\\\"\",\n  dec = \".\", fill = TRUE, comment.char = \"\", ...\n)\n\nread.delim2(file,\n  header = TRUE, sep = \"\\t\", quote = \"\\\"\",\n  dec = \",\", fill = TRUE, comment.char = \"\", ...\n)\ndat1 = read.table(header = TRUE, check.names = TRUE, text = \"\n_a _b _c\n1 2 a1\n3 4 a2\n\")\ndat1##   X_a X_b X_c\n## 1   1   2  a1\n## 2   3   4  a2\ndat2 = read.table(header = TRUE, check.names = FALSE, text = \"\n_a _b _c\n1 2 a1\n3 4 a2\n\")\ndat2##   _a _b _c\n## 1  1  2 a1\n## 2  3  4 a2\ndat3 <- read.table(header = TRUE, check.names = FALSE,\n  stringsAsFactors = FALSE, text = \"\n_a _b _c\n1 2 a1\n3 4 a2\n\"\n)\ndat3##   _a _b _c\n## 1  1  2 a1\n## 2  3  4 a2"},{"path":"chap-data-transportation.html","id":"read-write-lines","chapter":"第 3 章 数据搬运","heading":"3.1.3 readLines","text":"让我们折腾一波，读进来又写出去，只有 R 3.5.3 以上才能保持原样的正确输入输出，因为这里有一个之前版本包含的 BUG这次我们创建一个真的临时文件，因为重新启动 R 这个文件和文件夹就没有了，回收掉了设置参数 n = -1 表示将文件 fil 的内容从头读到尾作为拥有良好习惯的 R 用户，这种垃圾文件最好用后即焚再举个例子，我们创建一个新的临时文件 fil，文件内容只有这次读取文件的过程给出了警告，原因是 fil 没有以空行结尾，warn = TRUE 表示这种情况要给出警告，如果设置参数 warn = FALSE 就没有警告。我们还是建议大家尽量遵循规范。再举一个例子，从一个连接读取数据，建立连接的方式有很多，参见 ?file，下面设置参数 blocking","code":"\nreadLines(con = stdin(), n = -1L, ok = TRUE, warn = TRUE,\n          encoding = \"unknown\", skipNul = FALSE)\nwriteLines(readLines(system.file(\"DESCRIPTION\", package = \"splines\")), \"data/DESCRIPTION\")\n# 比较一下\nidentical(\n  readLines(system.file(\"DESCRIPTION\", package = \"splines\")),\n  readLines(\"data/DESCRIPTION\")\n)## [1] TRUE\nfil <- tempfile(fileext = \".data\")\ncat(\"TITLE extra line\", \"2 3 5 7\", \"\", \"11 13 17\", file = fil,\n    sep = \"\\n\")\nfil## [1] \"/tmp/RtmptC7PaN/file52d7105fbc6c.data\"\nreadLines(fil, n = -1)## [1] \"TITLE extra line\" \"2 3 5 7\"          \"\"                 \"11 13 17\"\nunlink(fil) # tidy up\ncat(\"123\\nabc\")## 123\n## abc\nfil <- tempfile(\"test\")\ncat(\"123\\nabc\\n\", file = fil, append = TRUE)\nfil## [1] \"/tmp/RtmptC7PaN/test52d765878f92\"\nreadLines(fil)## [1] \"123\" \"abc\"\ncon <- file(fil, \"r\", blocking = FALSE)\nreadLines(con)## [1] \"123\" \"abc\"\ncat(\" def\\n\", file = fil, append = TRUE)\nreadLines(con)## [1] \" def\"\n# 关闭连接\nclose(con)\n# 清理垃圾文件\nunlink(fil)"},{"path":"chap-data-transportation.html","id":"read-save-rds","chapter":"第 3 章 数据搬运","heading":"3.1.4 readRDS","text":"序列化数据操作，Mark Klik 开发的 fst 和 Travers Ching 开发的 qs， Hadley Wickham 开发的 feather 包实现跨语言环境快速的读写数据表 3.1:  fst 序列化数据框对象性能比较 BaseR、 data.table 和 feather 9目前比较好的是 qs 和 fst 包","code":""},{"path":"chap-data-transportation.html","id":"other-data-source","chapter":"第 3 章 数据搬运","heading":"3.2 其它数据格式","text":"来自其它格式的数据形式，如 JSON、XML、YAML 需要转化清理成 R 中数据框的形式 data.frameData Rectangling jqMongolite User Manual introduction using MongoDB mongolite client Rjsonlite 读取 *.json 格式的文件，jsonlite::write_json 函数将 R对象保存为 JSON 文件，jsonlite::fromJSON 将 json 字符串或文件转化为 R 对象，jsonlite::toJSON 函数正好与之相反yaml 包读取 *.yml 格式文件，返回一个列表，yaml::write_yaml 函数将 R 对象写入 yaml 格式表 3.2:  导入来自其它数据分析软件产生的数据集表 3.3:  导入来自其它格式的数据集read.dcf 函数读取 Debian 控制格式文件，这种类型的文件以人眼可读的形式在存储数据，如 R 包的 DESCRIPTION 文件或者包含所有 CRAN 上 R 包描述的文件 https://cran.r-project.org/src/contrib/PACKAGES最后要提及拥有瑞士军刀之称的 rio 包，它集合了当前 R 可以读取的所有统计分析软件导出的数据。","code":"\nlibrary(jsonlite)\n# 从 json 格式的文件导入\n# jsonlite::read_json(path = \"path/to/filename.json\")\n# A JSON array of primitives\njson <- '[\"Mario\", \"Peach\", null, \"Bowser\"]'\n\n# 简化为原子向量atomic vector\nfromJSON(json)## [1] \"Mario\"  \"Peach\"  NA       \"Bowser\"\n# 默认返回一个列表\nfromJSON(json, simplifyVector = FALSE)## [[1]]\n## [1] \"Mario\"\n## \n## [[2]]\n## [1] \"Peach\"\n## \n## [[3]]\n## NULL\n## \n## [[4]]\n## [1] \"Bowser\"\nlibrary(yaml)\nyaml::read_yaml(file = '_bookdown.yml')## $book_filename\n## [1] \"notesdown\"\n## \n## $delete_merged_file\n## [1] TRUE\n## \n## $language\n## $language$label\n## $language$label$fig\n## [1] \"图 \"\n## \n## $language$label$tab\n## [1] \"表 \"\n## \n## \n## $language$ui\n## $language$ui$edit\n## [1] \"编辑\"\n## \n## $language$ui$chapter_name\n## [1] \"第 \" \" 章\"\n## \n## $language$ui$appendix_name\n## [1] \"附录 \"\n## \n## \n## \n## $new_session\n## [1] TRUE\n## \n## $before_chapter_script\n## [1] \"_common.R\"\n## \n## $rmd_files\n##  [1] \"index.Rmd\"                    \"preface.Rmd\"                 \n##  [3] \"data-wrangling.Rmd\"           \"data-structure.Rmd\"          \n##  [5] \"data-transportation.Rmd\"      \"string-operations.Rmd\"       \n##  [7] \"regular-expressions.Rmd\"      \"data-manipulation.Rmd\"       \n##  [9] \"advanced-manipulation.Rmd\"    \"parallel-manipulation.Rmd\"   \n## [11] \"other-manipulation.Rmd\"       \"statistical-graphics.Rmd\"    \n## [13] \"graphics-foundations.Rmd\"     \"data-visualization.Rmd\"      \n## [15] \"interactive-web-graphics.Rmd\" \"statistical-computation.Rmd\" \n## [17] \"numerical-optimization.Rmd\"   \"appendix.Rmd\"                \n## [19] \"references.Rmd\"\nx <- read.dcf(file = system.file(\"DESCRIPTION\", package = \"splines\"),\n              fields = c(\"Package\", \"Version\", \"Title\"))\nx##      Package   Version Title                                    \n## [1,] \"splines\" \"4.2.0\" \"Regression Spline Functions and Classes\""},{"path":"chap-data-transportation.html","id":"import-large-dataset","chapter":"第 3 章 数据搬运","heading":"3.3 导入大数据集","text":"在不使用数据库的情况下，从命令行导入大数据集，如几百 M 或几个 G 的 csv 文件。利用 data.table 包的 fread 去读取https://stackoverflow.com/questions/1727772/","code":""},{"path":"chap-data-transportation.html","id":"import-data-from-database","chapter":"第 3 章 数据搬运","heading":"3.4 从数据库导入","text":"Hands-Programming R 数据读写章节10 以及 R, Databases Docker将大量的 txt 文本存进 MySQL 数据库中，通过操作数据库来聚合文本，极大降低内存消耗 11，而 ODBC 与 DBI 包是其它数据库接口的基础，knitr 提供了一个支持 SQL 代码的引擎，它便是基于 DBI，因此可以在 R Markdown 文档中直接使用 SQL 代码块 12。这里制作一个归纳表格，左边数据库右边对应其 R 接口，两边都包含链接，如表 3.4 所示表 3.4: 数据库接口","code":""},{"path":"chap-data-transportation.html","id":"postgresql","chapter":"第 3 章 数据搬运","heading":"3.4.1 PostgreSQL","text":"odbc 可以支持很多数据库，下面以连接 PostgreSQL 数据库为例介绍其过程首先在某台机器上，拉取 PostgreSQL 的 Docker 镜像在 Docker 上运行 PostgreSQL，主机端口号 8181 映射给数据库 PostgreSQL 的默认端口号 5432（或其它你的 DBA 分配给你的端口）在主机 Ubuntu 上配置端口 5432 是分配给 PostgreSQL 的默认端口，host 可以是云端的地址，如 你的亚马逊账户下的 PostgreSQL 数据库地址 <ec2-54-83-201-96.compute-1.amazonaws.com>，也可以是本地局域网IP地址，如<192.168.1.200>。通过参数 dbname 连接到指定的 PostgreSQL 数据库，如 Heroku，这里作为演示就以默认的数据库 postgres 为例查看配置系统文件路径不推荐修改全局配置文件，可设置 ODBCSYSINI 环境变量指定配置文件路径，如 ODBCSYSINI=~/ODBC http://www.unixodbc.org/odbcinst.html安装完驱动程序，/etc/odbcinst.ini 文件内容自动更新，我们可以不必修改，如果你想自定义不妨手动修改，我们查看在 R 环境中注册的数据库，可以看到 PostgreSQL 的驱动已经配置好系统配置文件 /etc/odbcinst.ini 已经包含有 PostgreSQL 的驱动配置，无需再重复配置只需将如下内容存放在 ~/.odbc.ini 文件中，最后，一行命令 DNS 配置连接 https://github.com/r-dbi/odbc 这样就实现了代码中无任何敏感信息，这里为了展示这个配置过程故而把相关信息公开。注意下面的内容需要在容器中运行， Windows 环境下的配置 PostgreSQL 的驱动有点麻烦就不搞了，意义也不大，现在数据库基本都是跑在 Linux 系统上docker-machine.exe ip default 可以获得本地 Docker 的 IP，比如 192.168.99.101。 Travis 上 ip addr 可以查看 Docker 的 IP，如 172.17.0.1列出数据库中的所有表第一次启动从 Docker Hub 上下载的镜像，默认的数据库是 postgres 里面没有任何表，所以将 R 环境中的 mtcars 数据集写入 postgres 数据库将数据集 mtcars 写入 PostgreSQL 数据库中，基本操作，写入表的操作也不能缓存，即不能缓存数据库中的表 mtcars现在可以看到数据表 mtcars 的各个字段最后执行一条 SQL 语句或者一条命令搞定再复杂一点的 SQL 查询操作得益于 knitr [6] 开发的钩子，这里直接写 SQL 语句块，值得注意的是 SQL 代码块不能启用缓存，数据库连接通道也不能缓存，如果数据库中还没有写入表，那么写入表的操作也不能缓存， tab.cap = \"表格标题\" 输出的内容是一个表格如果将查询结果导出到变量，在 Chunk 设置 output.var = \"agg_cyl\" 可以使用缓存，下面将 mpg 按 cyl 分组聚合的结果打印出来，ref.label = \"mtcars\" 引用上一个 SQL 代码块的内容这种基于 odbc 的方式的好处就不需要再安装 R 包 RPostgres 和相关系统依赖，最后关闭连接通道","code":"docker pull postgresdocker run --name psql -d -p 8181:5432 -e ROOT=TRUE \\\n   -e USER=xiangyun -e PASSWORD=cloud postgressudo apt-get install unixodbc unixodbc-dev odbc-postgresqlodbcinst -j unixODBC 2.3.6\nDRIVERS............: /etc/odbcinst.ini\nSYSTEM DATA SOURCES: /etc/odbc.ini\nFILE DATA SOURCES..: /etc/ODBCDataSources\nUSER DATA SOURCES..: /root/.odbc.ini\nSQLULEN Size.......: 8\nSQLLEN Size........: 8\nSQLSETPOSIROW Size.: 8\nodbc::odbcListDrivers()                 name   attribute                                    value\n1     PostgreSQL ANSI Description    PostgreSQL ODBC driver (ANSI version)\n2     PostgreSQL ANSI      Driver                             psqlodbca.so\n3     PostgreSQL ANSI       Setup                          libodbcpsqlS.so\n4     PostgreSQL ANSI       Debug                                        0\n5     PostgreSQL ANSI     CommLog                                        1\n6     PostgreSQL ANSI  UsageCount                                        1\n7  PostgreSQL Unicode Description PostgreSQL ODBC driver (Unicode version)\n8  PostgreSQL Unicode      Driver                             psqlodbcw.so\n9  PostgreSQL Unicode       Setup                          libodbcpsqlS.so\n10 PostgreSQL Unicode       Debug                                        0\n11 PostgreSQL Unicode     CommLog                                        1\n12 PostgreSQL Unicode  UsageCount                                        1[PostgreSQL ANSI]\nDescription=PostgreSQL ODBC driver (ANSI version)\nDriver=psqlodbca.so\nSetup=libodbcpsqlS.so\nDebug=0\nCommLog=1\nUsageCount=1\n\n[PostgreSQL Unicode]\nDescription=PostgreSQL ODBC driver (Unicode version)\nDriver=psqlodbcw.so\nSetup=libodbcpsqlS.so\nDebug=0\nCommLog=1\nUsageCount=1[PostgreSQL]\nDriver              = PostgreSQL Unicode\nDatabase            = postgres\nServername          = 172.17.0.1\nUserName            = postgres\nPassword            = default\nPort                = 8080\nlibrary(DBI)\ncon <- dbConnect(RPostgres::Postgres(),\n  dbname = \"postgres\",\n  host = ifelse(is_on_travis, Sys.getenv(\"DOCKER_HOST_IP\"), \"192.168.99.101\"),\n  port = 8080,\n  user = \"postgres\",\n  password = \"default\"\n)\nlibrary(DBI)\ncon <- dbConnect(odbc::odbc(), \"PostgreSQL\")\ndbListTables(con)\ndbWriteTable(con, \"mtcars\", mtcars, overwrite = TRUE)\ndbListFields(con, \"mtcars\")\nres <- dbSendQuery(con, \"SELECT * FROM mtcars WHERE cyl = 4\") # 发送 SQL 语句\ndbFetch(res) # 获取查询结果\ndbClearResult(res) # 清理查询通道\ndbGetQuery(con, \"SELECT * FROM mtcars WHERE cyl = 4\")\ndbGetQuery(con, \"SELECT cyl, AVG(mpg) AS mpg FROM mtcars GROUP BY cyl ORDER BY cyl\")\naggregate(mpg ~ cyl, data = mtcars, mean)SELECT cyl, AVG(mpg) AS mpg FROM mtcars GROUP BY cyl ORDER BY cyl\ndbDisconnect(con)"},{"path":"chap-data-transportation.html","id":"mysql","chapter":"第 3 章 数据搬运","heading":"3.4.2 MySQL","text":"MySQL 是一个很常见，应用也很广泛的数据库，数据分析的常见环境是在一个R Notebook 里，我们可以在正文之前先设定数据库连接信息SQL 代码块中使用 R 环境中的变量，并将查询结果输出为R环境中的数据框以上代码会将 SQL 的运行结果存在 data_output 这是数据库中，idate 取之前设置的日期2019-05-03，user_table 是 MySQL 数据库中的表名，created_date 是创建user_table时，指定的日期名。如果 SQL 比较长，为了代码美观，把带有变量的 SQL 保存为demo.sql脚本，只需要在 SQL 的 chunk 中直接读取 SQL 文件13。如果我们需要每天或者按照指定的日期重复地运行这个 R Markdown 文件，可以在 YAML 部分引入参数14我们将这个 Rmd 文件命名为 MyDocument.Rmd，运行这个文件可以从 R 控制台执行或在 RStudio 点击 knit。如果在文档的 YAML 位置已经指定日期，这里可以不指定。注意在这里设置日期会覆盖 YAML 处指定的参数值，这样做的好处是可以批量化操作。","code":"```{r setup}\nlibrary(DBI)\n# 指定数据库连接信息\ndb <- dbConnect(RMySQL::MySQL(),\n  dbname = 'dbtest',\n  username = 'user_test',\n  password = 'password',\n  host = '10.10.101.10',\n  port = 3306\n)\n# 创建默认连接\nknitr::opts_chunk$set(connection = 'db')\n# 设置字符编码，以免中文查询乱码\nDBI::dbSendQuery(db, 'SET NAMES utf8')\n# 设置日期变量，以运用在SQL中\nidate <- '2019-05-03'\n``````{sql, output.var='data_output'}\nSELECT * FROM user_table where date_format(created_date,'%Y-%m-%d')>=?idate\n``````{sql, code=readLines('demo.sql'), output.var='data_output'}\n```---\nparams:\n  date: \"2019-05-03\"  # 参数化日期\n---```{r setup, include=FALSE}\nidate = params$date # 将参数化日期传递给 idate 变量\n```\nrmarkdown::render(\"MyDocument.Rmd\", params = list(\n  date = \"2019-05-03\"\n))"},{"path":"chap-data-transportation.html","id":"spark","chapter":"第 3 章 数据搬运","heading":"3.4.3 Spark","text":"当数据分析报告遇上 Spark 时，就需要 SparkR、 sparklyr、 arrow 或 rsparking 接口了， Javier Luraschi 写了一本书 R Spark: Learning Apache Spark R 详细介绍了相关扩展和应用首先安装 sparklyr 包，RStudio 公司 Javier Lurasch 开发了 sparklyr 包，作为 Spark 与 R 语言之间的接口，安装完 sparklyr 包，还是需要 Spark 和 Hadoop 环境既然 sparklyr 已经安装了 Spark 和 Hadoop 环境，安装 SparkR 后，只需配置好路径，就可以加载 SparkR 包rscala 架起了 R 和 Scala 两门语言之间交流的桥梁，使得彼此之间可以互相调用是否存在这样的可能， Spark 提供了大量的 MLib 库的调用接口，R 的功能支持是最少的，Java/Scala 是原生的，那么要么自己开发新的功能整合到 SparkR 中，要么借助 rscala 将 scala 接口代码封装进来在本地，Windows 主机上，可以在 .Rprofile 中给 Spark 添加环境变量 SPARK_HOME 指定其安装路径，将 R 环境中的数据集 mtcars 传递到 Spark 上监控和分析命令执行的情况，可以在浏览器中，见图 3.1\n图 3.1: Spark Web 接口\n传递 SQL 查询语句，比如数据集 mtcars 有多少行进一步地，我们可以调用 dplyr 包来写数据操作，避免写复杂逻辑的 SQL 语句，再举一个稍复杂的操作，先从数据集 cars 中选择两个字段 hp 和 mpg数据查询和结果可视化，见图 3.2\n图 3.2: 数据聚合和可视化\n用完要记得关闭连接不要使用 SparkR 接口，要使用 sparklyr， 后者的功能已经全面覆盖前者，生态方面更是更是已经远远超越，它有大厂 RStudio 支持，是公司支持的旗舰项目。但是 sparklyr 的版本稍微比最新的 Spark 低一两个版本，这是开发周期和出于稳定性的考虑，无伤大雅！Spark 提供了官方 R 语言接口 SparkR。Spark JVM 和 SparkR 包版本要匹配，比如从 CRAN 上安装了最新版的 SparkR，比如版本 2.4.4 就要去 Spark 官网下载最新版的预编译文件 spark-2.4.4-bin-hadoop2.7，解压到本地磁盘，比如 D:/spark-2.4.4-bin-hadoop2.7从数据集 mtcars（数据类型是 R 的 data.frame） 创建 Spark 的 DataFrame 类型数据打印数据集 cars 的 schema 各个字段的从本地 JSON 文件创建 DataFramepeopleDF 转成 Hive 中的表 people调用 sql 传递 SQL 语句查询数据，启动 sparkR.session 时，设置 enableHiveSupport = TRUE，就是执行不出来，报错，不知道哪里配置存在问题调用 collect 函数执行查询，并将结果返回到本地 data.frame 类型查看数据集 teenagersLocalDF 的属性最后，关闭 SparkSession 会话","code":"\ninstall.packages('sparklyr')\nlibrary(sparklyr)\nspark_install()\n# Installing Spark 2.4.0 for Hadoop 2.7 or later.\n# Downloading from:\n# - 'https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz'\n# Installing to:\n# - '~/spark/spark-2.4.0-bin-hadoop2.7'\n# trying URL 'https://archive.apache.org/dist/spark/spark-2.4.0/spark-2.4.0-bin-hadoop2.7.tgz'\n# Content type 'application/x-gzip' length 227893062 bytes (217.3 MB)\n# ==================================================\n# downloaded 217.3 MB\n# \n# Installation complete.\ninstall.packages('SparkR')\nif (nchar(Sys.getenv(\"SPARK_HOME\")) < 1) {\n  Sys.setenv(SPARK_HOME = \"~/spark/spark-2.4.0-bin-hadoop2.7\")\n}\nlibrary(SparkR, lib.loc = c(file.path(Sys.getenv(\"SPARK_HOME\"), \"R\", \"lib\")))\nsparkR.session(master = \"local[*]\", sparkConfig = list(spark.driver.memory = \"2g\"))\n# Windows 平台默认安装路径\nSys.setenv(SPARK_HOME = \"C:/Users/XiangYun/AppData/Local/spark/spark-2.4.3-bin-hadoop2.7\")\nlibrary(sparklyr)\nsc <- spark_connect(master = \"local\", version = \"2.4\")\ncars <- copy_to(sc, mtcars)\ncars# Source: spark<mtcars> [?? x 11]\n    mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n1  21       6   160   110  3.9   2.62  16.5     0     1     4     4\n2  21       6   160   110  3.9   2.88  17.0     0     1     4     4\n3  22.8     4   108    93  3.85  2.32  18.6     1     1     4     1\n4  21.4     6   258   110  3.08  3.22  19.4     1     0     3     1\n5  18.7     8   360   175  3.15  3.44  17.0     0     0     3     2\n6  18.1     6   225   105  2.76  3.46  20.2     1     0     3     1\n# ... with more rows\nspark_web(sc)\nlibrary(DBI)\ndbGetQuery(sc, \"SELECT count(*) FROM mtcars\")  count(1)\n1       32\n# library(dplyr) # 数据操作\nlibrary(tidyverse) # 提供更多功能，包括数据可视化\ncount(cars)\nselect(cars, hp, mpg) %>%\n  sample_n(100) %>% # 随机选择 100 行\n  collect() %>% # 执行 SQL 查询，将结果返回到本地\n  ggplot(aes(hp, mpg)) + # 绘图\n  geom_point()\nspark_disconnect(sc)\nSys.setenv(SPARK_HOME = \"D:/spark-2.4.4-bin-hadoop2.7\")\n# Sys.setenv(R_HOME = \"C:/Program Files/R/R-3.6.1/\")\nlibrary(SparkR, lib.loc = c(file.path(Sys.getenv(\"SPARK_HOME\"), \"R\", \"lib\")))\nsparkR.session(master = \"local[*]\", \n               sparkConfig = list(spark.driver.memory = \"4g\"), \n               enableHiveSupport = TRUE)\ncars <- as.DataFrame(mtcars)\n# 显示 SparkDataFrame 的前几行\nhead(cars) mpg cyl disp  hp drat    wt  qsec vs am gear carb\n1 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4\n2 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4\n3 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1\n4 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1\n5 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2\n6 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1\nprintSchema(cars)root\n |-- mpg: double (nullable = true)\n |-- cyl: double (nullable = true)\n |-- disp: double (nullable = true)\n |-- hp: double (nullable = true)\n |-- drat: double (nullable = true)\n |-- wt: double (nullable = true)\n |-- qsec: double (nullable = true)\n |-- vs: double (nullable = true)\n |-- am: double (nullable = true)\n |-- gear: double (nullable = true)\n |-- carb: double (nullable = true)\npath <- file.path(Sys.getenv(\"SPARK_HOME\"), \"examples/src/main/resources/people.json\")\npeopleDF <- read.json(path)\nprintSchema(peopleDF)root\n |-- age: long (nullable = true)\n |-- name: string (nullable = true)\npeopleDFSparkDataFrame[age:bigint, name:string]\nshowDF(peopleDF)+----+-------+\n| age|   name|\n+----+-------+\n|null|Michael|\n|  30|   Andy|\n|  19| Justin|\n+----+-------+\ncreateOrReplaceTempView(peopleDF, \"people\")\nteenagers <- SparkR::sql(\"SELECT name FROM people WHERE age >= 13 AND age <= 19\")\nshow(people)Error in handleErrors(returnStatus, conn) : \n  org.apache.spark.sql.AnalysisException: java.lang.RuntimeException: java.io.IOException: (null) entry in command string: null chmod 0733 F:\\tmp\\hive;\n    at org.apache.spark.sql.hive.HiveExternalCatalog.withClient(HiveExternalCatalog.scala:106)\n    at org.apache.spark.sql.hive.HiveExternalCatalog.databaseExists(HiveExternalCatalog.scala:214)\n    at org.apache.spark.sql.internal.SharedState.externalCatalog$lzycompute(SharedState.scala:114)\n    at org.apache.spark.sql.internal.SharedState.externalCatalog(SharedState.scala:102)\n    at org.apache.spark.sql.internal.SharedState.globalTempViewManager$lzycompute(SharedState.scala:141)\n    at org.apache.spark.sql.internal.SharedState.globalTempViewManager(SharedState.scala:136)\n    at org.apache.spark.sql.hive.HiveSessionStateBuilder$$anonfun$2.apply(HiveSessionStateBuilder.scala:55)\n    at org.apache.spark.sql.hive.HiveSessionStateBuilder$$anonfun$2.apply(HiveSessionStateBuilder.scala:55)\n    at org.apache.spark.sql.catalyst.catalog.SessionCatalog.gl\nteenagersLocalDF <- collect(teenagers)\nprint(teenagersLocalDF)\nsparkR.session.stop()"},{"path":"chap-data-transportation.html","id":"batch-import-data","chapter":"第 3 章 数据搬运","heading":"3.5 批量导入数据","text":"批量导入文件扩展名为 .csv 的数据文件，即逗号分割的文件相比于 Base R 提供的 read.csv 函数，使用 readr 包的 read_csv 函数可以更快地读取csv格式文件，特别是在读取GB级数据文件时，效果特别明显。使用 tibble 包的glimpse函数可以十分方便地对整个数据集有一个大致的了解，展示方式和信息量相当于 str 加 head 函数","code":"\nlibrary(tidyverse)\nread_list <- function(list_of_datasets, read_func) {\n  read_and_assign <- function(dataset, read_func) {\n    dataset_name <- as.name(dataset)\n    dataset_name <- read_func(dataset)\n  }\n\n  # invisible is used to suppress the unneeded output\n  output <- invisible(\n    sapply(list_of_datasets,\n      read_and_assign,\n      read_func = read_func, simplify = FALSE, USE.NAMES = TRUE\n    )\n  )\n\n  # Remove the extension at the end of the data set names\n  names_of_datasets <- c(unlist(strsplit(list_of_datasets, \"[.]\"))[c(T, F)])\n  names(output) <- names_of_datasets\n  return(output)\n}\ndata_files <- list.files(path = \"path/to/csv/dir\",\n                         pattern = \".csv\", full.names = TRUE)\nprint(data_files)\nlist_of_data_sets <- read_list(data_files, readr::read_csv)\ntibble::glimpse(list_of_data_sets)"},{"path":"chap-data-transportation.html","id":"batch-export-data","chapter":"第 3 章 数据搬运","heading":"3.6 批量导出数据","text":"假定我们有一个列表，其每个元素都是一个数据框，现在要把每个数据框分别存入 xlsx 表的工作薄中，以 mtcars 数据集为例，将其按分类变量 cyl 分组拆分，获得一个列表 list将 xlsx 表格初始化，创建空白的工作薄， openxlsx 包不依赖 Java 环境，读写效率也高将列表里的每张表分别存入 xlsx 表格的每个 worksheet，worksheet 的名字就是分组变量的名字最后保存数据到磁盘，见图 3.3\n图 3.3: 批量导出数据\n","code":"\ndat <- split(mtcars, mtcars$cyl)\ndat## $`4`\n##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n## Merc 240D      24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\n## Merc 230       22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\n## Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n## Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n## Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n## Toyota Corona  21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n## Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n## Porsche 914-2  26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n## Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n## Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n## \n## $`6`\n##                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## Mazda RX4      21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## Mazda RX4 Wag  21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## Hornet 4 Drive 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n## Valiant        18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\n## Merc 280       19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## Merc 280C      17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n## Ferrari Dino   19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n## \n## $`8`\n##                      mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## Hornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n## Duster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\n## Merc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\n## Merc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\n## Merc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\n## Cadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\n## Lincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\n## Chrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\n## Dodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\n## AMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\n## Camaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\n## Pontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\n## Ford Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n## Maserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\n## 加载 openxlsx 包\nlibrary(openxlsx)\n## 创建空白的工作薄\nwb <- createWorkbook()\nMap(function(data, name){\n    addWorksheet(wb, name)\n    writeData(wb, name, data)\n \n}, dat, names(dat))\nsaveWorkbook(wb, file = \"data/matcars.xlsx\", overwrite = TRUE)"},{"path":"chap-data-transportation.html","id":"export-data","chapter":"第 3 章 数据搬运","heading":"3.7 导出数据","text":"","code":""},{"path":"chap-data-transportation.html","id":"export-output","chapter":"第 3 章 数据搬运","heading":"3.7.1 导出运行结果","text":"capture.output 将一段R代码执行结果，保存到文件，参数为表达式。capture.output 和 sink 的关系相当于 和 attach 的关系。sink 函数将控制台输出结果保存到文件，只将 outer 函数运行的结果保存到 ex-sink.txt 文件，outer 函数计算的是直积，在这里相当于 seq(10) %*% t(seq(10))，而在 R 语言中，更加有效的计算方式是 tcrossprod(seq(10),seq(10))","code":"\ncapture.output(..., file = NULL, append = FALSE,\n               type = c(\"output\", \"message\"), split = FALSE)\nglmout <- capture.output(summary(glm(case ~ spontaneous + induced,\n  data = infert, family = binomial()\n)), file = \"data/capture.txt\")\ncapture.output(1 + 1, 2 + 2)## [1] \"[1] 2\" \"[1] 4\"\ncapture.output({\n  1 + 1\n  2 + 2\n})## [1] \"[1] 4\"\nsink(\"data/ex-sink.txt\")\ni <- 1:10\nouter(i, i, \"*\") ##       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n##  [1,]    1    2    3    4    5    6    7    8    9    10\n##  [2,]    2    4    6    8   10   12   14   16   18    20\n##  [3,]    3    6    9   12   15   18   21   24   27    30\n##  [4,]    4    8   12   16   20   24   28   32   36    40\n##  [5,]    5   10   15   20   25   30   35   40   45    50\n##  [6,]    6   12   18   24   30   36   42   48   54    60\n##  [7,]    7   14   21   28   35   42   49   56   63    70\n##  [8,]    8   16   24   32   40   48   56   64   72    80\n##  [9,]    9   18   27   36   45   54   63   72   81    90\n## [10,]   10   20   30   40   50   60   70   80   90   100\nsink()"},{"path":"chap-data-transportation.html","id":"export-data-object","chapter":"第 3 章 数据搬运","heading":"3.7.2 导出数据对象","text":"load 和save 函数加载或保存包含工作环境信息的数据对象，save.image 保存当前工作环境到磁盘，即保存工作空间中所有数据对象，数据格式为 .RData，即相当于dump 保存数据对象 AirPassengers 到文件 AirPassengers.txt，文件内容是 R 命令，可把AirPassengers.txt看作代码文档执行，dput 保存数据对象内容到文件AirPassengers.dat，文件中不包含变量名 AirPassengers。注意到 dump 输入是一个字符串，而 dput 要求输入数据对象的名称，source 函数与 dump 对应，而 dget 与 dput对应。接下来，我们读取 AirPassengers.txt 的文件内容，可见它是一段完整的 R 代码，可以直接复制到 R 的控制台中运行，并且得到一个与原始 AirPassengers 变量一样的结果dput 函数类似 dump 函数，保存数据对象到磁盘文件同样地，现在我们观察 dput 函数保存的文件 AirPassengers.dat 内容，和dump 函数保存的文件 AirPassengers.txt相比，就缺一个赋值变量openxlsx 可以读写 XLSX 文档美团使用的大数据工具有很多，最常用的 Hive、Spark、Kylin、Impala、Presto 等，详见 https://tech.meituan.com/2018/08/02/mt-r-practice.html。下面主要介绍如何在 R 中连接 MySQL、Presto 和 Spark。sparklyr.flint 支持 Spark 的时间序列库 flint，sparkxgb 为 Spark 上的 XGBoost 提供 R 接口，sparkwarc 支持加载 Web ARChive 文件到 Spark 里\nsparkavro 支持从 Apache Avro (https://avro.apache.org/) 读取文件到 Spark 里，sparkbq 是一个 sparkly 扩展包，集成 Google BigQuery 服务，geospark 提供 GeoSpark 库的 R 接口，并且以 sf 的数据操作方式，rsparkling H2O Sparkling Water 机器学习库的 R 接口。Spark 性能优化，参考三篇博文Spark在美团的实践Spark性能优化指南——基础篇Spark性能优化指南——高级篇其他材料朱俊晖收集的 Spark 资源列表 https://github.com/harryprince/awesome-sparklyr，推荐使用 sparklyr https://github.com/sparklyr/sparklyr 连接 SparkSpark 与 R 语言 https://docs.microsoft.com/en-us/azure/databricks/spark/latest/sparkr/Mastering Spark R https://therinspark.com/","code":"\nload(file, envir = parent.frame(), verbose = FALSE)\n\nsave(..., list = character(),\n     file = stop(\"'file' must be specified\"),\n     ascii = FALSE, version = NULL, envir = parent.frame(),\n     compress = isTRUE(!ascii), compression_level,\n     eval.promises = TRUE, precheck = TRUE)\n\nsave.image(file = \".RData\", version = NULL, ascii = FALSE,\n           compress = !ascii, safe = TRUE)\nsave(list = ls(all.names = TRUE), file = \".RData\", envir = .GlobalEnv)\n# 加载数据\ndata(AirPassengers, package = \"datasets\")\n# 将数据以R代码块的形式保存到文件\ndump('AirPassengers', file = 'data/AirPassengers.txt') \n# source(file = 'data/AirPassengers.txt')\ncat(readLines('data/AirPassengers.txt'), sep = \"\\n\")## AirPassengers <-\n## structure(c(112, 118, 132, 129, 121, 135, 148, 148, 136, 119, \n## 104, 118, 115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, \n## 140, 145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166, \n## 171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194, 196, \n## 196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201, 204, 188, \n## 235, 227, 234, 264, 302, 293, 259, 229, 203, 229, 242, 233, 267, \n## 269, 270, 315, 364, 347, 312, 274, 237, 278, 284, 277, 317, 313, \n## 318, 374, 413, 405, 355, 306, 271, 306, 315, 301, 356, 348, 355, \n## 422, 465, 467, 404, 347, 305, 336, 340, 318, 362, 348, 363, 435, \n## 491, 505, 404, 359, 310, 337, 360, 342, 406, 396, 420, 472, 548, \n## 559, 463, 407, 362, 405, 417, 391, 419, 461, 472, 535, 622, 606, \n## 508, 461, 390, 432), tsp = c(1949, 1960.9166666666699, 12), class = \"ts\")\n# 将 R 对象保存/导出到磁盘\ndput(AirPassengers, file = 'data/AirPassengers.dat')\nAirPassengers     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949 112 118 132 129 121 135 148 148 136 119 104 118\n1950 115 126 141 135 125 149 170 170 158 133 114 140\n1951 145 150 178 163 172 178 199 199 184 162 146 166\n1952 171 180 193 181 183 218 230 242 209 191 172 194\n1953 196 196 236 235 229 243 264 272 237 211 180 201\n1954 204 188 235 227 234 264 302 293 259 229 203 229\n1955 242 233 267 269 270 315 364 347 312 274 237 278\n1956 284 277 317 313 318 374 413 405 355 306 271 306\n1957 315 301 356 348 355 422 465 467 404 347 305 336\n1958 340 318 362 348 363 435 491 505 404 359 310 337\n1959 360 342 406 396 420 472 548 559 463 407 362 405\n1960 417 391 419 461 472 535 622 606 508 461 390 432\n# dget 作用与 dput 相反\nAirPassengers2 <- dget(file = 'data/AirPassengers.dat')\nAirPassengers2     Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n1949 112 118 132 129 121 135 148 148 136 119 104 118\n1950 115 126 141 135 125 149 170 170 158 133 114 140\n1951 145 150 178 163 172 178 199 199 184 162 146 166\n1952 171 180 193 181 183 218 230 242 209 191 172 194\n1953 196 196 236 235 229 243 264 272 237 211 180 201\n1954 204 188 235 227 234 264 302 293 259 229 203 229\n1955 242 233 267 269 270 315 364 347 312 274 237 278\n1956 284 277 317 313 318 374 413 405 355 306 271 306\n1957 315 301 356 348 355 422 465 467 404 347 305 336\n1958 340 318 362 348 363 435 491 505 404 359 310 337\n1959 360 342 406 396 420 472 548 559 463 407 362 405\n1960 417 391 419 461 472 535 622 606 508 461 390 432\ncat(readLines('data/AirPassengers.dat'), sep = \"\\n\")structure(c(112, 118, 132, 129, 121, 135, 148, 148, 136, 119, \n104, 118, 115, 126, 141, 135, 125, 149, 170, 170, 158, 133, 114, \n140, 145, 150, 178, 163, 172, 178, 199, 199, 184, 162, 146, 166, \n171, 180, 193, 181, 183, 218, 230, 242, 209, 191, 172, 194, 196, \n196, 236, 235, 229, 243, 264, 272, 237, 211, 180, 201, 204, 188, \n235, 227, 234, 264, 302, 293, 259, 229, 203, 229, 242, 233, 267, \n269, 270, 315, 364, 347, 312, 274, 237, 278, 284, 277, 317, 313, \n318, 374, 413, 405, 355, 306, 271, 306, 315, 301, 356, 348, 355, \n422, 465, 467, 404, 347, 305, 336, 340, 318, 362, 348, 363, 435, \n491, 505, 404, 359, 310, 337, 360, 342, 406, 396, 420, 472, 548, \n559, 463, 407, 362, 405, 417, 391, 419, 461, 472, 535, 622, 606, \n508, 461, 390, 432), tsp = c(1949, 1960.91666666667, 12), class = \"ts\")"},{"path":"chap-data-transportation.html","id":"sec-spark-with-r","chapter":"第 3 章 数据搬运","heading":"3.8 Spark 与 R 语言","text":"","code":""},{"path":"chap-data-transportation.html","id":"subsec-sparklyr","chapter":"第 3 章 数据搬运","heading":"3.8.1 sparklyr","text":"Spark 依赖特定版本的 Java、Hadoop，三者之间的版本应该要相融。在 MacOS 上配置 Java 环境，注意 Spark 仅支持 Java 8 至 11，所以安装指定版本的 Java 开发环境配置 R 环境，让 R 能够识别 Java 环境，再安装 rJava 包最后安装 sparklyr 包，以及 Spark 环境，可以借助 spark_install() 安装 Spark，比如下面 Spark 3.0 连同 hadoop 2.7 一起安装。也可以先手动下载 Spark 软件环境，建议选择就近镜像站点下载，比如在北京选择清华站点\nhttps://mirrors.tuna.tsinghua.edu.cn/apache/spark/spark-3.0.1/spark-3.0.1-bin-hadoop2.7.tgz，此环境自带 R 和 Python 接口。为了供 sparklyr 调用，先设置 SPARK_HOME 环境变量指向 Spark 安装位置，再连接单机版 Spark。做数据的聚合统计，有两种方式。一种是使用用 R 包 dplyr 提供的数据操作语法，下面以按 cut 分组统计钻石的数量为例，说明 dplyr 提供的数据操作方式。另一种是使用结构化查询语言 SQL，这自不必说，大多数情况下，使用和一般的 SQL 没什么两样。 \n将结果数据用 ggplot2 呈现出来diamonds 数据集总共 53940 条数据，下面用 BUCKET 分桶抽样，将原数据随机分成 1000 个桶，取其中的一个桶，由于是随机分桶，所以每次的结果都不一样，解释详见https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-sampling.html将抽样的结果用窗口函数 RANK() 排序，详见 https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-window.html窗口函数 https://www.cnblogs.com/ZackSun/p/9713435.htmlLATERAL VIEW 把一列拆成多行https://liam.page/2020/03/09/LATERAL-VIEW--Hive-SQL/\nhttps://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-lateral-view.html创建数据集查看数据集行列转换 https://www.cnblogs.com/kimbo/p/6208973.html，LATERAL VIEW 展开日期相关的函数 https://spark.apache.org/docs/latest/sql-ref-functions-builtin.html#date--timestamp-functions最后，使用完记得关闭 Spark 连接","code":"# 安装 openjdk 11\nbrew install openjdk@11\n# 全局设置 JDK 11\nsudo ln -sfn /usr/local/opt/openjdk@11/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk-11.jdk\n# Java 11 JDK 添加到 .zshrc \nexport CPPFLAGS=\"-I/usr/local/opt/openjdk@11/include\"\nexport PATH=\"/usr/local/opt/openjdk@11/bin:$PATH\"# 配置\nsudo R CMD javareconf\n# 系统软件依赖\nbrew install pcre2\n# 安装 rJava\nRscript -e 'install.packages(\"rJava\", type=\"source\")'\ninstall.packages('sparklyr')\nsparklyr::spark_install(version = '3.0', hadoop_version = '2.7')\n# 排错 https://github.com/sparklyr/sparklyr/issues/2827\noptions(sparklyr.log.console = FALSE)\n# 连接 Spark \nlibrary(sparklyr)\nlibrary(ggplot2)\nsc <- spark_connect(\n  master = \"local\",\n  # config = list(sparklyr.gateway.address = \"127.0.0.1\"),\n  spark_home = Sys.getenv(\"SPARK_HOME\")\n)\n# diamonds 数据集导入 Spark\ndiamonds_tbl <- copy_to(sc, ggplot2::diamonds, \"diamonds\")\nlibrary(dplyr)\n# 列出数据源下所有的表 tbls\nsrc_tbls(sc)\n\ndiamonds_tbl <- diamonds_tbl %>%\n  group_by(cut) %>%\n  summarise(cnt = n()) %>%\n  collect\nlibrary(DBI)\ndiamonds_preview <- dbGetQuery(sc, \"SELECT count(*) as cnt, cut FROM diamonds GROUP BY cut\")\ndiamonds_preview##     cnt       cut\n## 1 21551     Ideal\n## 2 13791   Premium\n## 3  4906      Good\n## 4  1610      Fair\n## 5 12082 Very Good\n# SQL 中的 AVG 和 R 中的 mean 函数是类似的\ndiamonds_price <- dbGetQuery(sc, \"SELECT AVG(price) as mean_price, cut FROM diamonds GROUP BY cut\")\ndiamonds_price##   mean_price       cut\n## 1   3457.542     Ideal\n## 2   4584.258   Premium\n## 3   3928.864      Good\n## 4   4358.758      Fair\n## 5   3981.760 Very Good\nlibrary(ggplot2)\nlibrary(data.table)\ndiamonds <- as.data.table(diamonds)\ndiamonds[,.(mean_price = mean(price)), by = .(cut)]##          cut mean_price\n## 1:     Ideal   3457.542\n## 2:   Premium   4584.258\n## 3:      Good   3928.864\n## 4: Very Good   3981.760\n## 5:      Fair   4358.758\nggplot(diamonds_preview, aes(cut, cnt)) +\n  geom_col() +\n  theme_minimal()\ndiamonds_sample <- dbGetQuery(sc, \"SELECT * FROM diamonds TABLESAMPLE (BUCKET 1 OUT OF 1000) LIMIT 6\")\ndiamonds_sample##   carat       cut color clarity depth table price    x    y    z\n## 1  0.90   Premium     G     SI1  60.6    62  2830 6.21 6.13 3.74\n## 2  0.71     Ideal     E     VS1  62.4    56  2877 5.75 5.70 3.57\n## 3  0.70 Very Good     D     VS2  63.1    56  2985 5.62 5.69 3.57\n## 4  0.83     Ideal     H     VS2  61.3    54  3027 6.06 6.10 3.73\n## 5  0.70     Ideal     E     VS2  62.6    56  3068 5.65 5.69 3.55\n## 6  0.80 Very Good     E     SI2  62.6    59  3070 5.84 5.91 3.68\ndiamonds_rank <- dbGetQuery(sc, \"\n  SELECT cut, price, RANK() OVER (PARTITION BY cut ORDER BY price) AS rank \n  FROM diamonds TABLESAMPLE (BUCKET 1 OUT OF 1000)\n  LIMIT 6\n\")\ndiamonds_rank##    cut price rank\n## 1 Fair  3299    1\n## 2 Fair  7303    2\n## 3 Good   720    1\n## 4 Good   763    2\n## 5 Good  1600    3\n## 6 Good  2396    4\n# 先删除存在的表 person\ndbGetQuery(sc, \"DROP TABLE IF EXISTS person\")\n# 创建表 person\ndbGetQuery(sc, \"CREATE TABLE IF NOT EXISTS person (id INT, name STRING, age INT, class INT, address STRING)\")\n# 插入数据到表 person\ndbGetQuery(sc, \"\nINSERT INTO person VALUES\n    (100, 'John', 30, 1, 'Street 1'),\n    (200, 'Mary', NULL, 1, 'Street 2'),\n    (300, 'Mike', 80, 3, 'Street 3'),\n    (400, 'Dan', 50, 4, 'Street 4')\n\")\ndbGetQuery(sc, \"SELECT * FROM person\")##    id name age class  address\n## 1 300 Mike  80     3 Street 3\n## 2 400  Dan  50     4 Street 4\n## 3 100 John  30     1 Street 1\n## 4 200 Mary  NA     1 Street 2\ndbGetQuery(sc,\"\nSELECT * FROM person\n    LATERAL VIEW EXPLODE(ARRAY(30, 60)) tabelName AS c_age\n    LATERAL VIEW EXPLODE(ARRAY(40, 80)) AS d_age\nLIMIT 6\n\")##    id name age class  address c_age d_age\n## 1 300 Mike  80     3 Street 3    30    40\n## 2 300 Mike  80     3 Street 3    30    80\n## 3 300 Mike  80     3 Street 3    60    40\n## 4 300 Mike  80     3 Street 3    60    80\n## 5 400  Dan  50     4 Street 4    30    40\n## 6 400  Dan  50     4 Street 4    30    80\n# 今天\ndbGetQuery(sc, \"select current_date\")##   current_date()\n## 1     2022-06-10\n# 昨天\ndbGetQuery(sc, \"select date_sub(current_date, 1)\")##   date_sub(current_date(), 1)\n## 1                  2022-06-09\n# 本月最后一天 current_date 所属月份的最后一天\ndbGetQuery(sc, \"select last_day(current_date)\")##   last_day(current_date())\n## 1               2022-06-30\n# 星期几\ndbGetQuery(sc, \"select dayofweek(current_date)\")##   dayofweek(current_date())\n## 1                         6\nspark_disconnect(sc)"},{"path":"chap-data-transportation.html","id":"subsec-sparkr","chapter":"第 3 章 数据搬运","heading":"3.8.2 SparkR","text":"考虑到和第3.8.1节的重合性，以及 sparklyr 的优势，本节代码都不会执行，仅作为补充信息予以描述。完整的介绍见 SparkR 包SparkR 要求 Java 版本满足：大于等于8，而小于12，本地 MacOS 安装高版本，比如 oracle-jdk 16.0.1 会报不兼容的错误。sparkConfig 有哪些参数可以传递将 data.frame 转化为 SparkDataFrameSparkDataFrame查看结构","code":"\nif (nchar(Sys.getenv(\"SPARK_HOME\")) < 1) {\n  Sys.setenv(SPARK_HOME = \"/opt/spark/spark-3.0.1-bin-hadoop2.7\")\n}\nlibrary(SparkR, lib.loc = c(file.path(Sys.getenv(\"SPARK_HOME\"), \"R\", \"lib\")))\nsparkR.session(master = \"local[*]\", sparkConfig = list(spark.driver.memory = \"2g\"))Spark package found in SPARK_HOME: /opt/spark/spark-3.1.1-bin-hadoop3.2\nError in checkJavaVersion() : \n  Java version, greater than or equal to 8 and less than 12, is required for this package; found version: 16.0.1\nfaithful_sdf <- as.DataFrame(faithful)\nhead(faithful_sdf)\nstr(faithful_sdf)"},{"path":"chap-data-transportation.html","id":"sec-database-with-r","chapter":"第 3 章 数据搬运","heading":"3.9 数据库与 R 语言","text":"Presto 的 R 接口 https://github.com/prestodb/RPresto 和文档 https://prestodb.io/docs/current/index.html，Presto 数据库MySQL 为例介绍 odbc 的连接和使用，详见 从 R 连接 MySQL我的系统已经安装了多款数据库的 ODBC 驱动","code":"\ninstall.packages('RPresto')-- !preview conn=DBI::dbConnect(odbc::odbc(),  driver = \"MariaDB\", database = \"demo\", \n--                              uid = \"root\", pwd = \"cloud\", host = \"localhost\", port = 3306)\n\nSELECT * FROM mtcars\nLIMIT 10dnf install -y unixODBC unixODBC-devel mariadb mariadb-server mariadb-devel mariadb-connector-odbc\nodbc::odbcListDrivers()# Driver from the mariadb-connector-odbc package\n# Setup from the unixODBC package\n[MariaDB]\nDescription     = ODBC for MariaDB\nDriver          = /usr/lib/libmaodbc.so\nDriver64        = /usr/lib64/libmaodbc.so\nFileUsage       = 1"},{"path":"chap-data-transportation.html","id":"sec-batch-import-csv","chapter":"第 3 章 数据搬运","heading":"3.10 批量读取 csv 文件","text":"iris 数据转化为 data.table 类型，按照 Species 分组拆成单独的 csv 文件，各个文件的文件名用鸢尾花的类别名表示读取文件夹 data/ 所有 csv 数据文件","code":"\n# 批量分组导出\nlibrary(data.table)\nas.data.table(iris)[, fwrite(.SD, paste0(\"data/user_\", unique(Species), \".csv\")), by = Species, .SDcols = colnames(iris)]\nlibrary(data.table)\nmerged_df <- do.call('rbind', lapply(list.files(pattern = \"*.csv\", path = \"data/\"), fread ) )\n# 或者\nmerged_df <- rbindlist(lapply(list.files(pattern = \"*.csv\", path = \"data/\"), fread ))\nxdf$date <- as.Date(xdf$date)\nxdf$ts <- as.POSIXct(as.numeric(xdf$ts), origin = \"1978-01-01\")\nsplit(xdf[order(xdf$ts), ], interaction(xdf$study, xdf$port)) %>%\n  lapply(function(.x) {\n    .x[nrow(.x), ]\n  }) %>%\n  unname() %>%\n  Filter(function(.x) {\n    nrow(.x) > 0\n  }, .) %>%\n  do.call(rbind.data.frame, .)\n\nlibrary(dplyr)\nxdf %>%\n  mutate(\n    date = as.Date(date),\n    ts = anytime::anytime(as.numeric(ts))\n  ) %>%\n  arrange(ts) %>%\n  group_by(study, port) %>%\n  slice(n()) %>%\n  ungroup()\nlibrary(tibble)\nlibrary(magrittr)\n\nmtcars <- tibble(mtcars)\n\nmtcars %>% \n  print(n = 16, width = 69)## # A tibble: 32 × 11\n##      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n##    <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n##  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n##  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n##  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n##  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n##  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n##  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n##  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n##  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n##  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n## 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n## 11  17.8     6  168.   123  3.92  3.44  18.9     1     0     4     4\n## 12  16.4     8  276.   180  3.07  4.07  17.4     0     0     3     3\n## 13  17.3     8  276.   180  3.07  3.73  17.6     0     0     3     3\n## 14  15.2     8  276.   180  3.07  3.78  18       0     0     3     3\n## 15  10.4     8  472    205  2.93  5.25  18.0     0     0     3     4\n## 16  10.4     8  460    215  3     5.42  17.8     0     0     3     4\n## # … with 16 more rows\nmtcars %>% \n  print(., n = nrow(.)/4)## # A tibble: 32 × 11\n##     mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n##   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n## 1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n## 2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n## 3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n## 4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n## 5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n## 6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n## 7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n## 8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n## # … with 24 more rows"},{"path":"chap-data-transportation.html","id":"sec-batch-export-xlsx","chapter":"第 3 章 数据搬运","heading":"3.11 批量导出 xlsx 文件","text":"将 R 环境中的数据集导出为 xlsx 表格","code":"\n## 加载 openxlsx 包\nlibrary(openxlsx)\n## 创建空白的工作薄，标题为鸢尾花数据集\nwb <- createWorkbook(title = \"鸢尾花数据集\")\n## 添加 sheet 页\naddWorksheet(wb, sheetName = \"iris\")\n# 将数据写进 sheet 页\nwriteData(wb, sheet = \"iris\", x = iris, colNames = TRUE)\n# 导出数据到本地\nsaveWorkbook(wb, file = \"iris.xlsx\", overwrite = TRUE)\nlibrary(openxlsx)\nxlsxFile <- system.file(\"extdata\", \"readTest.xlsx\", package = \"openxlsx\")\n# 导入\ndat = read.xlsx(xlsxFile = xlsxFile)\n# 导出\nwrite.xlsx(dat, xlsxfile)"},{"path":"chap-data-transportation.html","id":"dm-session-info","chapter":"第 3 章 数据搬运","heading":"3.12 运行环境","text":"","code":"\nxfun::session_info()## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-pc-linux-gnu (64-bit)\n## Running under: Ubuntu 20.04.4 LTS\n## \n## Locale:\n##   LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n##   LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n##   LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n##   LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n##   LC_ADDRESS=C               LC_TELEPHONE=C            \n##   LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n## \n## Package version:\n##   askpass_1.1        assertthat_0.2.1   base64enc_0.1-3    blob_1.2.3        \n##   bookdown_0.26      brio_1.1.3         bslib_0.3.1        cachem_1.0.6      \n##   cli_3.3.0          codetools_0.2.18   colorspace_2.0-3   compiler_4.2.0    \n##   config_0.3.1       cpp11_0.4.2        crayon_1.5.1       curl_4.3.2        \n##   data.table_1.14.2  DBI_1.1.2          dbplyr_2.1.1       desc_1.4.1        \n##   digest_0.6.29      downlit_0.4.0      dplyr_1.0.9        ellipsis_0.3.2    \n##   evaluate_0.15      fansi_1.0.3        farver_2.1.0       fastmap_1.1.0     \n##   forge_0.2.0        fs_1.5.2           generics_0.1.2     ggplot2_3.3.6     \n##   globals_0.15.0     glue_1.6.2         graphics_4.2.0     grDevices_4.2.0   \n##   grid_4.2.0         gtable_0.3.0       highr_0.9          htmltools_0.5.2   \n##   htmlwidgets_1.5.4  httr_1.4.3         isoband_0.2.5      jquerylib_0.1.4   \n##   jsonlite_1.8.0     knitr_1.39         labeling_0.4.2     lattice_0.20.45   \n##   lifecycle_1.0.1    magrittr_2.0.3     MASS_7.3.57        Matrix_1.4.1      \n##   memoise_2.0.1      methods_4.2.0      mgcv_1.8.40        mime_0.12         \n##   munsell_0.5.0      nlme_3.1.157       openssl_2.0.1      parallel_4.2.0    \n##   pillar_1.7.0       pkgconfig_2.0.3    png_0.1-7          purrr_0.3.4       \n##   r2d3_0.2.6         R6_2.5.1           rappdirs_0.3.3     RColorBrewer_1.1.3\n##   rlang_1.0.2        rmarkdown_2.14     rprojroot_2.0.3    rstudioapi_0.13   \n##   sass_0.4.1         scales_1.2.0       sparklyr_1.7.5     splines_4.2.0     \n##   stats_4.2.0        stringi_1.7.6      stringr_1.4.0      sys_3.4           \n##   sysfonts_0.8.8     tibble_3.1.7       tidyr_1.2.0        tidyselect_1.1.2  \n##   tinytex_0.39       tools_4.2.0        utf8_1.2.2         utils_4.2.0       \n##   uuid_1.1.0         vctrs_0.4.1        viridisLite_0.4.0  withr_2.5.0       \n##   xfun_0.31          xml2_1.3.3         yaml_2.3.5"},{"path":"chap-string-operations.html","id":"chap-string-operations","chapter":"第 4 章 字符串操作","heading":"第 4 章 字符串操作","text":"Handling Strings R 和 R Data Science 提供字符串入门介绍 ，Sara Stoudt 整理了 stringr 包与 Base R 正则表达式函数的对应表 https://stringr.tidyverse.org/articles/-base.htmlstringr 基于 stringi 包字符串处理包， re2r 包基于 Google 开发的 C++ 库 re2，Google 编程之夏项目提供了一份 正则表达式性能综述， stringdist Approximate String Matching String Distance Functions 近似字符串匹配和字符串距离计算函数 [11]janitorManipulating strings stringr packagefilesstrings 基于 stringr 操作字符串strex 一些没有包含在 stringr 或者 stringi 中的字符串操作函数tidytext Text mining using dplyr, ggplot2, tidy toolsstringdist\nstringfish\nstringb\nstringi\nstringr字符和字符串类型的数据值得单独拿出来讲，不仅因为内容多，而且比较难，应用范围最广，特别是面对文本类型的数据时，几乎是避不开的！R 的前身是 S，S 的前身是一些 Fortran 和 C 子程序，最早在贝尔实验室是用于文本分析领域，因此在 R 基础包中提供了丰富的字符串处理函数，你可以在R控制台中执行如下一行命令查看本章主要介绍 R 内置的字符串操作函数","code":"\nhelp.search(keyword = \"character\", package = \"base\")"},{"path":"chap-string-operations.html","id":"base-count","chapter":"第 4 章 字符串操作","heading":"4.1 字符数统计","text":"nchar 函数统计字符串向量中每个元素的字符个数，注意与函数length 的差别，它统计向量中元素的个数，即向量的长度。一些特殊的情况","code":"\nnchar(c(\"Hello\", \"world\", \"!\"))## [1] 5 5 1\nR.version.string## [1] \"R version 4.2.0 (2022-04-22)\"\nnchar(R.version.string)## [1] 28\ndeparse(base::mean)## [1] \"function (x, ...) \"  \"UseMethod(\\\"mean\\\")\"\nnchar(deparse(base::mean))## [1] 18 17\nnchar(\"\")## [1] 0\nnchar(NULL)## integer(0)\nnchar(0)## [1] 1\npi## [1] 3.141593\nnchar(pi)## [1] 16\nexp(1)## [1] 2.718282\nnchar(exp(1))## [1] 16\nnchar(NA)## [1] NA"},{"path":"chap-string-operations.html","id":"base-translations","chapter":"第 4 章 字符串操作","heading":"4.2 字符串翻译","text":"tolower 将字符串或字符串向量中含有的大写字母全都转化为小写， toupper 函数正好与之相反.","code":"\ntolower(c(\"HELLO\", \"Hello, R\", \"hello\"))## [1] \"hello\"    \"hello, r\" \"hello\"\ntoupper(c(\"HELLO\", \"Hello, R\", \"hello\"))## [1] \"HELLO\"    \"HELLO, R\" \"HELLO\""},{"path":"chap-string-operations.html","id":"base-concatenate","chapter":"第 4 章 字符串操作","heading":"4.3 字符串连接","text":"paste 函数设置参数 sep 作为连接符，设置参数 collapse 可以将字符串拼接后连成一个字符串paste0 相当于 sep 设为空，没有连接符","code":"\npaste(\"A\", \"B\", sep = \"\")## [1] \"AB\"\npaste(c(\"A\", \"B\", \"C\"), 1:3, sep = \"-\")## [1] \"A-1\" \"B-2\" \"C-3\"\npaste(c(\"A\", \"B\", \"C\"), 1:3, sep = \"-\", collapse = \";\")## [1] \"A-1;B-2;C-3\"\npaste0(\"A\", \"B\")## [1] \"AB\"\npaste0(c(\"A\", \"B\", \"C\"), 1:3)## [1] \"A1\" \"B2\" \"C3\"\npaste0(c(\"A\", \"B\", \"C\"), 1:3, collapse = \";\")## [1] \"A1;B2;C3\""},{"path":"chap-string-operations.html","id":"base-strsplit","chapter":"第 4 章 字符串操作","heading":"4.4 字符串拆分","text":"strsplit 函数用于字符串拆分，参数 x 是被拆分的字符串向量，其每个元素都会被拆分，而参数 split 表示拆分的位置，可以用正则表达式来描述位置，拆分的结果是一个列表。参数 fixed 默认设置 fixed = FALSE 表示正则表达式匹配，而 fixed = TRUE 表示正则表达式的精确匹配或者按文本字符的字面意思匹配，即按普通文本匹配。我们知道按普通文本匹配速度快。当启用 perl = TRUE 时，由 PCRE_use_JIT 控制细节。perl 参数的设置与 Perl 软件版本有关，如果正则表达式很长，除了正确设置正则表达式，使用 perl = TRUE 可以提高运算速度参数 useBytes 设置是否按照逐个字节地进行匹配，默认设置为 FALSE，即按照字符而不是字节进行匹配参数 split 支持通过正则表达式的方式指明拆分位置这里介绍一个将字符串逆序的函数 str_rev为了加深理解，再举几个例子","code":"\nstrsplit(x, split, fixed = FALSE, perl = FALSE, useBytes = FALSE)\nx <- c(as = \"asfef\", qu = \"qwerty\", \"yuiop[\", \"b\", \"stuff.blah.yech\")\n# 按字母 e 拆分字符串向量 x\nstrsplit(x, \"e\")## $as\n## [1] \"asf\" \"f\"  \n## \n## $qu\n## [1] \"qw\"  \"rty\"\n## \n## [[3]]\n## [1] \"yuiop[\"\n## \n## [[4]]\n## [1] \"b\"\n## \n## [[5]]\n## [1] \"stuff.blah.y\" \"ch\"\n# 默认将点号 . 看作一个正则表达式，它是一个元字符，匹配任意字符\nstrsplit(\"a.b.c\", \".\")## [[1]]\n## [1] \"\" \"\" \"\" \"\" \"\"\n# 这才是按点号拆分\nstrsplit(\"a.b.c\", \".\", fixed = TRUE)## [[1]]\n## [1] \"a\" \"b\" \"c\"\n# 或者\nstrsplit(\"a.b.c\", \"[.]\")## [[1]]\n## [1] \"a\" \"b\" \"c\"\n# 或者转义点号，去掉元字符的特殊意义\nstrsplit(\"a.b.c\", \"\\\\.\")## [[1]]\n## [1] \"a\" \"b\" \"c\"\nstr_rev <- function(x)\n        sapply(lapply(strsplit(x, NULL), rev), paste, collapse = \"\")\nstr_rev(c(\"abc\", \"Statistics\"))## [1] \"cba\"        \"scitsitatS\"\n# 最后一个空字符没有产生\nstrsplit(paste(c(\"\", \"a\", \"\"), collapse=\"#\"), split=\"#\")## [[1]]\n## [1] \"\"  \"a\"\n# 空字符只有有定义的时候才会产生\nstrsplit(\"\", \" \")## [[1]]\n## character(0)\nstrsplit(\" \", \" \")## [[1]]\n## [1] \"\""},{"path":"chap-string-operations.html","id":"base-match","chapter":"第 4 章 字符串操作","heading":"4.5 字符串匹配","text":"agrep 和 agrepl 函数做近似（模糊）匹配 (Approximate Matching Fuzzy Matching) ，对于匹配，考虑到参数 pattern 在参数 x 中匹配时，允许参数值x存在最小可能的插入、删除和替换，这种修改叫做Levenshtein 编辑距离，max.distance 控制其细节agrep 函数返回 pattern 在 x 中匹配到的一个位置向量，agrepl 返回一个逻辑向量，这一点类似 grep 和 grepl 这对函数，下面举例子说明startsWith 和 endsWith 函数用来匹配字符串的前缀和后缀，返回值是一个逻辑向量，参数 prefix 和 suffix 不要包含特殊的正则表达式字符，如点号.，举例子当前目录下，列出扩展名为 .Rmd 的文件部分匹配(Partial String Matching)这几个 match 函数的返回值都是一个向量，每个元素是参数x在参数table中第一次匹配到的位置，charmatch 与 pmatch(x, table, nomatch = NA_integer_, duplicates.ok = TRUE) 类似，所以 pmatch 在默认 duplicates.ok = FALSE 的情况下，若x在第二个参数table中有多次匹配就会返回 NA，因此，实际上 pmatch 只允许在第二个参数中匹配一次","code":"\nagrep(pattern, x, max.distance = 0.1, costs = NULL,\n      ignore.case = FALSE, value = FALSE, fixed = TRUE,\n      useBytes = FALSE)\n\nagrepl(pattern, x, max.distance = 0.1, costs = NULL,\n       ignore.case = FALSE, fixed = TRUE, useBytes = FALSE)\nagrep(\"lasy\", \"1 lazy 2\")## [1] 1\n# sub = 0 表示匹配时不考虑替换\nagrep(\"lasy\", c(\" 1 lazy 2\", \"1 lasy 2\"), max = list(sub = 0))## [1] 2\n# 默认设置下，匹配时区分大小写\nagrep(\"laysy\", c(\"1 lazy\", \"1\", \"1 LAZY\"), max = 2)## [1] 1\n# 返回匹配到值，而不是位置下标，类似 grep(..., value = TRUE) 的返回值\nagrep(\"laysy\", c(\"1 lazy\", \"1\", \"1 LAZY\"), max = 2, value = TRUE)## [1] \"1 lazy\"\n# 不区分大小写\nagrep(\"laysy\", c(\"1 lazy\", \"1\", \"1 LAZY\"), max = 2, ignore.case = TRUE)## [1] 1 3\nstartsWith(x, prefix)\n  endsWith(x, suffix)\n# 字符串向量\nsearch()## [1] \".GlobalEnv\"        \"package:stats\"     \"package:graphics\" \n## [4] \"package:grDevices\" \"package:utils\"     \"package:datasets\" \n## [7] \"package:methods\"   \"Autoloads\"         \"package:base\"\n# 匹配以 package: 开头的字符串\nstartsWith(search(), \"package:\")## [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n# 或者\ngrepl(\"^package:\", search())## [1] FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE  TRUE\n# list.files(path = \".\", pattern = \"\\\\.Rmd$\")\n# 而不是 endsWith(list.files(), \"\\\\.Rmd\")\nendsWith(list.files(), \".Rmd\")##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n## [13] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE\n## [25] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n## [37] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE\n## [49]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n## [61]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n## [73] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\n# 或者\ngrepl(\"\\\\.Rmd$\", list.files())##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE FALSE\n## [13] FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE  TRUE FALSE\n## [25] FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE\n## [37] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE FALSE FALSE\n## [49]  TRUE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE\n## [61]  TRUE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE  TRUE  TRUE FALSE FALSE\n## [73] FALSE FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE FALSE  TRUE FALSE\nmatch(x, table, nomatch = NA_integer_, incomparables = NULL)\nx %in% table\ncharmatch(x, table, nomatch = NA_integer_)\npmatch(x, table, nomatch = NA_integer_, duplicates.ok = FALSE)\nmatch(\"xx\", c(\"abc\", \"xx\", \"xxx\", \"xx\"))## [1] 2\n1:10 %in% c(1,3,5,9)##  [1]  TRUE FALSE  TRUE FALSE  TRUE FALSE FALSE FALSE  TRUE FALSE\n# charmatch 就比较奇怪，规则太多\ncharmatch(\"\", \"\")                             # returns 1## [1] 1\n# 多个精确匹配到，或者多个部分匹配到，则返回 0\ncharmatch(\"m\",   c(\"mean\", \"median\", \"mode\", \"quantile\")) # returns 0## [1] 0\n# med 只在table参数值的第二个位置部分匹配到，所以返回2\ncharmatch(\"med\", c(\"mean\", \"median\", \"mode\", \"quantile\")) # returns 2## [1] 2\ncharmatch(\"xx\", \"xx\")## [1] 1\ncharmatch(\"xx\", \"xxa\")## [1] 1\ncharmatch(\"xx\", \"axx\")## [1] NA\n# 注意比较与 charmatch 的不同\npmatch(\"\", \"\")                             # returns NA## [1] NA\npmatch(\"m\",   c(\"mean\", \"median\", \"mode\")) # returns NA## [1] NA\npmatch(\"med\", c(\"mean\", \"median\", \"mode\")) # returns 2## [1] 2"},{"path":"chap-string-operations.html","id":"base-search","chapter":"第 4 章 字符串操作","heading":"4.6 字符串查询","text":"grep 和 grepl 是一对字符串查询函数，查看字符串向量 x 中是否包含正则表达式 pattern 描述的内容ignore.case: TRUE 表示忽略大小写，FALSE 表示匹配的时候区分大小写fixed = TRUE 表示启用 literal regular expression 字面正则表达式，默认情况下fixed = FALSEgrep 函数返回匹配到的字符串向量x的元素的下标，如果 value=TRUE 则返回下标对应的值grepl 函数返回一个逻辑向量，检查字符串向量x中的每个元素是否匹配到，匹配到返回 TRUE，没有匹配到返回 FALSE继续举例子关于 grepl 函数的使用例子R 语言是用字符串来表示正则表达式的，但是正则表达式不是字符串，字符串的构造类似算术表达式在 R 里面分别表示 \\\\b 和 \\b下面在 R 里面分别匹配字符串 \\\\b 和 \\b 中的 \\\\ 和 \\当启用 perl=TRUE 时， 函数 regexpr 和 gregexpr 支持 Python 环境下的命名捕获(named captures)，但是不支持长向量的输入。如果一个分组被命名了，如 (?<first>[-Z][-z]+) 那么匹配到的位置按命名返回。函数 sub 不支持命名反向引用 (Named backreferences)函数 regmatches 用来提取函数regexpr, gregexpr 和 regexec 匹配到的子字符串useBytes = FALSE 匹配位置和长度默认是按照字符级别来的，如果 useBytes = TRUE 则是按照逐个字节的匹配结果如果使用到了 命名捕获 则会返回更多的属性 “capture.start”，“capture.length” 和 “capture.names”，分别表示捕获的起始位置、捕获的长度和捕获的命名。regexpr 函数返回一个整型向量，第一次匹配的初始位置，-1 表示没有匹配到，返回的属性 match.length 表示匹配的字符数量，是一个整型向量，向量长度是匹配的文本的长度，-1 表示没有匹配到gregexpr 函数返回一个列表，返回列表的长度与字符串向量的长度一样，列表中每个元素的形式与 regexpr 的返回值一样, except starting positions every (disjoint) match given.regexec 函数返回一个列表，类似函数gregexpr的返回结果，长度与字符串向量的长度一样，如果没有匹配到就返回 -1，匹配到了就返回一个匹配的初值位置的整型序列，所有子字符串与括号分组的正则表达式的子表达式对应，属性 “match.length” 是一个表示匹配的长度的向量，如果是 -1 表示没有匹配到。位置、长度和属性的解释与 regexpr 一致由于资源限制（特别是 PCRE）导致的匹配失败，会视为没有匹配，通常伴随一个警告下面这个将链接分解的例子由 Luke Tierney 提供15这里 x 是一个字符串，所以函数 regexec 返回的列表长度为1，正则表达式 ^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*) 括号分组匹配到了7次，第一次匹配整个字符串，所以起始位置是1，而匹配长度是26，即整个字符串的长度，读者可以调用函数 nchar(x) 算一下，如果你愿意手动数一下也可以哈！余下不一一介绍，可以根据返回结果和图4.1一起看，最后还可以调用regmatches函数抽取匹配到的结果我们可以在 https://regex101.com/ 上测试表达式，如图4.1所示，表达式 ^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*) 包含7个组，每个组的匹配结果见图的右下角，这样我们不难理解，函数 regmatches 返回的第列表中，第3个位置是传输协议 protocol http ，第4个位置是主机 host stat.umn.edu， 第6个位置是端口 port 80 ，第7个位置是路径 path /xyz，所以函数 regmatches 的作用就是根据函数 regexec 匹配的结果抽取子字符串。\n图 4.1: 正则表达式匹配结果\n进一步，我们可以用 regmatches 函数抽取 URL 的部分内容，如前面提到的传输协议，主机等目前还没有 gregexec 函数，但是可以模拟一个，首先用 gregexpr 函数返回匹配的位置，regmatches 抽取相应的值，然后用 regexec 作用到每一个提取的值，做再一次匹配和值的抽取，实现了全部的匹配。另一个例子","code":"\ngrep(pattern, x,\n  ignore.case = FALSE, perl = FALSE, value = FALSE,\n  fixed = FALSE, useBytes = FALSE, invert = FALSE\n)\ngrepl(pattern, x,\n  ignore.case = FALSE, perl = FALSE,\n  fixed = FALSE, useBytes = FALSE\n)\n# 返回下标位置\ngrep(\"[a-z]\", letters)##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25\n## [26] 26\n# 返回查询到的值\ngrep(\"[a-z]\", letters, value = TRUE)##  [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n## [20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\ngrep(x = c(\"apple\", \"banana\"), pattern = \"a\")## [1] 1 2\ngrep(x = c(\"apple\", \"banana\"), pattern = \"b\")## [1] 2\ngrep(x = c(\"apple\", \"banana\"), pattern = \"a\", value = TRUE)## [1] \"apple\"  \"banana\"\ngrep(x = c(\"apple\", \"banana\"), pattern = \"b\", value = TRUE)## [1] \"banana\"\ngrepl(x = c(\"apple\", \"banana\"), pattern = \"a\")## [1] TRUE TRUE\ngrepl(x = c(\"apple\", \"banana\"), pattern = \"b\")## [1] FALSE  TRUE\nwriteLines(c(\"a\\\\\\\\b\", \"a\\\\b\"))## a\\\\b\n## a\\b\n# 匹配字符串中的一个反斜杠\ngrep(x = c(\"a\\\\\\\\b\", \"a\\\\b\"), pattern = \"\\\\\", value = TRUE, fixed = TRUE)## [1] \"a\\\\\\\\b\" \"a\\\\b\"\ngrep(x = c(\"a\\\\\\\\b\", \"a\\\\b\"), pattern = \"\\\\\\\\\", value = TRUE, fixed = FALSE)## [1] \"a\\\\\\\\b\" \"a\\\\b\"\n# 匹配字符串中的两个反斜杠\ngrep(x = c(\"a\\\\\\\\b\", \"a\\\\b\"), pattern = \"\\\\\\\\\", value = TRUE, fixed = TRUE)## [1] \"a\\\\\\\\b\"\ngrep(x = c(\"a\\\\\\\\b\", \"a\\\\b\"), pattern = \"\\\\\\\\\\\\\\\\\", value = TRUE, fixed = FALSE)## [1] \"a\\\\\\\\b\"\n# 匹配字符串中的两个反斜杠 \\\\\ngrepl(x = \"a\\\\\\\\b\", pattern = \"\\\\\\\\\\\\\\\\\", fixed = FALSE)## [1] TRUE\ngrepl(x = \"a\\\\\\\\b\", pattern = \"\\\\\\\\\\\\\\\\\", fixed = TRUE)## [1] FALSE\ngrepl(x = \"a\\\\\\\\b\", pattern = \"\\\\\\\\\", fixed = TRUE)## [1] TRUE\nregexpr(pattern, text,\n  ignore.case = FALSE, perl = FALSE,\n  fixed = FALSE, useBytes = FALSE\n)\ngregexpr(pattern, text,\n  ignore.case = FALSE, perl = FALSE,\n  fixed = FALSE, useBytes = FALSE\n)\nregexec(pattern, text,\n  ignore.case = FALSE, perl = FALSE,\n  fixed = FALSE, useBytes = FALSE\n)       \ntext <- c(\"Hellow, Adam!\", \"Hi, Adam!\", \"How are you, Adam.\")\nregexpr(\"Adam\", text)## [1]  9  5 14\n## attr(,\"match.length\")\n## [1] 4 4 4\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\ntxt <- c(\n  \"The\", \"licenses\", \"for\", \"most\", \"software\", \"are\",\n  \"designed\", \"to\", \"take\", \"away\", \"your\", \"freedom\",\n  \"to\", \"share\", \"and\", \"change\", \"it.\",\n  \"\", \"By\", \"contrast,\", \"the\", \"GNU\", \"General\", \"Public\", \"License\",\n  \"is\", \"intended\", \"to\", \"guarantee\", \"your\", \"freedom\", \"to\",\n  \"share\", \"and\", \"change\", \"free\", \"software\", \"--\",\n  \"to\", \"make\", \"sure\", \"the\", \"software\", \"is\",\n  \"free\", \"for\", \"all\", \"its\", \"users\"\n)\n# gregexpr(\"en\", txt)\nregexpr(\"en\", txt)##  [1] -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  2 -1  4\n## [26] -1  4 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n## attr(,\"match.length\")\n##  [1] -1  2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1  2 -1  2\n## [26] -1  2 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1 -1\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\ngregexpr(\"Adam\", text)## [[1]]\n## [1] 9\n## attr(,\"match.length\")\n## [1] 4\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\n## \n## [[2]]\n## [1] 5\n## attr(,\"match.length\")\n## [1] 4\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\n## \n## [[3]]\n## [1] 14\n## attr(,\"match.length\")\n## [1] 4\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\nregexec(\"Adam\", text)## [[1]]\n## [1] 9\n## attr(,\"match.length\")\n## [1] 4\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\n## \n## [[2]]\n## [1] 5\n## attr(,\"match.length\")\n## [1] 4\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\n## \n## [[3]]\n## [1] 14\n## attr(,\"match.length\")\n## [1] 4\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\nx <- \"http://stat.umn.edu:80/xyz\"\nm <- regexec(\"^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)\", x)\nm## [[1]]\n## [1]  1  1  1  8 20 21 23\n## attr(,\"match.length\")\n## [1] 26  7  4 12  3  2  4\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\nregmatches(x, m)## [[1]]\n## [1] \"http://stat.umn.edu:80/xyz\" \"http://\"                   \n## [3] \"http\"                       \"stat.umn.edu\"              \n## [5] \":80\"                        \"80\"                        \n## [7] \"/xyz\"\nURL_parts <- function(x) {\n  m <- regexec(\"^(([^:]+)://)?([^:/]+)(:([0-9]+))?(/.*)\", x)\n  parts <- do.call(\n    rbind,\n    lapply(regmatches(x, m), `[`, c(3L, 4L, 6L, 7L))\n    # 3,4,6,7是索引位置\n  )\n  colnames(parts) <- c(\"protocol\", \"host\", \"port\", \"path\")\n  parts\n}\nURL_parts(x)##      protocol host           port path  \n## [1,] \"http\"   \"stat.umn.edu\" \"80\" \"/xyz\"\n## There is no gregexec() yet, but one can emulate it by running\n## regexec() on the regmatches obtained via gregexpr().  E.g.:\npattern <- \"([[:alpha:]]+)([[:digit:]]+)\"\ns <- \"Test: A1 BC23 DEF456\"\ngregexpr(pattern, s)## [[1]]\n## [1]  7 10 15\n## attr(,\"match.length\")\n## [1] 2 4 6\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\nregmatches(s, gregexpr(pattern, s))## [[1]]\n## [1] \"A1\"     \"BC23\"   \"DEF456\"\nlapply(\n  regmatches(s, gregexpr(pattern, s)),\n  function(e) regmatches(e, regexec(pattern, e))\n)## [[1]]\n## [[1]][[1]]\n## [1] \"A1\" \"A\"  \"1\" \n## \n## [[1]][[2]]\n## [1] \"BC23\" \"BC\"   \"23\"  \n## \n## [[1]][[3]]\n## [1] \"DEF456\" \"DEF\"    \"456\""},{"path":"chap-string-operations.html","id":"base-replacement","chapter":"第 4 章 字符串操作","heading":"4.7 字符串替换","text":"chartr 支持正则表达式的替换，chartr 是对应字符的替换操作两个 *sub 函数的区别：sub 替换第一次匹配到的结果，gsub 替换所有匹配的结果参数 replacement 的值是正则表达式，其包含反向引用的用法， \\\\1 即引用表达式 ([ab])","code":"\nx <- \"MiXeD cAsE 123\"\n# 将字符 iXs 替换为 why\nchartr(\"iXs\", \"why\", x)## [1] \"MwheD cAyE 123\"\n# 将字符串 a-cX 中的字符挨个对应地替换为 D-Fw\nchartr(\"a-cX\", \"D-Fw\", x)## [1] \"MiweD FAsE 123\"\nsub(\" .*\", \"\", extSoftVersion()[\"PCRE\"])##    PCRE \n## \"10.39\"\ngsub(pattern =  \"([ab])\", replacement = \"\\\\1_\\\\1_\", x = \"abc and ABC\")## [1] \"a_a_b_b_c a_a_nd ABC\""},{"path":"chap-string-operations.html","id":"base-extract","chapter":"第 4 章 字符串操作","heading":"4.8 字符串提取","text":"substr 和 substring 函数通过位置进行字符串的拆分和提取，它们本身不使用正则表达式，结合其他正则表达式函数regexpr, gregexpr 和 regexec，可以很方便地从大量文本中提取所需的信息。作用类似之前提到的 regmatches 函数参数设置基本相同x/text 是要拆分的字符串向量start/first 截取的起始位置向量stop/last 截取的终止位置向量返回值有差别substr 返回的字串个数等于第一个参数 x 的长度substring 返回字串个数等于三个参数中最长向量长度，短向量循环使用。因为 x 的向量长度为1，所以 substr 获得的结果只有1个字串，即第2和第3个参数向量只用了第一个组合：起始位置2，终止位置4。而 substring 的语句三个参数中最长的向量为 c(4,5,8)，执行时按短向量循环使用的规则第一个参数事实上就是c(x,x,x)，第二个参数就成了c(2,4,2)，最终截取的字串起始位置组合为：2-4, 4-5和2-8。更加高级的字符串抽取举例子，抽取连续的数字例子来自于 https://recology.info/2018/10/limiting-dependencies/","code":"\nsubstr(x, start, stop)\nsubstring(text, first, last = 1000000L)\nx <- \"123456789\"\nsubstr(x, c(2, 4), c(4, 5, 8))## [1] \"234\"\nsubstring(x, c(2, 4), c(4, 5, 8))## [1] \"234\"     \"45\"      \"2345678\"\nsubstr(\"abcdef\", 2, 4)## [1] \"bcd\"\nsubstring(\"abcdef\", 1:6, 1:6)## [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\"\nx <- c(\"123456789\", \"abcdefghijklmnopq\")\nsubstr(x, c(2, 4), c(4, 5, 8))## [1] \"234\" \"de\"\nsubstring(x, c(2, 4), c(4, 5, 8))## [1] \"234\"     \"de\"      \"2345678\"\n# 从字符串中抽取固定模式的文本，替代 stringr::str_extract\n# 只抽取一个匹配的\nextract_str <- function(text, pattern) regmatches(text, regexpr(pattern, text))\n# 符合模式的全部抽取\ngextract_str <- function(text, pattern) regmatches(text, gregexpr(pattern, text))\n# 两个例子\nextract_str(text = \"abd123da345das\", pattern = \"(\\\\d+){3}\")## [1] \"123\"\ngextract_str(text = \"abd123da345das\", pattern = \"(\\\\d+){3}\")## [[1]]\n## [1] \"123\" \"345\""},{"path":"chap-string-operations.html","id":"string-named-capture","chapter":"第 4 章 字符串操作","heading":"4.9 命名捕捉","text":"函数 regexpr(..., perl = TRUE) 和 gregexpr(..., perl = TRUE) 支持命名捕捉希望返回一个 data.frame，列名是指定的 named group 名字","code":"\n## named capture\nnotables <- c(\"  Ben Franklin and Jefferson Davis\",\n              \"\\tMillard Fillmore\")\n# name groups 'first' and 'last'\nname.rex <- \"(?<first>[[:upper:]][[:lower:]]+) (?<last>[[:upper:]][[:lower:]]+)\"\n\n(parsed <- regexpr(name.rex, notables, perl = TRUE))## [1] 3 2\n## attr(,\"match.length\")\n## [1] 12 16\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\n## attr(,\"capture.start\")\n##      first last\n## [1,]     3    7\n## [2,]     2   10\n## attr(,\"capture.length\")\n##      first last\n## [1,]     3    8\n## [2,]     7    8\n## attr(,\"capture.names\")\n## [1] \"first\" \"last\"\nattr(parsed, 'capture.names')## [1] \"first\" \"last\"\nregmatches(notables, parsed)## [1] \"Ben Franklin\"     \"Millard Fillmore\"\n# 有多个结果\n(idx <- gregexpr(name.rex, notables, perl = TRUE))## [[1]]\n## [1]  3 20\n## attr(,\"match.length\")\n## [1] 12 15\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\n## attr(,\"capture.start\")\n##      first last\n## [1,]     3    7\n## [2,]    20   30\n## attr(,\"capture.length\")\n##      first last\n## [1,]     3    8\n## [2,]     9    5\n## attr(,\"capture.names\")\n## [1] \"first\" \"last\" \n## \n## [[2]]\n## [1] 2\n## attr(,\"match.length\")\n## [1] 16\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\n## attr(,\"capture.start\")\n##      first last\n## [1,]     2   10\n## attr(,\"capture.length\")\n##      first last\n## [1,]     7    8\n## attr(,\"capture.names\")\n## [1] \"first\" \"last\"\nregmatches(notables, idx)## [[1]]\n## [1] \"Ben Franklin\"    \"Jefferson Davis\"\n## \n## [[2]]\n## [1] \"Millard Fillmore\"\nattr(idx[[1]], 'capture.names')## [1] \"first\" \"last\"\nlibrary(magrittr)\ndata.frame(notable = notables) %>% \ntidyr::extract(\n    notable, c(\"first\", \"last\"), name.rex, \n    remove = FALSE\n  )##                              notable   first     last\n## 1   Ben Franklin and Jefferson Davis     Ben Franklin\n## 2                 \\tMillard Fillmore Millard Fillmore"},{"path":"chap-string-operations.html","id":"exact-match","chapter":"第 4 章 字符串操作","heading":"4.10 精确匹配","text":"fixed = TRUE","code":""},{"path":"chap-string-operations.html","id":"fuzzy-match","chapter":"第 4 章 字符串操作","heading":"4.11 模糊匹配","text":"近似字符串匹配 (Approximate String Matching) 也叫模糊匹配 (Fuzzy Matching)agrep() agrepl() aregexec() adist()案例help.search()","code":"\nagrep(pattern = \"lasy\", x = \"1 lazy 2\")## [1] 1\nagrep(\"lasy\", c(\" 1 lazy 2\", \"1 lasy 2\"), max = list(sub = 0))## [1] 2\nagrep(\"laysy\", c(\"1 lazy\", \"1\", \"1 LAZY\"), max = 2)## [1] 1\nagrep(\"laysy\", c(\"1 lazy\", \"1\", \"1 LAZY\"), max = 2, value = TRUE)## [1] \"1 lazy\"\nagrep(\"laysy\", c(\"1 lazy\", \"1\", \"1 LAZY\"), max = 2, ignore.case = TRUE)## [1] 1 3\nagrepl(pattern = \"lasy\", x = \"1 lazy 2\")## [1] TRUE\n## Cf. the examples for agrep.\nx <- c(\"1 lazy\", \"1\", \"1 LAZY\")\n\naregexec(\"laysy\", x, max.distance = 2)## [[1]]\n## [1] 3\n## attr(,\"match.length\")\n## [1] 4\n## \n## [[2]]\n## [1] -1\n## attr(,\"match.length\")\n## [1] -1\n## \n## [[3]]\n## [1] -1\n## attr(,\"match.length\")\n## [1] -1\naregexec(\"(lay)(sy)\", x, max.distance = 2)## [[1]]\n## [1] 3 3 5\n## attr(,\"match.length\")\n## [1] 4 2 2\n## \n## [[2]]\n## [1] -1\n## attr(,\"match.length\")\n## [1] -1\n## \n## [[3]]\n## [1] -1\n## attr(,\"match.length\")\n## [1] -1\naregexec(\"(lay)(sy)\", x, max.distance = 2, ignore.case = TRUE)## [[1]]\n## [1] 3 3 6\n## attr(,\"match.length\")\n## [1] 4 3 1\n## \n## [[2]]\n## [1] -1\n## attr(,\"match.length\")\n## [1] -1\n## \n## [[3]]\n## [1] 3 3 6\n## attr(,\"match.length\")\n## [1] 4 3 1\nm <- aregexec(\"(lay)(sy)\", x, max.distance = 2)\nregmatches(x, m)## [[1]]\n## [1] \"lazy\" \"la\"   \"zy\"  \n## \n## [[2]]\n## character(0)\n## \n## [[3]]\n## character(0)\n## Cf. https://en.wikipedia.org/wiki/Levenshtein_distance\nadist(\"kitten\", \"sitting\")##      [,1]\n## [1,]    3\n## To see the transformation counts for the Levenshtein distance:\ndrop(attr(adist(\"kitten\", \"sitting\", counts = TRUE), \"counts\"))## ins del sub \n##   1   0   2\n## To see the transformation sequences:\nattr(adist(c(\"kitten\", \"sitting\"), counts = TRUE), \"trafos\")##      [,1]      [,2]     \n## [1,] \"MMMMMM\"  \"SMMMSMI\"\n## [2,] \"SMMMSMD\" \"MMMMMMM\"\n## Cf. the examples for agrep:\nadist(\"lasy\", \"1 lazy 2\")##      [,1]\n## [1,]    5\n## For a \"partial approximate match\" (as used for agrep):\nadist(\"lasy\", \"1 lazy 2\", partial = TRUE)##      [,1]\n## [1,]    1"},{"path":"chap-string-operations.html","id":"replace","chapter":"第 4 章 字符串操作","heading":"4.12 高级的替换","text":"相比于 sprintf() 格式化输出字符串的方式替换，它的优势在于提示性，或者说代码的可读性","code":"\nglue_data <- function(param, text) {\n  idx <- gregexpr('\\\\{[^}]*\\\\}', text)[[1L]]\n  keys <- substring(text, idx, idx + attr(idx, 'match.length') - 1L)\n  for (key in keys) {\n    text <- gsub(key, param[[gsub('[{}]', '', key)]], text, fixed = TRUE)\n  }\n  text\n}\ncat(glue_data(\n  param = list(table = 'flights', origin = 'JFK'),\n  text = \"\n  select count(*) as n\n  from {table}\n  where origin = '{origin}'\n  \"\n))## \n##   select count(*) as n\n##   from flights\n##   where origin = 'JFK'\n## "},{"path":"chap-string-operations.html","id":"extract","chapter":"第 4 章 字符串操作","heading":"4.13 高级的提取","text":"从 text 中抽取给定模式 pattern 的字符串举个栗子，比如提取数字提取所有符合匹配模式的字符串举个栗子，提取其中的英文字母","code":"\nstr_extract <- function(text, pattern, ...) regmatches(text, regexpr(pattern, text, ...))\nshopping_list <- c(\"apples x4\", \"bag of flour\", \"bag of sugar\", \"milk x2\")\nstringr::str_extract(shopping_list, \"\\\\d\")## [1] \"4\" NA  NA  \"2\"\n# 注意二者的差别\nstr_extract(shopping_list, \"\\\\d\")## [1] \"4\" \"2\"\nstr_extract_all <- function(text, pattern, ...) regmatches(text, gregexpr(pattern, text, ...))\nstr_extract_all(shopping_list, \"[a-z]+\")## [[1]]\n## [1] \"apples\" \"x\"     \n## \n## [[2]]\n## [1] \"bag\"   \"of\"    \"flour\"\n## \n## [[3]]\n## [1] \"bag\"   \"of\"    \"sugar\"\n## \n## [[4]]\n## [1] \"milk\" \"x\"\nstringr::str_extract_all(shopping_list, \"[a-z]+\")## [[1]]\n## [1] \"apples\" \"x\"     \n## \n## [[2]]\n## [1] \"bag\"   \"of\"    \"flour\"\n## \n## [[3]]\n## [1] \"bag\"   \"of\"    \"sugar\"\n## \n## [[4]]\n## [1] \"milk\" \"x\""},{"path":"chap-string-operations.html","id":"other-string-op","chapter":"第 4 章 字符串操作","heading":"4.14 其它操作","text":"","code":""},{"path":"chap-string-operations.html","id":"strwrap","chapter":"第 4 章 字符串操作","heading":"4.14.1 strwrap","text":"该函数把一个字符串当成一个段落的文字（不管字符串中是否有换行符），按照段落的格式（缩进和长度）和断字方式进行分行，每一行是结果中的一个字符串。再举一个烧脑的例子","code":"\nstrwrap(x, width = 0.9 * getOption(\"width\"), indent = 0,\n        exdent = 0, prefix = \"\", simplify = TRUE, initial = prefix)\n# 读取一段文本\nx <- paste(readLines(file.path(R.home(\"doc\"), \"THANKS\")), collapse = \"\\n\")\n## 将文本拆分为段落，且移除前三段\nx <- unlist(strsplit(x, \"\\n[ \\t\\n]*\\n\"))[-(1:3)]\n# 每一段换两行\nx <- paste(x, collapse = \"\\n\\n\")\n# 每一行的宽度设定为60个字符\nwriteLines(strwrap(x, width = 60))## J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr,\n## Michael A. Covington, Bill Cleveland, Robert Cleveland,, G.\n## W. Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O.\n## Evans, David M. Gay, H. Frick, G. W. Hill, Richard H.\n## Jones, Eric Grosse, Shelby Haberman, Bruno Haible, John\n## Hartigan, Andrew Harvey, Trevor Hastie, Min Long Lam,\n## George Marsaglia, K. J. Martin, Gordon Matzigkeit, C. R.\n## Mckenzie, Jean McRae, Cyrus Mehta, Fionn Murtagh, John C.\n## Nash, Finbarr O'Sullivan, R. E. Odeh, William Patefield,\n## Nitin Patel, Alan Richardson, D. E. Roberts, Patrick\n## Royston, Russell Lenth, Ming-Jen Shyu, Richard C.\n## Singleton, S. G. Springer, Supoj Sutanthavibul, Irma\n## Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang,\n## Berwin Turlach, Gary V. Vaughan, Michael Wichura, Jingbo\n## Wang, M. A. Wong, and the Free Software Foundation (for\n## autoconf code and utilities). See also files under\n## src/extras.\n## \n## Many more, too numerous to mention here, have contributed\n## by sending bug reports and suggesting various improvements.\n## \n## Simon Davies whilst at the University of Auckland wrote the\n## original version of glm().\n## \n## Julian Harris and Wing Kwong (Tiki) Wan whilst at the\n## University of Auckland assisted Ross Ihaka with the\n## original Macintosh port.\n## \n## R was inspired by the S environment which has been\n## principally developed by John Chambers, with substantial\n## input from Douglas Bates, Rick Becker, Bill Cleveland,\n## Trevor Hastie, Daryl Pregibon and Allan Wilks.\n## \n## A special debt is owed to John Chambers who has graciously\n## contributed advice and encouragement in the early days of R\n## and later became a member of the core team.\n## \n## Stefano Iacus (up to 2014, a former member of R Core) and\n## Simon Urbanek developed the macOS port, including the R.app\n## GUI, toolchains and packaging.\n## \n## The Windows port was originally developed by Guido\n## Masarotto (for a while a member of R Core) and Brian\n## Ripley, then further by Duncan Murdoch (a former member of\n## R Core) and then Jeroen Ooms (base) and Uwe Ligges\n## (packages).  Tomas Kalibera is the current main developer\n## of the Windows port and provides assistance with package\n## porting.\n## \n## Tomas Kalibera's work has been sponsored by Jan Vitek and\n## funded by his European Research Council grant \"Evolving\n## Language Ecosystems (ELE)\".\n## \n## Computing support (including hardware, hosting and\n## infrastructure) has been provided/funded by the R\n## Foundation, employers of R-Core members (notably WU Wien,\n## ETH Zurich, U Oxford and U Iowa) and by Northeastern\n## University and the University of Kent.\n## \n## Distributions of R contain the recommended packages, whose\n## authors/contributors are listed in their DESCRIPTION files.\n# 每一段的段首缩进5个字符\nwriteLines(strwrap(x, width = 60, indent = 5))##      J. D. Beasley, David J. Best, Richard Brent, Kevin\n## Buhr, Michael A. Covington, Bill Cleveland, Robert\n## Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper, Paul\n## Eggert, J. O. Evans, David M. Gay, H. Frick, G. W. Hill,\n## Richard H. Jones, Eric Grosse, Shelby Haberman, Bruno\n## Haible, John Hartigan, Andrew Harvey, Trevor Hastie, Min\n## Long Lam, George Marsaglia, K. J. Martin, Gordon\n## Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus Mehta, Fionn\n## Murtagh, John C. Nash, Finbarr O'Sullivan, R. E. Odeh,\n## William Patefield, Nitin Patel, Alan Richardson, D. E.\n## Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu,\n## Richard C. Singleton, S. G. Springer, Supoj Sutanthavibul,\n## Irma Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan\n## Tsang, Berwin Turlach, Gary V. Vaughan, Michael Wichura,\n## Jingbo Wang, M. A. Wong, and the Free Software Foundation\n## (for autoconf code and utilities). See also files under\n## src/extras.\n## \n##      Many more, too numerous to mention here, have\n## contributed by sending bug reports and suggesting various\n## improvements.\n## \n##      Simon Davies whilst at the University of Auckland\n## wrote the original version of glm().\n## \n##      Julian Harris and Wing Kwong (Tiki) Wan whilst at the\n## University of Auckland assisted Ross Ihaka with the\n## original Macintosh port.\n## \n##      R was inspired by the S environment which has been\n## principally developed by John Chambers, with substantial\n## input from Douglas Bates, Rick Becker, Bill Cleveland,\n## Trevor Hastie, Daryl Pregibon and Allan Wilks.\n## \n##      A special debt is owed to John Chambers who has\n## graciously contributed advice and encouragement in the\n## early days of R and later became a member of the core team.\n## \n##      Stefano Iacus (up to 2014, a former member of R Core)\n## and Simon Urbanek developed the macOS port, including the\n## R.app GUI, toolchains and packaging.\n## \n##      The Windows port was originally developed by Guido\n## Masarotto (for a while a member of R Core) and Brian\n## Ripley, then further by Duncan Murdoch (a former member of\n## R Core) and then Jeroen Ooms (base) and Uwe Ligges\n## (packages).  Tomas Kalibera is the current main developer\n## of the Windows port and provides assistance with package\n## porting.\n## \n##      Tomas Kalibera's work has been sponsored by Jan Vitek\n## and funded by his European Research Council grant \"Evolving\n## Language Ecosystems (ELE)\".\n## \n##      Computing support (including hardware, hosting and\n## infrastructure) has been provided/funded by the R\n## Foundation, employers of R-Core members (notably WU Wien,\n## ETH Zurich, U Oxford and U Iowa) and by Northeastern\n## University and the University of Kent.\n## \n##      Distributions of R contain the recommended packages,\n## whose authors/contributors are listed in their DESCRIPTION\n## files.\n# 除了段首，每一段的余下诸行都缩进5个字符\nwriteLines(strwrap(x, width = 60, exdent = 5))## J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr,\n##      Michael A. Covington, Bill Cleveland, Robert\n##      Cleveland,, G. W. Cran, C. G. Ding, Ulrich Drepper,\n##      Paul Eggert, J. O. Evans, David M. Gay, H. Frick, G.\n##      W. Hill, Richard H. Jones, Eric Grosse, Shelby\n##      Haberman, Bruno Haible, John Hartigan, Andrew Harvey,\n##      Trevor Hastie, Min Long Lam, George Marsaglia, K. J.\n##      Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae,\n##      Cyrus Mehta, Fionn Murtagh, John C. Nash, Finbarr\n##      O'Sullivan, R. E. Odeh, William Patefield, Nitin\n##      Patel, Alan Richardson, D. E. Roberts, Patrick\n##      Royston, Russell Lenth, Ming-Jen Shyu, Richard C.\n##      Singleton, S. G. Springer, Supoj Sutanthavibul, Irma\n##      Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan\n##      Tsang, Berwin Turlach, Gary V. Vaughan, Michael\n##      Wichura, Jingbo Wang, M. A. Wong, and the Free\n##      Software Foundation (for autoconf code and utilities).\n##      See also files under src/extras.\n## \n## Many more, too numerous to mention here, have contributed\n##      by sending bug reports and suggesting various\n##      improvements.\n## \n## Simon Davies whilst at the University of Auckland wrote the\n##      original version of glm().\n## \n## Julian Harris and Wing Kwong (Tiki) Wan whilst at the\n##      University of Auckland assisted Ross Ihaka with the\n##      original Macintosh port.\n## \n## R was inspired by the S environment which has been\n##      principally developed by John Chambers, with\n##      substantial input from Douglas Bates, Rick Becker,\n##      Bill Cleveland, Trevor Hastie, Daryl Pregibon and\n##      Allan Wilks.\n## \n## A special debt is owed to John Chambers who has graciously\n##      contributed advice and encouragement in the early days\n##      of R and later became a member of the core team.\n## \n## Stefano Iacus (up to 2014, a former member of R Core) and\n##      Simon Urbanek developed the macOS port, including the\n##      R.app GUI, toolchains and packaging.\n## \n## The Windows port was originally developed by Guido\n##      Masarotto (for a while a member of R Core) and Brian\n##      Ripley, then further by Duncan Murdoch (a former\n##      member of R Core) and then Jeroen Ooms (base) and Uwe\n##      Ligges (packages).  Tomas Kalibera is the current main\n##      developer of the Windows port and provides assistance\n##      with package porting.\n## \n## Tomas Kalibera's work has been sponsored by Jan Vitek and\n##      funded by his European Research Council grant\n##      \"Evolving Language Ecosystems (ELE)\".\n## \n## Computing support (including hardware, hosting and\n##      infrastructure) has been provided/funded by the R\n##      Foundation, employers of R-Core members (notably WU\n##      Wien, ETH Zurich, U Oxford and U Iowa) and by\n##      Northeastern University and the University of Kent.\n## \n## Distributions of R contain the recommended packages, whose\n##      authors/contributors are listed in their DESCRIPTION\n##      files.\n# 在输出的每一行前面添加前缀\nwriteLines(strwrap(x, prefix = \"THANKS> \"))## THANKS> J. D. Beasley, David J. Best, Richard Brent, Kevin Buhr,\n## THANKS> Michael A. Covington, Bill Cleveland, Robert Cleveland,, G. W.\n## THANKS> Cran, C. G. Ding, Ulrich Drepper, Paul Eggert, J. O. Evans,\n## THANKS> David M. Gay, H. Frick, G. W. Hill, Richard H. Jones, Eric\n## THANKS> Grosse, Shelby Haberman, Bruno Haible, John Hartigan, Andrew\n## THANKS> Harvey, Trevor Hastie, Min Long Lam, George Marsaglia, K. J.\n## THANKS> Martin, Gordon Matzigkeit, C. R. Mckenzie, Jean McRae, Cyrus\n## THANKS> Mehta, Fionn Murtagh, John C. Nash, Finbarr O'Sullivan, R. E.\n## THANKS> Odeh, William Patefield, Nitin Patel, Alan Richardson, D. E.\n## THANKS> Roberts, Patrick Royston, Russell Lenth, Ming-Jen Shyu, Richard\n## THANKS> C. Singleton, S. G. Springer, Supoj Sutanthavibul, Irma\n## THANKS> Terpenning, G. E. Thomas, Rob Tibshirani, Wai Wan Tsang, Berwin\n## THANKS> Turlach, Gary V. Vaughan, Michael Wichura, Jingbo Wang, M. A.\n## THANKS> Wong, and the Free Software Foundation (for autoconf code and\n## THANKS> utilities). See also files under src/extras.\n## THANKS> \n## THANKS> Many more, too numerous to mention here, have contributed by\n## THANKS> sending bug reports and suggesting various improvements.\n## THANKS> \n## THANKS> Simon Davies whilst at the University of Auckland wrote the\n## THANKS> original version of glm().\n## THANKS> \n## THANKS> Julian Harris and Wing Kwong (Tiki) Wan whilst at the\n## THANKS> University of Auckland assisted Ross Ihaka with the original\n## THANKS> Macintosh port.\n## THANKS> \n## THANKS> R was inspired by the S environment which has been principally\n## THANKS> developed by John Chambers, with substantial input from Douglas\n## THANKS> Bates, Rick Becker, Bill Cleveland, Trevor Hastie, Daryl\n## THANKS> Pregibon and Allan Wilks.\n## THANKS> \n## THANKS> A special debt is owed to John Chambers who has graciously\n## THANKS> contributed advice and encouragement in the early days of R and\n## THANKS> later became a member of the core team.\n## THANKS> \n## THANKS> Stefano Iacus (up to 2014, a former member of R Core) and Simon\n## THANKS> Urbanek developed the macOS port, including the R.app GUI,\n## THANKS> toolchains and packaging.\n## THANKS> \n## THANKS> The Windows port was originally developed by Guido Masarotto\n## THANKS> (for a while a member of R Core) and Brian Ripley, then further\n## THANKS> by Duncan Murdoch (a former member of R Core) and then Jeroen\n## THANKS> Ooms (base) and Uwe Ligges (packages).  Tomas Kalibera is the\n## THANKS> current main developer of the Windows port and provides\n## THANKS> assistance with package porting.\n## THANKS> \n## THANKS> Tomas Kalibera's work has been sponsored by Jan Vitek and\n## THANKS> funded by his European Research Council grant \"Evolving\n## THANKS> Language Ecosystems (ELE)\".\n## THANKS> \n## THANKS> Computing support (including hardware, hosting and\n## THANKS> infrastructure) has been provided/funded by the R Foundation,\n## THANKS> employers of R-Core members (notably WU Wien, ETH Zurich, U\n## THANKS> Oxford and U Iowa) and by Northeastern University and the\n## THANKS> University of Kent.\n## THANKS> \n## THANKS> Distributions of R contain the recommended packages, whose\n## THANKS> authors/contributors are listed in their DESCRIPTION files.\nx <- paste(sapply(\n  sample(10, 100, replace = TRUE), # 从1-10个数字中有放回的随机抽取100个数\n  function(x) substring(\"aaaaaaaaaa\", 1, x)\n), collapse = \" \")\nsapply(\n  10:40,\n  function(m)\n    c(target = m, actual = max(nchar(strwrap(x, m))))\n)##        [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11] [,12] [,13]\n## target   10   11   12   13   14   15   16   17   18    19    20    21    22\n## actual   10   10   11   12   13   14   15   16   17    18    19    20    21\n##        [,14] [,15] [,16] [,17] [,18] [,19] [,20] [,21] [,22] [,23] [,24] [,25]\n## target    23    24    25    26    27    28    29    30    31    32    33    34\n## actual    22    23    24    25    26    27    28    29    30    31    32    33\n##        [,26] [,27] [,28] [,29] [,30] [,31]\n## target    35    36    37    38    39    40\n## actual    34    35    36    36    38    39"},{"path":"chap-string-operations.html","id":"strtrim","chapter":"第 4 章 字符串操作","heading":"4.14.2 strtrim","text":"strtrim 函数将字符串x修剪到特定的显示宽度，返回的字符串向量的长度等于字符串向量 x 的长度，如果 width 的参数值（它是一个整型向量）的长度小于 x 的，就循环补齐。","code":"\nstrtrim(x, width)\nstrtrim(c(\"abcdef\", \"abcdef\", \"abcdef\"), c(1, 5, 10))## [1] \"a\"      \"abcde\"  \"abcdef\""},{"path":"chap-string-operations.html","id":"strrep","chapter":"第 4 章 字符串操作","heading":"4.14.3 strrep","text":"以给定的次数重复字符串向量中每个元素的个数，并连接字符串的各个副本","code":"\nstrrep(x, times)\nstrrep(\"ABC\", 2)## [1] \"ABCABC\"\nstrrep(c(\"A\", \"B\", \"C\"), 1 : 3)## [1] \"A\"   \"BB\"  \"CCC\"\n# 创建一个字符串向量，指定每个元素中空格的数量\nstrrep(\" \", 1 : 5)## [1] \" \"     \"  \"    \"   \"   \"    \"  \"     \""},{"path":"chap-string-operations.html","id":"trimws","chapter":"第 4 章 字符串操作","heading":"4.14.4 trimws","text":"trimws 函数用于移除字符串中的空格，这种空格可以来自制表符、回车符和换行符，位置可以位于字符串的开头或者结尾，参数指定空格的大致位置。举例如下","code":"\ntrimws(x, which = c(\"both\", \"left\", \"right\"), whitespace = \"[ \\t\\r\\n]\")\nx <- \"  Some text. \"\nx## [1] \"  Some text. \"\ntrimws(x)## [1] \"Some text.\"\ntrimws(x, \"l\")## [1] \"Some text. \"\ntrimws(x, \"r\")## [1] \"  Some text.\"\nshopping_list <- c(\"apples x4\", \"bag of flour\", \"bag of sugar\", \"milk x2\")\n\nstringr::str_replace(string = shopping_list, pattern = \"\\\\d\", replacement = \"aa\")## [1] \"apples xaa\"   \"bag of flour\" \"bag of sugar\" \"milk xaa\"\n# https://github.com/hadley/stringb/issues/5\n# x is vector\nstr_replace <- function(x, pattern, fun, ...) {\n  loc <- gregexpr(pattern, text = x, perl = TRUE)\n  matches <- regmatches(x, loc)\n  out <- lapply(matches, fun, ...)\n\n  regmatches(x, loc) <- out\n  x\n}\n\n\nloc <- gregexpr(pattern = \"\\\\d\", text = shopping_list, perl = TRUE)\n\nmatches = regmatches(x = shopping_list, loc)\n\nmatches\n\nout <- lapply(matches, transform, \"aa\")\n\nregmatches(x = shopping_list, loc) <- out\n\n\nshopping_list\n\n\nstr_replace(shopping_list, pattern = \"\\\\\\\\d\", replace = \"aa\")"},{"path":"chap-string-operations.html","id":"tolower","chapter":"第 4 章 字符串操作","heading":"4.14.5 tolower","text":"tolower 和 toupper 是一对，将大写转小写，小写转大写","code":"\nsimpleCap <- function(x) {\n  x <- tolower(x)\n  s <- strsplit(x, \" \")[[1]]\n  paste(toupper(substring(s, 1, 1)), substring(s, 2),\n    sep = \"\", collapse = \" \"\n  )\n}\n# 参考文献条目里需要将每个英文单词的首字母大写\nsimpleCap(x = \"THE USE OF MULTIPLE MEASUREMENTS IN TAXONOMIC PROBLEMS\")## [1] \"The Use Of Multiple Measurements In Taxonomic Problems\""},{"path":"chap-string-operations.html","id":"encode-string","chapter":"第 4 章 字符串操作","heading":"4.15 字符串加密","text":"字符串编码加密， openssl 包提供了 sha1 函数 16","code":"\nlibrary(openssl)\nencode_mobile <- function(phone_number) paste(\"*\", paste(toupper(sha1(sha1(charToRaw(paste(phone_number, \"$1$mobile$\", sep = \"\"))))), collapse = \"\"), sep = \"\")\n# 随意模拟两个手机号\nmobile_vec <- c(\"18601013453\", \"13811674545\")\nsapply(mobile_vec, encode_mobile)##                                 18601013453 \n## \"*B1D46D1D62C7280137F0E14249EE500865247B7B\" \n##                                 13811674545 \n## \"*0554DA6E403491F58F1567DF2EDEB19186B77173\""},{"path":"chap-string-operations.html","id":"performance","chapter":"第 4 章 字符串操作","heading":"4.16 处理性能","text":"当你对一个很长的字符串进行大量的正则表达式匹配的时候，你需要考虑性能问题了，这时候该考虑启用合适的选项，一般来讲， PCRE 比默认的正则表达式引擎快，fixed=TRUE 可以继续加快匹配速度，特别是当每个模式只匹配少量次数时。连接字符串，paste/c/bfile/bracket 函数性能比较\nhttps://wch.github.io/string_builder/index.htmlR 内置的默认正则表达式匹配方式是基于 PCRE 的匹配，options 控制 PCRE 默认的三个选项 PCRE_limit_recursion=NA 、PCRE_study=10 和 PCRE_use_JIT=TRUE，当前系统环境下 PCRE 的支持情况查看R环境的 PCRE 配置","code":"\npcre_config()##              UTF-8 Unicode properties                JIT              stack \n##               TRUE               TRUE               TRUE              FALSE\nsapply(c(\"PCRE_limit_recursion\", \"PCRE_study\", \"PCRE_use_JIT\"), getOption)## PCRE_limit_recursion           PCRE_study         PCRE_use_JIT \n##                   NA                FALSE                 TRUE"},{"path":"chap-string-operations.html","id":"web-crawler","chapter":"第 4 章 字符串操作","heading":"4.17 网络爬虫","text":"用 R 语言写爬虫 curl、httr、 xml2、XML 和 rvest 解析网页17于主编利用 tidyRSS 包 抓取解析博客站点的订阅信息，并将此设置为定时任务，创建自动更新内容的博客聚合网站 Daily R抓取地震台信息一个爬网页的练习：看看 R 邮件列表中最热门的讨论是什么","code":"\n# 查看 libcurl 库的版本\nlibcurlVersion()## [1] \"7.68.0\"\n## attr(,\"ssl_version\")\n## [1] \"OpenSSL/1.1.1f\"\n## attr(,\"libssh_version\")\n## [1] \"libssh/0.9.3/openssl/zlib\"\n## attr(,\"protocols\")\n##  [1] \"dict\"   \"file\"   \"ftp\"    \"ftps\"   \"gopher\" \"http\"   \"https\"  \"imap\"  \n##  [9] \"imaps\"  \"ldap\"   \"ldaps\"  \"pop3\"   \"pop3s\"  \"rtmp\"   \"rtsp\"   \"scp\"   \n## [17] \"sftp\"   \"smb\"    \"smbs\"   \"smtp\"   \"smtps\"  \"telnet\" \"tftp\""},{"path":"chap-string-operations.html","id":"text-mining","chapter":"第 4 章 字符串操作","heading":"4.18 文本挖掘","text":"Axios rectangle Trump’s PDF schedule? try R 使用 pdftools 和 magick 处理表格，这两个 R 包分别依赖 Poppler C++ 和 ImageMagick++，在 Ubuntu 上安装 pdftools 和 magick 包除了 pdftools 包外，PDF 文档中表格抽取工具还有 tabulizer。扫描版 PDF 文档需要OCR识别技术支持的 tesseract 包","code":"sudo apt-get install libpoppler-cpp-dev libmagick++-dev\ninstall.packages(c(\"pdftools\", \"magick\"))"},{"path":"chap-string-operations.html","id":"string-session-info","chapter":"第 4 章 字符串操作","heading":"4.19 运行环境","text":"","code":"\nxfun::session_info()## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-pc-linux-gnu (64-bit)\n## Running under: Ubuntu 20.04.4 LTS\n## \n## Locale:\n##   LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n##   LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n##   LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n##   LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n##   LC_ADDRESS=C               LC_TELEPHONE=C            \n##   LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n## \n## Package version:\n##   askpass_1.1      assertthat_0.2.1 base64enc_0.1.3  bookdown_0.26   \n##   brio_1.1.3       bslib_0.3.1      cachem_1.0.6     cli_3.3.0       \n##   compiler_4.2.0   cpp11_0.4.2      crayon_1.5.1     curl_4.3.2      \n##   DBI_1.1.2        desc_1.4.1       digest_0.6.29    downlit_0.4.0   \n##   dplyr_1.0.9      ellipsis_0.3.2   evaluate_0.15    fansi_1.0.3     \n##   fastmap_1.1.0    fs_1.5.2         generics_0.1.2   glue_1.6.2      \n##   graphics_4.2.0   grDevices_4.2.0  highr_0.9        htmltools_0.5.2 \n##   jquerylib_0.1.4  jsonlite_1.8.0   knitr_1.39       lifecycle_1.0.1 \n##   magrittr_2.0.3   memoise_2.0.1    methods_4.2.0    openssl_2.0.1   \n##   pillar_1.7.0     pkgconfig_2.0.3  purrr_0.3.4      R6_2.5.1        \n##   rappdirs_0.3.3   rlang_1.0.2      rmarkdown_2.14   rprojroot_2.0.3 \n##   sass_0.4.1       stats_4.2.0      stringi_1.7.6    stringr_1.4.0   \n##   sys_3.4          sysfonts_0.8.8   tibble_3.1.7     tidyr_1.2.0     \n##   tidyselect_1.1.2 tinytex_0.39     tools_4.2.0      utf8_1.2.2      \n##   utils_4.2.0      vctrs_0.4.1      xfun_0.31        xml2_1.3.3      \n##   yaml_2.3.5"},{"path":"chap-regular-expressions.html","id":"chap-regular-expressions","chapter":"第 5 章 正则表达式","heading":"第 5 章 正则表达式","text":"Douglas Bates: really want cautious use octal\nrepresentation like sep=\"\\\\007\" get character unlikely \noccur factor level.Ed L. Cashin: definitely want cautious. Instead bell character\nthink ’ll use field separator character, \"\\\\034\", just \nfirst time ’ve able use ’s intended purpose! ;)Douglas Bates: Yes, \"\\\\034\" don’t get make obscure James Bond\nreferences :-)— Douglas Bates Ed L. Cashin\nR-help (April 2004)维基百科关于 正则表达式的描述， 学习正则表达式R 内置的三种匹配模式fixed = TRUE: 字面意思匹配 exact matching.perl = TRUE: 使用 Perl 正则表达式.fixed = FALSE, perl = FALSE: 使用 POSIX 1003.2 extended 正则表达式 (默认设置).不要拘泥于一种解决方案，比如清理数据中正则表达式有 Base R 提供的一套，stringr 又一套，提高效率的工具 RStudio 插件 regexplain 和辅助创建正则表达式 RVerbalExpressions 包。有几个名词需要单独拎出来解释的literal character strings 字面字符串metacharacters 元字符extended regular expressions 在下文中约定翻译为默认正则表达式character class 字符集 [abc]Perl-like regular expressions Perl 风格的正则表达式以下所述，都不考虑函数中参数 perl=TRUE 的情况，R 语言中提供了扩展的（默认的）和 Perl 风格 的两套正则表达式。作为入门，我们这里只关注前者，启用 Perl 正则表达式只需在函数如 grep 中将选项 perl = TRUE 即可，并将后者统一命名为 Perl 正则表达式18。正则表达式 (regular expression，简称 regexp)， 函数 regexpr 和 gregexpr 的名称就好理解了，在控制台输入 ?regex 查看 R 支持的正则表达式，这个文档看上百八十回也不过分。R 内支持正则表达式的函数有 grep、grepl、sub、gsub、regexpr、gregexpr 、 regexec 和 strsplit。函数 apropos，browseEnv，help.search，list.files 和 ls 是通过函数 grep 来使用正则表达式的，它们全都使用 extended regular expressions匹配模式 pattern 的内容 可以用函数 cat 打印出来，注意反斜杠进入 R 字符串中时，需要用两个，反斜杠 \\ 本身是转义符，否则会报错。","code":"\n# 毒鸡汤用来做文本分析\n# https://github.com/egotong/nows/blob/master/soul.sql\ngrep(pattern, x, ignore.case = FALSE, perl = FALSE, value = FALSE,\n     fixed = FALSE, useBytes = FALSE, invert = FALSE)\ncat(\"\\\\\") # \\ 反斜杠是转义字符## \\\ncat(\"\\\\.\")## \\.\ncat(\"\\\\\\n\") # 注意 \\n 表示换行## \\"},{"path":"chap-regular-expressions.html","id":"character-constants","chapter":"第 5 章 正则表达式","heading":"5.1 字符常量","text":"单引号 ' 双引号 \" 和反引号 ` 三种类型的引用 (quotes) 是 R 语法的一部分19，此外反斜杠 \\ 用来转义下面的字符表 5.1:  字符常量表","code":""},{"path":"chap-regular-expressions.html","id":"environments","chapter":"第 5 章 正则表达式","heading":"5.2 软件环境","text":"R 内置的正则表达式实现是基于 PCRE ICU TRE iconv 等第三方库，搞清楚自己使用的版本信息是重要的，一些字符集的解释与区域环境有关，如 [:alnum:] 和 [:alpha:]等，所以获取当前的区域设置也很重要需要临时改变区域环境设置，配合特殊的画图和文本输出要求。","code":"\n# find a suitable coding for the current locale\nlocaleToCharset(locale = Sys.getlocale(\"LC_CTYPE\"))## [1] \"UTF-8\"     \"ISO8859-1\"\n# 软件版本信息\nextSoftVersion()##                                              zlib \n##                                          \"1.2.11\" \n##                                             bzlib \n##                              \"1.0.8, 13-Jul-2019\" \n##                                                xz \n##                                           \"5.2.4\" \n##                                              PCRE \n##                                \"10.39 2021-10-29\" \n##                                               ICU \n##                                            \"66.1\" \n##                                               TRE \n##                         \"TRE 0.8.0 R_fixes (BSD)\" \n##                                             iconv \n##                                      \"glibc 2.31\" \n##                                          readline \n##                                             \"8.0\" \n##                                              BLAS \n## \"/usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\"\n# 区域及其编码信息\nl10n_info()## $MBCS\n## [1] TRUE\n## \n## $`UTF-8`\n## [1] TRUE\n## \n## $`Latin-1`\n## [1] FALSE\n## \n## $codeset\n## [1] \"UTF-8\"\n# 表示数字、货币的细节\nSys.localeconv()##     decimal_point     thousands_sep          grouping   int_curr_symbol \n##               \".\"                \"\"                \"\"            \"USD \" \n##   currency_symbol mon_decimal_point mon_thousands_sep      mon_grouping \n##               \"$\"               \".\"               \",\"        \"\\003\\003\" \n##     positive_sign     negative_sign   int_frac_digits       frac_digits \n##                \"\"               \"-\"               \"2\"               \"2\" \n##     p_cs_precedes    p_sep_by_space     n_cs_precedes    n_sep_by_space \n##               \"1\"               \"0\"               \"1\"               \"0\" \n##       p_sign_posn       n_sign_posn \n##               \"1\"               \"1\"\n# PCRE 启用的配置选项\npcre_config()##              UTF-8 Unicode properties                JIT              stack \n##               TRUE               TRUE               TRUE              FALSE\n# 比较全的字符信息\nstringi::stri_info()## $Unicode.version\n## [1] \"13.0\"\n## \n## $ICU.version\n## [1] \"66.1\"\n## \n## $Locale\n## $Locale$Language\n## [1] \"en\"\n## \n## $Locale$Country\n## [1] \"US\"\n## \n## $Locale$Variant\n## [1] \"\"\n## \n## $Locale$Name\n## [1] \"en_US\"\n## \n## \n## $Charset.internal\n## [1] \"UTF-8\"  \"UTF-16\"\n## \n## $Charset.native\n## $Charset.native$Name.friendly\n## [1] \"UTF-8\"\n## \n## $Charset.native$Name.ICU\n## [1] \"UTF-8\"\n## \n## $Charset.native$Name.UTR22\n## [1] NA\n## \n## $Charset.native$Name.IBM\n## [1] \"ibm-1208\"\n## \n## $Charset.native$Name.WINDOWS\n## [1] \"windows-65001\"\n## \n## $Charset.native$Name.JAVA\n## [1] \"UTF-8\"\n## \n## $Charset.native$Name.IANA\n## [1] \"UTF-8\"\n## \n## $Charset.native$Name.MIME\n## [1] \"UTF-8\"\n## \n## $Charset.native$ASCII.subset\n## [1] TRUE\n## \n## $Charset.native$Unicode.1to1\n## [1] NA\n## \n## $Charset.native$CharSize.8bit\n## [1] FALSE\n## \n## $Charset.native$CharSize.min\n## [1] 1\n## \n## $Charset.native$CharSize.max\n## [1] 3\n## \n## \n## $ICU.system\n## [1] TRUE\n## \n## $ICU.UTF8\n## [1] TRUE\n# 获取当前默认的区域设置\nSys.getlocale()\nfoo <- Sys.getlocale()\n# 恢复默认的区域设置\nSys.setlocale(\"LC_ALL\", locale = foo)"},{"path":"chap-regular-expressions.html","id":"foundations","chapter":"第 5 章 正则表达式","heading":"5.3 基本概念","text":"正则表达式的构造方式类似算术表达式，通过各种操作组合子（更小的）表达式，整个表达式匹配一个或多个字符20。大多数字符，包括所有的字母和数字，是匹配自身的正则表达式。元字符 . \\ | ( ) [ { ^ $ * + ? 需要转义才能表达其自身的含义，转义的方式是在元字符前面添加反斜杠，如要表达点号 . 需要使用 \\.。要注意，它们是否有特殊意义取决于所在的内容。一个字符集 (character class) 是用一对中括号[]括起来的字符列表，用来匹配列表中的任意单个字符，除非列表中的第一个字符是 ^，它用来匹配不在这个列表中的字符。 [0123456789] 用来匹配任意单个数字，[^abc] 用来匹配除字符 ,b,c 以外的任意字符。字符范围 (character ranges) 可以通过第一个和最后一个字符指定， 中间用连字符 (hyphen) 连接， 由于这种解释依赖于区域和具体实现，所以指定字符范围的使用方式最好避免。唯一可移植（便携，通用）的方式是作为字符集，在列表中列出所有的 ASCII 字母，\n[ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz].预定义的一些字符类，它们的解释依赖于当前的语言区域，下面是 POSIX locale 环境下的解释[:alnum:] 表示 [:alpha:] 和 [:digit:]，含义是 [0-9A-Za-z]，但是前者与区域和字符集无关，后者依赖于当前的区域设置和字符编码。要注意在这些字符集名 class names 中，中括号 [] 是符号名的一部分，是必须要包含的。在字符集中，大多数元字符失去它们特殊的意义。[:alnum:] 表示 [:alpha:] 和 [:digit:]，含义是 [0-9A-Za-z]，但是前者与区域和字符集无关，后者依赖于当前的区域设置和字符编码。要注意在这些字符集名 class names 中，中括号 [] 是符号名的一部分，是必须要包含的。在字符集中，大多数元字符失去它们特殊的意义。[:alpha:] 表示 [:lower:] 和 [:upper:][:alpha:] 表示 [:lower:] 和 [:upper:][:blank:] 表示 空格 space 制表符 tab[:blank:] 表示 空格 space 制表符 tab[:cntrl:] 表示控制符，在 ASCII 字符集里里，这些字符有八进制代码，从 000 到 037，和 177(DEL)。[:cntrl:] 表示控制符，在 ASCII 字符集里里，这些字符有八进制代码，从 000 到 037，和 177(DEL)。[:digit:] 表示数字 0,1,2,3,4,5,6,7,8,9[:digit:] 表示数字 0,1,2,3,4,5,6,7,8,9[:graph:] 表示 [:alnum:] 和 [:punct:].[:graph:] 表示 [:alnum:] 和 [:punct:].[:lower:] 表示当前区域下的小写字母[:lower:] 表示当前区域下的小写字母[:print:] 表示可打印的字符 [:alnum:], [:punct:] 和空格.[:print:] 表示可打印的字符 [:alnum:], [:punct:] 和空格.[:punct:] 表示标点字符\n! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` { | } ~`[:punct:] 表示标点字符[:space:] 表示空格字符： 水平制表符 tab， 换行符 newline，垂直制表符 vertical tab，换页符 form feed，回车符 carriage return，空格符 space[:space:] 表示空格字符： 水平制表符 tab， 换行符 newline，垂直制表符 vertical tab，换页符 form feed，回车符 carriage return，空格符 space[:xdigit:] 表示 16 进制数字 0 1 2 3 4 5 6 7 8 9 B C D E F b c d e f.[:xdigit:] 表示 16 进制数字 0 1 2 3 4 5 6 7 8 9 B C D E F b c d e f.要包含字面的 ] 就把它放在列表的开头，类似地，要包含字面 ^，除了开头可以放在任意位置。要包含字面 - 把它放在开头或者结尾。只有 ^ - \\ ] 在字符集内是有特殊的含义点号 . 匹配任意单个字符，\\w 匹配一个词 word 字符(是[[:alnum:]_]的同义词，一个扩展) ，而 \\W 是 \\w 取反，意味着 [^[:alnum:]_]。 \\d, \\s, \\D 和 \\S 表示数字和空格类和它们的取反脱字符 caret ^ 和美元符号 $ 是元字符，分别匹配一行的开头和结尾。符号 \\< 和 \\> 分别匹配一个词的开头和结尾的空字符串。\\b 匹配词边缘的空字符串，\\B 匹配不在词边缘的空字符串。 词 word 的解释依赖于区域和实现。","code":"! \" # $ % & ' ( ) * + , - . / : ; < = > ? @ [ \\ ] ^ _ ` { | } ~`"},{"path":"chap-regular-expressions.html","id":"match","chapter":"第 5 章 正则表达式","heading":"5.4 字符串匹配","text":"默认的匹配方式是贪婪的，会使用尽可能多的匹配次数，这个可以变为最小的匹配次数，通过在其之后添加 ?，一个正则表达式可能跟着重复量词，下面的限定符都是限定在它前面的正则表达式表 5.2:  贪婪匹配限定符","code":""},{"path":"chap-regular-expressions.html","id":"concatenation","chapter":"第 5 章 正则表达式","heading":"5.5 级联表达式","text":"Regular expressions may concatenated; resulting regular expression matches string formed concatenating substrings match concatenated subexpressions.正则表达式可以是级联 concatenation 的，是不是在讲一个正则表达式里面嵌套一个正则表达式？两个正则表达式可以通过中缀符号 | 联合，用两个子表达式的任意一个去匹配字符串，例如 abba | cde 要么匹配字符串 abba 要么匹配字符串 cde，要注意在字符集内，即 abba|cde，二选一的匹配不凑效，因为中缀符 | 有它的字面意思。重复匹配 Repetition 的优先级高于级联，级联高于 | 。 整个子表达式可以括号括起来覆盖这些优先级规则。","code":""},{"path":"chap-regular-expressions.html","id":"backreference","chapter":"第 5 章 正则表达式","heading":"5.6 反向引用","text":"反向引用 \\N 这里 N 可取 1,2,…,9 匹配被之前第 N 个括起来的子表达式匹配的子字符串，例子见 COS 论坛 https://d.cosx.org/d/420570/5","code":""},{"path":"chap-regular-expressions.html","id":"regexp-named-capture","chapter":"第 5 章 正则表达式","heading":"5.7 命名捕捉","text":"模式 (?:...) 包住的字符就是括号分组，但是不做反向查找。模式 (?<=...) 和 (?<!...) 都是反向查找，它们不允许跟限制符，在 ... 也不允许出现 \\C。表 5.3 展示四个反向引用表 5.3:  环顾四周查找函数 regexpr 和 gregexpr 支持命名捕捉 (named capture). 如果一个组被命名了，如 (?<first>[-Z][-z]+) 那么，匹配的位置是按名字返回。下面举个例子说明，从字符串向量 notables 中获得了三组匹配 name.rex 是一段正则表达式，描述的模式是人名notables 是一个长度为2的字符串向量，所以获得两组匹配，捕捉到匹配开始的位置 capture.start 和匹配的长度 capture.length 都是两组，按列来看，字符 B 出现在字符串 Ben Franklin Jefferson Davis 的第三个位置，匹配的长度 Ben 是三个字符，长度是 3，如图 5.1 所示，需要注意的是一定要设置 perl = TRUE 才能使用命名捕捉功能，函数 sub 不支持命名反向引用 Named backreferences\n图 5.1: 命名捕捉\nAtomic grouping 原子分组, possessive qualifiers 占有限定 conditional 条件 recursive 递归等模式超出介绍的范围，不在此处详述，感兴趣的读者可参考，此外，插播一条漫画 5.2\n图 5.2: 正则表达式漫画\n正则表达式的直观解释 https://github.com/gadenbuie/regexplain","code":"\n## named capture\nnotables <- c(\"  Ben Franklin and Jefferson Davis\",\n              \"\\tMillard Fillmore\")\n# name groups 'first' and 'last'\nname.rex <- \"(?<first>[[:upper:]][[:lower:]]+) (?<last>[[:upper:]][[:lower:]]+)\"\nparsed <- regexpr(name.rex, notables, perl = TRUE)\nparsed## [1] 3 2\n## attr(,\"match.length\")\n## [1] 12 16\n## attr(,\"index.type\")\n## [1] \"chars\"\n## attr(,\"useBytes\")\n## [1] TRUE\n## attr(,\"capture.start\")\n##      first last\n## [1,]     3    7\n## [2,]     2   10\n## attr(,\"capture.length\")\n##      first last\n## [1,]     3    8\n## [2,]     7    8\n## attr(,\"capture.names\")\n## [1] \"first\" \"last\""},{"path":"chap-regular-expressions.html","id":"comment","chapter":"第 5 章 正则表达式","heading":"5.8 表达式注释","text":"sequence (?# marks start comment continues next closing parenthesis. Nested parentheses permitted. characters make comment play part pattern matching.extended option set, unescaped # character outside character class introduces comment continues next newline character pattern.批量转换驼峰式命名解析术之 XPath解析术之 CSS Selector","code":"\nold_name <- list.files(\".\", pattern = \"^[A-Z].*.Rmd$\")\nnew_name <- gsub(\"rmd\", \"Rmd\", tolower(old_name))\nfile.rename(from = old_name, to = new_name)\nhtml_lines <- readLines(\"https://movie.douban.com/top250\")\ndoc <- paste0(html_lines, collapse = \"\")\n\ntitle_lines <- grep('class=\"title\"', html_lines, value = T)\ntitles <- gsub(\".*>(.*?)<.*\", \"\\\\1\", title_lines, perl = T)\n\ngsub(\".*>(.*?)<.*\", \"\\\\1\", '<span class=\"title\">肖生克的救赎<\/span>', perl = T)\nlibrary(xml2)\ndom = read_html(doc)\ntitle_nodes = xml_find_all(dom, './/span[@class=\"title\"]')\nxml_text(title_nodes)\nlibrary(rvest)\nread_html(doc) %>%\nhtml_nodes('.title') %>% # class=\"title\"的标签\nhtml_text()"},{"path":"chap-data-manipulation.html","id":"chap-data-manipulation","chapter":"第 6 章 数据操作","heading":"第 6 章 数据操作","text":"data.table 诞生于2006年4月15日（以在 CRAN 上发布的第一个版本时间为准），是基于 data.frame 的扩展和 Base R 的数据操作连贯一些，dplyr 诞生于2014年1月29日，号称数据操作的语法，其实二者套路一致，都是借用 SQL 语言的设计，实现方式不同罢了，前者主要依靠 C 语言完成底层数据操作，总代码量1.29M，C 占65.6%，后者主要依靠 C++ 语言完成底层数据操作，总代码量1.2M，C++ 占34.4%，上层的高级操作接口都是 R 语言。像这样的大神在写代码，码力应该差不多，编程语言会对数据操作的性能有比较大的影响，我想这也是为什么在很多场合下 data.table 霸榜！关于 data.table 和 dplyr 的对比，参看爆栈网的帖子 https://stackoverflow.com/questions/21435339学习 data.table 包最快的方式就是在 R 控制台运行 example(data.table) 并研究其输出。data.table 大大加强了 Base R 提供的数据操作，poorman 提供最常用的数据操作，但是不依赖 dplyr，fst，arrow 和 feather 提供更加高效的数据读写性能。collapse 提供一系列高级和快速的数据操作，支持 Base R、dplyr、tibble、data.table、plm 和 sf 数据框结构类型。关键的特点有：1. 高级的统计编程，提供一系列统计函数支持在向量、矩阵和数据框上做分组和带权计算。fastverse 提供丰富的数据操作和统计计算功能，意图打造一个 tidyverse 替代品。更多参考材料见A data.table dplyr tour，\nBig Data Economics: Data cleaning wrangling 和 DataCamp’s data.table cheatsheet，关于采用 Base R 还是 tidyverse 做数据操作的 讨论，数据操作的动画展示参考 https://github.com/gadenbuie/tidyexplain。\n图 6.1: Tidyverse 和 Base R 的关系\n什么是 Base R? Base R 指的是 R 语言/软件的核心组件，由 R Core Team 维护数据变形，分组统计聚合等，用以作为模型的输入，绘图的对象，操作的数据对象是数据框(data.frame)类型的，而且如果没有特别说明，文中出现的数据集都是 Base R 内置的，第三方 R 包或者来源于网上的数据集都会加以说明。","code":"\nPkgs <- sapply(list.files(R.home(\"library\")), function(x)\n  packageDescription(pkg = x, fields = \"Priority\"))\nnames(Pkgs[Pkgs == \"base\" & !is.na(Pkgs)])##  [1] \"base\"      \"compiler\"  \"datasets\"  \"graphics\"  \"grDevices\" \"grid\"     \n##  [7] \"methods\"   \"parallel\"  \"splines\"   \"stats\"     \"stats4\"    \"tcltk\"    \n## [13] \"tools\"     \"utils\"\nnames(Pkgs[Pkgs == \"recommended\" & !is.na(Pkgs)])##  [1] \"boot\"       \"class\"      \"cluster\"    \"codetools\"  \"foreign\"   \n##  [6] \"KernSmooth\" \"lattice\"    \"MASS\"       \"Matrix\"     \"mgcv\"      \n## [11] \"nlme\"       \"nnet\"       \"rpart\"      \"spatial\"    \"survival\"\n# 给定一个/些 R 包名，返回该 R 包存放的位置\nsapply(.libPaths(), function(pkg_path) {\n  c(\"survival\", \"ggplot2\") %in% .packages(T, lib.loc = pkg_path)\n})##      /home/runner/work/_temp/Library /opt/R/4.2.0/lib/R/library\n## [1,]                           FALSE                       TRUE\n## [2,]                            TRUE                      FALSE"},{"path":"chap-data-manipulation.html","id":"dm-view","chapter":"第 6 章 数据操作","heading":"6.1 查看数据","text":"查看属性查看部分数据集查看文件前（后）5行对象的类型，存储方式查看对象在R环境中所占空间的大小","code":"\nstr(iris)## 'data.frame':    150 obs. of  5 variables:\n##  $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n##  $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n##  $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n##  $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n##  $ Species     : Factor w/ 3 levels \"setosa\",\"versicolor\",..: 1 1 1 1 1 1 1 1 1 1 ...\nhead(iris, 5)##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1          5.1         3.5          1.4         0.2  setosa\n## 2          4.9         3.0          1.4         0.2  setosa\n## 3          4.7         3.2          1.3         0.2  setosa\n## 4          4.6         3.1          1.5         0.2  setosa\n## 5          5.0         3.6          1.4         0.2  setosa\ntail(iris, 5)##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n## 146          6.7         3.0          5.2         2.3 virginica\n## 147          6.3         2.5          5.0         1.9 virginica\n## 148          6.5         3.0          5.2         2.0 virginica\n## 149          6.2         3.4          5.4         2.3 virginica\n## 150          5.9         3.0          5.1         1.8 virginicahead -n 5 test.csv\ntail -n 5 test.csv\nclass(iris)## [1] \"data.frame\"\nmode(iris)## [1] \"list\"\ntypeof(iris)## [1] \"list\"\nobject.size(iris)## 7256 bytes\nobject.size(letters)## 1712 bytes\nobject.size(ls)## 89880 bytes\nformat(object.size(library), units = \"auto\")## [1] \"1.8 Mb\""},{"path":"chap-data-manipulation.html","id":"dm-subset","chapter":"第 6 章 数据操作","heading":"6.2 提取子集","text":"参数 subset代表行操作，select 代表列操作，函数 subset 从数据框中提取部分数据高级操作：加入正则表达式筛选警告：这是一个为了交互使用打造的便捷函数。对于编程，最好使用标准的子集函数，如 [，特别地，参数 subset 的非标准计算(non-standard evaluation)21 可能带来意想不到的后果。使用索引 [选择操作是针对数据框的列（变量/特征/字段）","code":"\nsubset(x, subset, select, drop = FALSE, ...)\nsubset(iris, subset = Species == \"virginica\" & Sepal.Length > 7.5)##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n## 106          7.6         3.0          6.6         2.1 virginica\n## 118          7.7         3.8          6.7         2.2 virginica\n## 119          7.7         2.6          6.9         2.3 virginica\n## 123          7.7         2.8          6.7         2.0 virginica\n## 132          7.9         3.8          6.4         2.0 virginica\n## 136          7.7         3.0          6.1         2.3 virginica\n# summary(iris$Sepal.Length)  mean(iris$Sepal.Length)\n# 且的逻辑\n# subset(iris, Species == \"virginica\" & Sepal.Length > 5.8)\nsubset(iris, Species == \"virginica\" &\n  Sepal.Length == median(Sepal.Length))##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n## 102          5.8         2.7          5.1         1.9 virginica\n## 115          5.8         2.8          5.1         2.4 virginica\n## 143          5.8         2.7          5.1         1.9 virginica\n# 在行的子集范围内\nsubset(iris, Species %in% c(\"virginica\", \"versicolor\") &\n  Sepal.Length == median(Sepal.Length))##     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n## 68           5.8         2.7          4.1         1.0 versicolor\n## 83           5.8         2.7          3.9         1.2 versicolor\n## 93           5.8         2.6          4.0         1.2 versicolor\n## 102          5.8         2.7          5.1         1.9  virginica\n## 115          5.8         2.8          5.1         2.4  virginica\n## 143          5.8         2.7          5.1         1.9  virginica\n# 在列的子集内 先选中列\nsubset(iris, Sepal.Length == median(Sepal.Length),\n  select = c(\"Sepal.Length\", \"Species\")\n)##     Sepal.Length    Species\n## 15           5.8     setosa\n## 68           5.8 versicolor\n## 83           5.8 versicolor\n## 93           5.8 versicolor\n## 102          5.8  virginica\n## 115          5.8  virginica\n## 143          5.8  virginica\n## sometimes requiring a logical 'subset' argument is a nuisance\nnm <- rownames(state.x77)\nstart_with_M <- nm %in% grep(\"^M\", nm, value = TRUE)\nsubset(state.x77, start_with_M, Illiteracy:Murder)##               Illiteracy Life Exp Murder\n## Maine                0.7    70.39    2.7\n## Maryland             0.9    70.22    8.5\n## Massachusetts        1.1    71.83    3.3\n## Michigan             0.9    70.63   11.1\n## Minnesota            0.6    72.96    2.3\n## Mississippi          2.4    68.09   12.5\n## Missouri             0.8    70.69    9.3\n## Montana              0.6    70.56    5.0\n# 简化\nsubset(state.x77, subset = grepl(\"^M\", rownames(state.x77)), select = Illiteracy:Murder)##               Illiteracy Life Exp Murder\n## Maine                0.7    70.39    2.7\n## Maryland             0.9    70.22    8.5\n## Massachusetts        1.1    71.83    3.3\n## Michigan             0.9    70.63   11.1\n## Minnesota            0.6    72.96    2.3\n## Mississippi          2.4    68.09   12.5\n## Missouri             0.8    70.69    9.3\n## Montana              0.6    70.56    5.0\n# 继续简化\nsubset(state.x77, grepl(\"^M\", rownames(state.x77)), Illiteracy:Murder)##               Illiteracy Life Exp Murder\n## Maine                0.7    70.39    2.7\n## Maryland             0.9    70.22    8.5\n## Massachusetts        1.1    71.83    3.3\n## Michigan             0.9    70.63   11.1\n## Minnesota            0.6    72.96    2.3\n## Mississippi          2.4    68.09   12.5\n## Missouri             0.8    70.69    9.3\n## Montana              0.6    70.56    5.0\niris[iris$Species == \"virginica\" & iris$Sepal.Length == 5.8, ]##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n## 102          5.8         2.7          5.1         1.9 virginica\n## 115          5.8         2.8          5.1         2.4 virginica\n## 143          5.8         2.7          5.1         1.9 virginica\niris[iris$Species == \"virginica\" &\n  iris$Sepal.Length == median(iris$Sepal.Length), ]##     Sepal.Length Sepal.Width Petal.Length Petal.Width   Species\n## 102          5.8         2.7          5.1         1.9 virginica\n## 115          5.8         2.8          5.1         2.4 virginica\n## 143          5.8         2.7          5.1         1.9 virginica\niris[\n  iris$Species == \"virginica\" &\n    iris$Sepal.Length == median(iris$Sepal.Length),\n  c(\"Sepal.Length\", \"Species\")\n]##     Sepal.Length   Species\n## 102          5.8 virginica\n## 115          5.8 virginica\n## 143          5.8 virginica\niris[iris$Species == \"setosa\" & iris$Sepal.Length > 5.5, grepl(\"Sepal\", colnames(iris))]##    Sepal.Length Sepal.Width\n## 15          5.8         4.0\n## 16          5.7         4.4\n## 19          5.7         3.8\nsubset(iris,\n  subset = Species == \"setosa\" & Sepal.Length > 5.5,\n  select = grepl(\"Sepal\", colnames(iris))\n)##    Sepal.Length Sepal.Width\n## 15          5.8         4.0\n## 16          5.7         4.4\n## 19          5.7         3.8\nlibrary(data.table)\nmtcars$cars <- rownames(mtcars)\nmtcars_df <- as.data.table(mtcars)\nmtcars_df[, .(mpg, disp)] |> head()##     mpg disp\n## 1: 21.0  160\n## 2: 21.0  160\n## 3: 22.8  108\n## 4: 21.4  258\n## 5: 18.7  360\n## 6: 18.1  225\nmtcars |> \n  dplyr::select(mpg, disp) |> \n  head()##                    mpg disp\n## Mazda RX4         21.0  160\n## Mazda RX4 Wag     21.0  160\n## Datsun 710        22.8  108\n## Hornet 4 Drive    21.4  258\n## Hornet Sportabout 18.7  360\n## Valiant           18.1  225"},{"path":"chap-data-manipulation.html","id":"dm-reshape","chapter":"第 6 章 数据操作","heading":"6.3 数据重塑","text":"重复测量数据的变形 Reshape Grouped Data，将宽格式 wide 的数据框变长格式 long的，反之也行。reshape 还支持正则表达式宽的格式变成长的格式 https://stackoverflow.com/questions/2185252 或者长的格式变成宽的格式 https://stackoverflow.com/questions/5890584/更加复杂的例子， gambia 数据集，重塑的效果是使得个体水平的长格式变为村庄水平的宽格式","code":"\nstr(Indometh)## Classes 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':   66 obs. of  3 variables:\n##  $ Subject: Ord.factor w/ 6 levels \"1\"<\"4\"<\"2\"<\"5\"<..: 1 1 1 1 1 1 1 1 1 1 ...\n##  $ time   : num  0.25 0.5 0.75 1 1.25 2 3 4 5 6 ...\n##  $ conc   : num  1.5 0.94 0.78 0.48 0.37 0.19 0.12 0.11 0.08 0.07 ...\n##  - attr(*, \"formula\")=Class 'formula'  language conc ~ time | Subject\n##   .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n##  - attr(*, \"labels\")=List of 2\n##   ..$ x: chr \"Time since drug administration\"\n##   ..$ y: chr \"Indomethacin concentration\"\n##  - attr(*, \"units\")=List of 2\n##   ..$ x: chr \"(hr)\"\n##   ..$ y: chr \"(mcg/ml)\"\nsummary(Indometh)##  Subject      time            conc       \n##  1:11    Min.   :0.250   Min.   :0.0500  \n##  4:11    1st Qu.:0.750   1st Qu.:0.1100  \n##  2:11    Median :2.000   Median :0.3400  \n##  5:11    Mean   :2.886   Mean   :0.5918  \n##  6:11    3rd Qu.:5.000   3rd Qu.:0.8325  \n##  3:11    Max.   :8.000   Max.   :2.7200\n# 长的变宽\nwide <- reshape(Indometh,\n  v.names = \"conc\", idvar = \"Subject\",\n  timevar = \"time\", direction = \"wide\"\n)\nwide[, 1:6]##    Subject conc.0.25 conc.0.5 conc.0.75 conc.1 conc.1.25\n## 1        1      1.50     0.94      0.78   0.48      0.37\n## 12       2      2.03     1.63      0.71   0.70      0.64\n## 23       3      2.72     1.49      1.16   0.80      0.80\n## 34       4      1.85     1.39      1.02   0.89      0.59\n## 45       5      2.05     1.04      0.81   0.39      0.30\n....\n# 宽的变长\nreshape(wide, direction = \"long\")##        Subject time conc\n## 1.0.25       1 0.25 1.50\n## 2.0.25       2 0.25 2.03\n## 3.0.25       3 0.25 2.72\n## 4.0.25       4 0.25 1.85\n## 5.0.25       5 0.25 2.05\n....\nset.seed(45)\ndat <- data.frame(\n    name = rep(c(\"Orange\", \"Apple\"), each=4),\n    numbers = rep(1:4, 2),\n    value = rnorm(8))\ndat##     name numbers      value\n## 1 Orange       1  0.3407997\n## 2 Orange       2 -0.7033403\n## 3 Orange       3 -0.3795377\n## 4 Orange       4 -0.7460474\n## 5  Apple       1 -0.8981073\n## 6  Apple       2 -0.3347941\n## 7  Apple       3 -0.5013782\n## 8  Apple       4 -0.1745357\nreshape(dat, idvar = \"name\", timevar = \"numbers\", direction = \"wide\")##     name    value.1    value.2    value.3    value.4\n## 1 Orange  0.3407997 -0.7033403 -0.3795377 -0.7460474\n## 5  Apple -0.8981073 -0.3347941 -0.5013782 -0.1745357\n## times need not be numeric\ndf <- data.frame(id = rep(1:4, rep(2,4)),\n                 visit = I(rep(c(\"Before\",\"After\"), 4)),\n                 x = rnorm(4), y = runif(4))\ndf##   id  visit          x          y\n## 1  1 Before  1.8090374 0.89106978\n## 2  1  After -0.2301050 0.06920426\n## 3  2 Before -1.1304182 0.94623103\n## 4  2  After  0.2159889 0.74850150\n## 5  3 Before  1.8090374 0.89106978\n## 6  3  After -0.2301050 0.06920426\n## 7  4 Before -1.1304182 0.94623103\n## 8  4  After  0.2159889 0.74850150\nreshape(df, timevar = \"visit\", idvar = \"id\", direction = \"wide\")##   id  x.Before  y.Before    x.After    y.After\n## 1  1  1.809037 0.8910698 -0.2301050 0.06920426\n## 3  2 -1.130418 0.9462310  0.2159889 0.74850150\n## 5  3  1.809037 0.8910698 -0.2301050 0.06920426\n## 7  4 -1.130418 0.9462310  0.2159889 0.74850150\n## warns that y is really varying\nreshape(df, timevar = \"visit\", idvar = \"id\", direction = \"wide\", v.names = \"x\")## Warning in reshapeWide(data, idvar = idvar, timevar = timevar, varying =\n## varying, : some constant variables (y) are really varying##   id         y  x.Before    x.After\n## 1  1 0.8910698  1.809037 -0.2301050\n## 3  2 0.9462310 -1.130418  0.2159889\n## 5  3 0.8910698  1.809037 -0.2301050\n## 7  4 0.9462310 -1.130418  0.2159889\n# data(gambia, package = \"geoR\")\n# 在线下载数据集\ngambia <- read.table(\n  file =\n    paste(\"http://www.leg.ufpr.br/lib/exe/fetch.php\",\n      \"pessoais:paulojus:mbgbook:datasets:gambia.txt\",\n      sep = \"/\"\n    ), header = TRUE\n)\nhead(gambia)\n# Building a \"village-level\" data frame\nind <- paste(\"x\", gambia[, 1], \"y\", gambia[, 2], sep = \"\")\nvillage <- gambia[!duplicated(ind), c(1:2, 7:8)]\nvillage$prev <- as.vector(tapply(gambia$pos, ind, mean))\nhead(village)"},{"path":"chap-data-manipulation.html","id":"dm-transform","chapter":"第 6 章 数据操作","heading":"6.4 数据转换","text":"transform 对数据框中的某些列做计算，取对数，将计算的结果单存一列加到数据框中验证一下 scale.sl 变量的第一个值Warning: convenience function intended use interactively. programming better use standard subsetting arithmetic functions, particular non-standard evaluation argument transform can unanticipated consequences.","code":"\ntransform(iris[1:6, ], scale.sl = (max(Sepal.Length) - Sepal.Length) / (max(Sepal.Length) - min(Sepal.Length)))##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species scale.sl\n## 1          5.1         3.5          1.4         0.2  setosa    0.375\n## 2          4.9         3.0          1.4         0.2  setosa    0.625\n## 3          4.7         3.2          1.3         0.2  setosa    0.875\n## 4          4.6         3.1          1.5         0.2  setosa    1.000\n## 5          5.0         3.6          1.4         0.2  setosa    0.500\n## 6          5.4         3.9          1.7         0.4  setosa    0.000\n(max(iris$Sepal.Length) - 5.1) / (max(iris$Sepal.Length) - min(iris$Sepal.Length))## [1] 0.7777778"},{"path":"chap-data-manipulation.html","id":"dm-order","chapter":"第 6 章 数据操作","heading":"6.5 按列排序","text":"在数据框内，根据(order)某一列或几列对行进行排序(sort)，根据鸢尾花(iris)的类别(Species)对萼片(sepal)的长度进行排序，其余的列随之变化sort/ordered 排序， 默认是升序根据变量 z","code":"\n# 先对花瓣的宽度排序，再对花瓣的长度排序\nhead(iris[order(iris$Species, iris$Petal.Width, iris$Petal.Length), ]) ##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 14          4.3         3.0          1.1         0.1  setosa\n## 13          4.8         3.0          1.4         0.1  setosa\n## 38          4.9         3.6          1.4         0.1  setosa\n## 10          4.9         3.1          1.5         0.1  setosa\n## 33          5.2         4.1          1.5         0.1  setosa\n## 23          4.6         3.6          1.0         0.2  setosa\ndd <- data.frame(\n  b = factor(c(\"Hi\", \"Med\", \"Hi\", \"Low\"),\n    levels = c(\"Low\", \"Med\", \"Hi\"), ordered = TRUE\n  ),\n  x = c(\"A\", \"D\", \"A\", \"C\"), y = c(8, 3, 9, 9),\n  z = c(1, 1, 1, 2)\n)\nstr(dd)## 'data.frame':    4 obs. of  4 variables:\n##  $ b: Ord.factor w/ 3 levels \"Low\"<\"Med\"<\"Hi\": 3 2 3 1\n##  $ x: chr  \"A\" \"D\" \"A\" \"C\"\n##  $ y: num  8 3 9 9\n##  $ z: num  1 1 1 2\ndd[order(-dd[,4], dd[,1]), ]##     b x y z\n## 4 Low C 9 2\n## 2 Med D 3 1\n## 1  Hi A 8 1\n## 3  Hi A 9 1\ndd[order(dd$z, dd$b), ]##     b x y z\n## 2 Med D 3 1\n## 1  Hi A 8 1\n## 3  Hi A 9 1\n## 4 Low C 9 2"},{"path":"chap-data-manipulation.html","id":"dm-split","chapter":"第 6 章 数据操作","heading":"6.6 数据拆分","text":"数据拆分通常是按找某一个分类变量分组，分完组就是计算，计算完就把结果按照原来的分组方式合并tapply 自带分组的功能，按月份 Month 对 Ozone 中心标准化，其返回一个列表上面的过程等价于由于上面对 Ozone 正态标准化，所以标准化后的 Oz.z 再按月分组计算方差自然每个月都是 1，而均值都是 0。循着这个思路，我们可以用 tapply 实现分组计算，上面函数 sd 和 mean 完全可以用自定义的更加复杂的函数替代cut 函数可以将连续型变量划分为分类变量我们还可以指定参数 dig.lab 设置分组的精度，ordered 将分组变量看作是有序的，breaks 传递单个数时，表示分组数，而不是断点此时，统计每组的频数，如图 6.2\n图 6.2: 连续型变量分组统计\n在指定分组数的情况下，我们还想获取分组的断点用正则表达式抽取断点更多相关函数可以参考 findInterval 和 embedtabulate 和 table 有所不同，它表示排列，由 0 和 1 组成的一个长度为 5 数组，其中 1 有 3 个，则排列组合为","code":"\n## Notice that assignment form is not used since a variable is being added\ng <- airquality$Month\nl <- split(airquality, g) # 分组\nl <- lapply(l, transform, Oz.Z = scale(Ozone)) # 计算：按月对 Ozone 标准化\naq2 <- unsplit(l, g) # 合并\nhead(aq2)##   Ozone Solar.R Wind Temp Month Day       Oz.Z\n## 1    41     190  7.4   67     5   1  0.7822293\n## 2    36     118  8.0   72     5   2  0.5572518\n## 3    12     149 12.6   74     5   3 -0.5226399\n## 4    18     313 11.5   62     5   4 -0.2526670\n## 5    NA      NA 14.3   56     5   5         NA\n## 6    28      NA 14.9   66     5   6  0.1972879\nwith(airquality, tapply(Ozone, Month, scale))## $`5`\n##              [,1]\n##  [1,]  0.78222929\n##  [2,]  0.55725184\n##  [3,] -0.52263993\n##  [4,] -0.25266698\n##  [5,]          NA\n##  [6,]  0.19728792\n##  [7,] -0.02768953\n##  [8,] -0.20767149\n....\ndo.call(\"rbind\", lapply(split(airquality, airquality$Month), transform, Oz.Z = scale(Ozone)))##       Ozone Solar.R Wind Temp Month Day         Oz.Z\n## 5.1      41     190  7.4   67     5   1  0.782229293\n## 5.2      36     118  8.0   72     5   2  0.557251841\n## 5.3      12     149 12.6   74     5   3 -0.522639926\n## 5.4      18     313 11.5   62     5   4 -0.252666984\n## 5.5      NA      NA 14.3   56     5   5           NA\n## 5.6      28      NA 14.9   66     5   6  0.197287919\n## 5.7      23     299  8.6   65     5   7 -0.027689532\n## 5.8      19      99 13.8   59     5   8 -0.207671494\n## 5.9       8      19 20.1   61     5   9 -0.702621887\n....\nwith(aq2, tapply(Oz.Z, Month, sd, na.rm = TRUE))## 5 6 7 8 9 \n## 1 1 1 1 1\nwith(aq2, tapply(Oz.Z, Month, mean, na.rm = TRUE))##             5             6             7             8             9 \n## -4.240273e-17  1.052760e-16  5.841432e-17  5.898060e-17  2.571709e-17\nset.seed(2019)\nZ <- stats::rnorm(10)\ncut(Z, breaks = -6:6)##  [1] (0,1]   (-1,0]  (-2,-1] (0,1]   (-2,-1] (0,1]   (-1,0]  (0,1]   (-2,-1]\n## [10] (-1,0] \n## 12 Levels: (-6,-5] (-5,-4] (-4,-3] (-3,-2] (-2,-1] (-1,0] (0,1] (1,2] ... (5,6]\n# labels = FALSE 返回每个数所落的区间位置\ncut(Z, breaks = -6:6, labels = FALSE)##  [1] 7 6 5 7 5 7 6 7 5 6\ncut(Z, breaks = 3, dig.lab = 4, ordered = TRUE)##  [1] (0.06396,0.9186]  (-0.7881,0.06396] (-1.643,-0.7881]  (0.06396,0.9186] \n##  [5] (-1.643,-0.7881]  (0.06396,0.9186]  (-0.7881,0.06396] (0.06396,0.9186] \n##  [9] (-1.643,-0.7881]  (-0.7881,0.06396]\n## Levels: (-1.643,-0.7881] < (-0.7881,0.06396] < (0.06396,0.9186]\n# 条形图\nplot(cut(Z, breaks = -6:6))\n# 直方图\nhist(Z, breaks = -6:6)\nlabs <- levels(cut(Z, 3))\nlabs## [1] \"(-1.64,-0.788]\" \"(-0.788,0.064]\" \"(0.064,0.919]\"\ncbind(\n  lower = as.numeric(sub(\"\\\\((.+),.*\", \"\\\\1\", labs)),\n  upper = as.numeric(sub(\"[^,]*,([^]]*)\\\\]\", \"\\\\1\", labs))\n)##       lower  upper\n## [1,] -1.640 -0.788\n## [2,] -0.788  0.064\n## [3,]  0.064  0.919\ncombn(5, 3, tabulate, nbins = 5)##      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n## [1,]    1    1    1    1    1    1    0    0    0     0\n## [2,]    1    1    1    0    0    0    1    1    1     0\n## [3,]    1    0    0    1    1    0    1    1    0     1\n## [4,]    0    1    0    1    0    1    1    0    1     1\n## [5,]    0    0    1    0    1    1    0    1    1     1"},{"path":"chap-data-manipulation.html","id":"dm-merge","chapter":"第 6 章 数据操作","heading":"6.7 数据合并","text":"merge 合并两个数据框默认找到同名的列，然后是同名的行合并，多余的没有匹配到的就丢掉还可以指定合并的列，先按照 surname 合并，留下 surname留下的是 name为了比较清楚地观察几种合并的区别，这里提供对应的动画展示 https://github.com/gadenbuie/tidyexplain(inner, outer, left, right, cross) join 共5种合并方式详情请看 https://stackoverflow.com/questions/1299871cbind 和 rbind 分别是按列和行合并数据框","code":"\nauthors <- data.frame(\n  ## I(*) : use character columns of names to get sensible sort order\n  surname = I(c(\"Tukey\", \"Venables\", \"Tierney\", \"Ripley\", \"McNeil\")),\n  nationality = c(\"US\", \"Australia\", \"US\", \"UK\", \"Australia\"),\n  deceased = c(\"yes\", rep(\"no\", 4))\n)\nauthorN <- within(authors, {\n  name <- surname\n  rm(surname)\n})\nbooks <- data.frame(\n  name = I(c(\n    \"Tukey\", \"Venables\", \"Tierney\",\n    \"Ripley\", \"Ripley\", \"McNeil\", \"R Core\"\n  )),\n  title = c(\n    \"Exploratory Data Analysis\",\n    \"Modern Applied Statistics ...\",\n    \"LISP-STAT\",\n    \"Spatial Statistics\", \"Stochastic Simulation\",\n    \"Interactive Data Analysis\",\n    \"An Introduction to R\"\n  ),\n  other.author = c(\n    NA, \"Ripley\", NA, NA, NA, NA,\n    \"Venables & Smith\"\n  )\n)\n\nauthors##    surname nationality deceased\n## 1    Tukey          US      yes\n## 2 Venables   Australia       no\n## 3  Tierney          US       no\n## 4   Ripley          UK       no\n## 5   McNeil   Australia       no\nauthorN##   nationality deceased     name\n## 1          US      yes    Tukey\n## 2   Australia       no Venables\n## 3          US       no  Tierney\n## 4          UK       no   Ripley\n## 5   Australia       no   McNeil\nbooks##       name                         title     other.author\n## 1    Tukey     Exploratory Data Analysis             <NA>\n## 2 Venables Modern Applied Statistics ...           Ripley\n## 3  Tierney                     LISP-STAT             <NA>\n## 4   Ripley            Spatial Statistics             <NA>\n## 5   Ripley         Stochastic Simulation             <NA>\n## 6   McNeil     Interactive Data Analysis             <NA>\n## 7   R Core          An Introduction to R Venables & Smith\nmerge(authorN, books)##       name nationality deceased                         title other.author\n## 1   McNeil   Australia       no     Interactive Data Analysis         <NA>\n## 2   Ripley          UK       no            Spatial Statistics         <NA>\n## 3   Ripley          UK       no         Stochastic Simulation         <NA>\n## 4  Tierney          US       no                     LISP-STAT         <NA>\n## 5    Tukey          US      yes     Exploratory Data Analysis         <NA>\n## 6 Venables   Australia       no Modern Applied Statistics ...       Ripley\nmerge(authors, books, by.x = \"surname\", by.y = \"name\")##    surname nationality deceased                         title other.author\n## 1   McNeil   Australia       no     Interactive Data Analysis         <NA>\n## 2   Ripley          UK       no            Spatial Statistics         <NA>\n## 3   Ripley          UK       no         Stochastic Simulation         <NA>\n## 4  Tierney          US       no                     LISP-STAT         <NA>\n## 5    Tukey          US      yes     Exploratory Data Analysis         <NA>\n## 6 Venables   Australia       no Modern Applied Statistics ...       Ripley\nmerge(books, authors, by.x = \"name\", by.y = \"surname\")##       name                         title other.author nationality deceased\n## 1   McNeil     Interactive Data Analysis         <NA>   Australia       no\n## 2   Ripley            Spatial Statistics         <NA>          UK       no\n## 3   Ripley         Stochastic Simulation         <NA>          UK       no\n## 4  Tierney                     LISP-STAT         <NA>          US       no\n## 5    Tukey     Exploratory Data Analysis         <NA>          US      yes\n## 6 Venables Modern Applied Statistics ...       Ripley   Australia       no"},{"path":"chap-data-manipulation.html","id":"dm-duplicated","chapter":"第 6 章 数据操作","heading":"6.8 数据去重","text":"单个数值型向量去重，此时和 unique 函数作用一样数据框类型数据中，去除重复的行，这个重复可以是多个变量对应的向量去掉字段 cyl 和 gear 有重复的记录，data.table 方式dplyr 方式dplyr 的去重操作不需要拷贝一个新的数据对象 mtcars_df，并且可以以管道的方式将后续的选择操作连接起来，代码更加具有可读性。Base R 和 data.table 提供的 duplicated() 函数和 [ 函数一起实现去重的操作，选择操作放在 [ 实现，[ 其实是一个函数","code":"\n(x <- c(9:20, 1:5, 3:7, 0:8))##  [1]  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5  3  4  5  6  7  0  1  2\n## [26]  3  4  5  6  7  8\n## extract unique elements\nx[!duplicated(x)]##  [1]  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5  6  7  0  8\nunique(x)##  [1]  9 10 11 12 13 14 15 16 17 18 19 20  1  2  3  4  5  6  7  0  8\nset.seed(2019)\ndf <- data.frame(\n  x = sample(0:1, 10, replace = T),\n  y = sample(0:1, 10, replace = T),\n  z = 1:10\n)\ndf##    x y  z\n## 1  0 0  1\n## 2  0 1  2\n## 3  1 0  3\n## 4  0 0  4\n## 5  0 1  5\n## 6  0 1  6\n## 7  1 0  7\n## 8  0 1  8\n## 9  0 0  9\n## 10 1 0 10\ndf[!duplicated(df[, c(\"x\", \"y\")]), ]##   x y z\n## 1 0 0 1\n## 2 0 1 2\n## 3 1 0 3\nmtcars_df[!duplicated(mtcars_df, by = c(\"cyl\", \"gear\"))][,.(mpg, cyl, gear)]##     mpg cyl gear\n## 1: 21.0   6    4\n## 2: 22.8   4    4\n## 3: 21.4   6    3\n## 4: 18.7   8    3\n## 5: 21.5   4    3\n## 6: 26.0   4    5\n## 7: 15.8   8    5\n## 8: 19.7   6    5\nmtcars |> \n  dplyr::distinct(cyl, gear, .keep_all = TRUE) |> \n  dplyr::select(mpg, cyl, gear)##                    mpg cyl gear\n## Mazda RX4         21.0   6    4\n## Datsun 710        22.8   4    4\n## Hornet 4 Drive    21.4   6    3\n## Hornet Sportabout 18.7   8    3\n## Toyota Corona     21.5   4    3\n## Porsche 914-2     26.0   4    5\n## Ford Pantera L    15.8   8    5\n## Ferrari Dino      19.7   6    5\nmtcars_df[!duplicated(mtcars_df[, c(\"cyl\", \"gear\")]), c(\"mpg\",\"cyl\",\"gear\")]##     mpg cyl gear\n## 1: 21.0   6    4\n## 2: 22.8   4    4\n## 3: 21.4   6    3\n## 4: 18.7   8    3\n## 5: 21.5   4    3\n## 6: 26.0   4    5\n## 7: 15.8   8    5\n## 8: 19.7   6    5\nx <- 2:4\nx[1]## [1] 2\n`[`(x, 1)## [1] 2"},{"path":"chap-data-manipulation.html","id":"dm-missing","chapter":"第 6 章 数据操作","heading":"6.9 数据缺失","text":"缺失数据操作对缺失值的处理默认是 na.action = na.omit缺失值处理查看包含缺失的记录，不完整的记录Ozone 和 Solar.R 同时包含缺失值的行","code":"\ndata(\"airquality\")\nhead(airquality)##   Ozone Solar.R Wind Temp Month Day\n## 1    41     190  7.4   67     5   1\n## 2    36     118  8.0   72     5   2\n## 3    12     149 12.6   74     5   3\n## 4    18     313 11.5   62     5   4\n## 5    NA      NA 14.3   56     5   5\n## 6    28      NA 14.9   66     5   6\n# Ozone 最高的那天\naggregate(data = airquality, Ozone ~ Month, max)##   Month Ozone\n## 1     5   115\n## 2     6    71\n## 3     7   135\n## 4     8   168\n## 5     9    96\n# 每月 Ozone, Solar.R, Wind, Temp 平均值\naggregate(data = airquality, Ozone ~ Month, mean)##   Month    Ozone\n## 1     5 23.61538\n## 2     6 29.44444\n## 3     7 59.11538\n## 4     8 59.96154\n## 5     9 31.44828\nlibrary(DataExplorer)\nplot_missing(airquality)\nairquality[!complete.cases(airquality), ]##     Ozone Solar.R Wind Temp Month Day\n## 5      NA      NA 14.3   56     5   5\n## 6      28      NA 14.9   66     5   6\n## 10     NA     194  8.6   69     5  10\n## 11      7      NA  6.9   74     5  11\n## 25     NA      66 16.6   57     5  25\n## 26     NA     266 14.9   58     5  26\n## 27     NA      NA  8.0   57     5  27\n## 32     NA     286  8.6   78     6   1\n## 33     NA     287  9.7   74     6   2\n## 34     NA     242 16.1   67     6   3\n## 35     NA     186  9.2   84     6   4\n## 36     NA     220  8.6   85     6   5\n## 37     NA     264 14.3   79     6   6\n## 39     NA     273  6.9   87     6   8\n## 42     NA     259 10.9   93     6  11\n## 43     NA     250  9.2   92     6  12\n## 45     NA     332 13.8   80     6  14\n## 46     NA     322 11.5   79     6  15\n## 52     NA     150  6.3   77     6  21\n## 53     NA      59  1.7   76     6  22\n## 54     NA      91  4.6   76     6  23\n## 55     NA     250  6.3   76     6  24\n## 56     NA     135  8.0   75     6  25\n## 57     NA     127  8.0   78     6  26\n## 58     NA      47 10.3   73     6  27\n## 59     NA      98 11.5   80     6  28\n## 60     NA      31 14.9   77     6  29\n## 61     NA     138  8.0   83     6  30\n## 65     NA     101 10.9   84     7   4\n## 72     NA     139  8.6   82     7  11\n## 75     NA     291 14.9   91     7  14\n## 83     NA     258  9.7   81     7  22\n## 84     NA     295 11.5   82     7  23\n## 96     78      NA  6.9   86     8   4\n## 97     35      NA  7.4   85     8   5\n## 98     66      NA  4.6   87     8   6\n## 102    NA     222  8.6   92     8  10\n## 103    NA     137 11.5   86     8  11\n## 107    NA      64 11.5   79     8  15\n## 115    NA     255 12.6   75     8  23\n## 119    NA     153  5.7   88     8  27\n## 150    NA     145 13.2   77     9  27\nairquality[is.na(airquality$Ozone) & is.na(airquality$Solar.R), ]##    Ozone Solar.R Wind Temp Month Day\n## 5     NA      NA 14.3   56     5   5\n## 27    NA      NA  8.0   57     5  27"},{"path":"chap-data-manipulation.html","id":"dm-aggregate","chapter":"第 6 章 数据操作","heading":"6.10 数据聚合","text":"分组求和 https://stackoverflow.com/questions/1660124主要是分组统计aggregate: Compute Summary Statistics Data Subsets按照 Species 划分的类别，分组计算，使用公式表示形式，右边一定是分类变量，否则会报错误或者警告，输出奇怪的结果，请读者尝试运行aggregate(Species ~ Sepal.Length, data = iris, mean)。公式法表示分组计算，~ 左手边可以做加 + 减 - 乘 * 除 / 取余 %% 等数学运算。下面以数据集 iris 为例，只对 Sepal.Length 按 Species 分组计算与上述分组统计结果一样的命令，在大数据集上， 与 aggregate 相比，tapply 要快很多，是 tapply 的包裹，处理速度差不多。读者可以构造伪随机数据集验证。对所有变量按 Species 分组计算对变量 Sepal.Length 和 Sepal.Width 求和后，按 Species 分组计算对多个分类变量做分组计算，在数据集 ChickWeight 中 Chick和Diet都是数字编码的分类变量，其中 Chick 是有序的因子变量，Diet 是无序的因子变量，而 Time 是数值型的变量，表示小鸡出生的天数。查看数据集ChickWeight的前几行对于数据集ChickWeight中的有序变量Chick，aggregate 会按照既定顺序返回分组计算的结果分类变量没有用数字编码，以 CO2 数据集为例，该数据集描述草植对二氧化碳的吸收情况，Plant 是具有12个水平的有序的因子变量，Type表示植物的源头分别是魁北克(Quebec)和密西西比(Mississippi)，Treatment表示冷却(chilled)和不冷却(nonchilled)两种处理方式，conc表示周围环境中二氧化碳的浓度，uptake表示植物吸收二氧化碳的速率。对单个变量分组统计对多个变量分组统计，查看二氧化碳吸收速率uptake随类型Type和处理方式Treatment在这个例子中 tapply 和 的输出结果的表示形式不一样，aggregate 返回一个 data.frame 数据框，tapply 返回一个表格 table，返回特殊的数据类型 。Function object-oriented wrapper tapply applied data frames.Group Averages Level Combinations Factors 分组平均","code":"\napropos(\"apply\")##  [1] \"apply\"      \"dendrapply\" \"eapply\"     \"frollapply\" \"kernapply\" \n##  [6] \"lapply\"     \"mapply\"     \"rapply\"     \"sapply\"     \"tapply\"    \n## [11] \"vapply\"\n# 分组求和 colSums colMeans max\nunique(iris$Species)## [1] setosa     versicolor virginica \n## Levels: setosa versicolor virginica\n# 分类求和\n# colSums(iris[iris$Species == \"setosa\", -5])\n# colSums(iris[iris$Species == \"virginica\", -5])\ncolSums(iris[iris$Species == \"versicolor\", -5])## Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n##        296.8        138.5        213.0         66.3\n# apply(iris[iris$Species == \"setosa\", -5], 2, sum)\n# apply(iris[iris$Species == \"setosa\", -5], 2, mean)\n# apply(iris[iris$Species == \"setosa\", -5], 2, min)\n# apply(iris[iris$Species == \"setosa\", -5], 2, max)\napply(iris[iris$Species == \"setosa\", -5], 2, quantile)##      Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 0%            4.3       2.300        1.000         0.1\n## 25%           4.8       3.200        1.400         0.2\n## 50%           5.0       3.400        1.500         0.2\n## 75%           5.2       3.675        1.575         0.3\n## 100%          5.8       4.400        1.900         0.6\n# 按分类变量 Species 分组求和\n# aggregate(subset(iris, select = -Species), by = list(iris[, \"Species\"]), FUN = sum)\naggregate(iris[, -5], list(iris[, 5]), sum)##      Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 1     setosa        250.3       171.4         73.1        12.3\n## 2 versicolor        296.8       138.5        213.0        66.3\n## 3  virginica        329.4       148.7        277.6       101.3\n# 先确定位置，假设有很多分类变量\nind <- which(\"Species\" == colnames(iris))\n# 分组统计\naggregate(iris[, -ind], list(iris[, ind]), sum)##      Group.1 Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 1     setosa        250.3       171.4         73.1        12.3\n## 2 versicolor        296.8       138.5        213.0        66.3\n## 3  virginica        329.4       148.7        277.6       101.3\naggregate(Sepal.Length ~ Species, data = iris, mean)##      Species Sepal.Length\n## 1     setosa        5.006\n## 2 versicolor        5.936\n## 3  virginica        6.588\n# tapply(iris$Sepal.Length, list(iris$Species), mean)\nwith(iris, tapply(Sepal.Length, Species, mean))##     setosa versicolor  virginica \n##      5.006      5.936      6.588\nby(iris$Sepal.Length, iris$Species, mean)## iris$Species: setosa\n## [1] 5.006\n## ------------------------------------------------------------ \n## iris$Species: versicolor\n## [1] 5.936\n## ------------------------------------------------------------ \n## iris$Species: virginica\n## [1] 6.588\naggregate(. ~ Species, data = iris, mean)##      Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 1     setosa        5.006       3.428        1.462       0.246\n## 2 versicolor        5.936       2.770        4.260       1.326\n## 3  virginica        6.588       2.974        5.552       2.026\naggregate(Sepal.Length + Sepal.Width ~ Species, data = iris, mean)##      Species Sepal.Length + Sepal.Width\n## 1     setosa                      8.434\n## 2 versicolor                      8.706\n## 3  virginica                      9.562\n# 查看数据\nstr(ChickWeight)## Classes 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':   578 obs. of  4 variables:\n##  $ weight: num  42 51 59 64 76 93 106 125 149 171 ...\n##  $ Time  : num  0 2 4 6 8 10 12 14 16 18 ...\n##  $ Chick : Ord.factor w/ 50 levels \"18\"<\"16\"<\"15\"<..: 15 15 15 15 15 15 15 15 15 15 ...\n##  $ Diet  : Factor w/ 4 levels \"1\",\"2\",\"3\",\"4\": 1 1 1 1 1 1 1 1 1 1 ...\n##  - attr(*, \"formula\")=Class 'formula'  language weight ~ Time | Chick\n##   .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n##  - attr(*, \"outer\")=Class 'formula'  language ~Diet\n##   .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n##  - attr(*, \"labels\")=List of 2\n##   ..$ x: chr \"Time\"\n##   ..$ y: chr \"Body weight\"\n##  - attr(*, \"units\")=List of 2\n##   ..$ x: chr \"(days)\"\n##   ..$ y: chr \"(gm)\"\nhead(ChickWeight)##   weight Time Chick Diet\n## 1     42    0     1    1\n## 2     51    2     1    1\n## 3     59    4     1    1\n## 4     64    6     1    1\n## 5     76    8     1    1\n....\nstr(ChickWeight)## Classes 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':   578 obs. of  4 variables:\n##  $ weight: num  42 51 59 64 76 93 106 125 149 171 ...\n##  $ Time  : num  0 2 4 6 8 10 12 14 16 18 ...\n##  $ Chick : Ord.factor w/ 50 levels \"18\"<\"16\"<\"15\"<..: 15 15 15 15 15 15 15 15 15 15 ...\n##  $ Diet  : Factor w/ 4 levels \"1\",\"2\",\"3\",\"4\": 1 1 1 1 1 1 1 1 1 1 ...\n##  - attr(*, \"formula\")=Class 'formula'  language weight ~ Time | Chick\n....\naggregate(weight ~ Chick, data = ChickWeight, mean)##    Chick    weight\n## 1     18  37.00000\n## 2     16  49.71429\n## 3     15  60.12500\n## 4     13  67.83333\n## 5      9  81.16667\n....\naggregate(weight ~ Diet, data = ChickWeight, mean)##   Diet   weight\n## 1    1 102.6455\n## 2    2 122.6167\n## 3    3 142.9500\n## 4    4 135.2627\n# 查看数据集\nhead(CO2)##   Plant   Type  Treatment conc uptake\n## 1   Qn1 Quebec nonchilled   95   16.0\n## 2   Qn1 Quebec nonchilled  175   30.4\n## 3   Qn1 Quebec nonchilled  250   34.8\n## 4   Qn1 Quebec nonchilled  350   37.2\n## 5   Qn1 Quebec nonchilled  500   35.3\n## 6   Qn1 Quebec nonchilled  675   39.2\nstr(CO2)## Classes 'nfnGroupedData', 'nfGroupedData', 'groupedData' and 'data.frame':   84 obs. of  5 variables:\n##  $ Plant    : Ord.factor w/ 12 levels \"Qn1\"<\"Qn2\"<\"Qn3\"<..: 1 1 1 1 1 1 1 2 2 2 ...\n##  $ Type     : Factor w/ 2 levels \"Quebec\",\"Mississippi\": 1 1 1 1 1 1 1 1 1 1 ...\n##  $ Treatment: Factor w/ 2 levels \"nonchilled\",\"chilled\": 1 1 1 1 1 1 1 1 1 1 ...\n##  $ conc     : num  95 175 250 350 500 675 1000 95 175 250 ...\n##  $ uptake   : num  16 30.4 34.8 37.2 35.3 39.2 39.7 13.6 27.3 37.1 ...\n##  - attr(*, \"formula\")=Class 'formula'  language uptake ~ conc | Plant\n##   .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n##  - attr(*, \"outer\")=Class 'formula'  language ~Treatment * Type\n##   .. ..- attr(*, \".Environment\")=<environment: R_EmptyEnv> \n##  - attr(*, \"labels\")=List of 2\n##   ..$ x: chr \"Ambient carbon dioxide concentration\"\n##   ..$ y: chr \"CO2 uptake rate\"\n##  - attr(*, \"units\")=List of 2\n##   ..$ x: chr \"(uL/L)\"\n##   ..$ y: chr \"(umol/m^2 s)\"\naggregate(uptake ~ Plant, data = CO2, mean)##    Plant   uptake\n## 1    Qn1 33.22857\n## 2    Qn2 35.15714\n## 3    Qn3 37.61429\n## 4    Qc1 29.97143\n## 5    Qc3 32.58571\n## 6    Qc2 32.70000\n## 7    Mn3 24.11429\n## 8    Mn2 27.34286\n## 9    Mn1 26.40000\n## 10   Mc2 12.14286\n## 11   Mc3 17.30000\n## 12   Mc1 18.00000\naggregate(uptake ~ Type, data = CO2, mean)##          Type   uptake\n## 1      Quebec 33.54286\n## 2 Mississippi 20.88333\naggregate(uptake ~ Treatment, data = CO2, mean)##    Treatment   uptake\n## 1 nonchilled 30.64286\n## 2    chilled 23.78333\naggregate(uptake ~ Type + Treatment, data = CO2, mean)##          Type  Treatment   uptake\n## 1      Quebec nonchilled 35.33333\n## 2 Mississippi nonchilled 25.95238\n## 3      Quebec    chilled 31.75238\n## 4 Mississippi    chilled 15.81429\ntapply(CO2$uptake, list(CO2$Type, CO2$Treatment), mean)##             nonchilled  chilled\n## Quebec        35.33333 31.75238\n## Mississippi   25.95238 15.81429\nby(CO2$uptake, list(CO2$Type, CO2$Treatment), mean)## : Quebec\n## : nonchilled\n## [1] 35.33333\n## ------------------------------------------------------------ \n## : Mississippi\n## : nonchilled\n## [1] 25.95238\n## ------------------------------------------------------------ \n## : Quebec\n## : chilled\n## [1] 31.75238\n## ------------------------------------------------------------ \n## : Mississippi\n## : chilled\n## [1] 15.81429\n# 分组求和\n# by(iris[, 1], INDICES = list(iris$Species), FUN = sum)\n# by(iris[, 2], INDICES = list(iris$Species), FUN = sum)\nby(iris[, 3], INDICES = list(iris$Species), FUN = sum)## : setosa\n## [1] 73.1\n## ------------------------------------------------------------ \n## : versicolor\n## [1] 213\n## ------------------------------------------------------------ \n## : virginica\n## [1] 277.6\nby(iris[1:3], INDICES = list(iris$Species), FUN = sum)## : setosa\n## [1] 494.8\n## ------------------------------------------------------------ \n## : versicolor\n## [1] 648.3\n## ------------------------------------------------------------ \n## : virginica\n## [1] 755.7\nby(iris[1:3], INDICES = list(iris$Species), FUN = summary)## : setosa\n##   Sepal.Length    Sepal.Width     Petal.Length  \n##  Min.   :4.300   Min.   :2.300   Min.   :1.000  \n##  1st Qu.:4.800   1st Qu.:3.200   1st Qu.:1.400  \n##  Median :5.000   Median :3.400   Median :1.500  \n##  Mean   :5.006   Mean   :3.428   Mean   :1.462  \n##  3rd Qu.:5.200   3rd Qu.:3.675   3rd Qu.:1.575  \n##  Max.   :5.800   Max.   :4.400   Max.   :1.900  \n## ------------------------------------------------------------ \n## : versicolor\n##   Sepal.Length    Sepal.Width     Petal.Length \n##  Min.   :4.900   Min.   :2.000   Min.   :3.00  \n##  1st Qu.:5.600   1st Qu.:2.525   1st Qu.:4.00  \n##  Median :5.900   Median :2.800   Median :4.35  \n##  Mean   :5.936   Mean   :2.770   Mean   :4.26  \n##  3rd Qu.:6.300   3rd Qu.:3.000   3rd Qu.:4.60  \n##  Max.   :7.000   Max.   :3.400   Max.   :5.10  \n## ------------------------------------------------------------ \n## : virginica\n##   Sepal.Length    Sepal.Width     Petal.Length  \n##  Min.   :4.900   Min.   :2.200   Min.   :4.500  \n##  1st Qu.:6.225   1st Qu.:2.800   1st Qu.:5.100  \n##  Median :6.500   Median :3.000   Median :5.550  \n##  Mean   :6.588   Mean   :2.974   Mean   :5.552  \n##  3rd Qu.:6.900   3rd Qu.:3.175   3rd Qu.:5.875  \n##  Max.   :7.900   Max.   :3.800   Max.   :6.900\nby(iris, INDICES = list(iris$Species), FUN = summary)## : setosa\n##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n##  Min.   :4.300   Min.   :2.300   Min.   :1.000   Min.   :0.100  \n##  1st Qu.:4.800   1st Qu.:3.200   1st Qu.:1.400   1st Qu.:0.200  \n##  Median :5.000   Median :3.400   Median :1.500   Median :0.200  \n##  Mean   :5.006   Mean   :3.428   Mean   :1.462   Mean   :0.246  \n##  3rd Qu.:5.200   3rd Qu.:3.675   3rd Qu.:1.575   3rd Qu.:0.300  \n##  Max.   :5.800   Max.   :4.400   Max.   :1.900   Max.   :0.600  \n##        Species  \n##  setosa    :50  \n##  versicolor: 0  \n##  virginica : 0  \n##                 \n##                 \n##                 \n## ------------------------------------------------------------ \n## : versicolor\n##   Sepal.Length    Sepal.Width     Petal.Length   Petal.Width          Species  \n##  Min.   :4.900   Min.   :2.000   Min.   :3.00   Min.   :1.000   setosa    : 0  \n##  1st Qu.:5.600   1st Qu.:2.525   1st Qu.:4.00   1st Qu.:1.200   versicolor:50  \n##  Median :5.900   Median :2.800   Median :4.35   Median :1.300   virginica : 0  \n##  Mean   :5.936   Mean   :2.770   Mean   :4.26   Mean   :1.326                  \n##  3rd Qu.:6.300   3rd Qu.:3.000   3rd Qu.:4.60   3rd Qu.:1.500                  \n##  Max.   :7.000   Max.   :3.400   Max.   :5.10   Max.   :1.800                  \n## ------------------------------------------------------------ \n## : virginica\n##   Sepal.Length    Sepal.Width     Petal.Length    Petal.Width   \n##  Min.   :4.900   Min.   :2.200   Min.   :4.500   Min.   :1.400  \n##  1st Qu.:6.225   1st Qu.:2.800   1st Qu.:5.100   1st Qu.:1.800  \n##  Median :6.500   Median :3.000   Median :5.550   Median :2.000  \n##  Mean   :6.588   Mean   :2.974   Mean   :5.552   Mean   :2.026  \n##  3rd Qu.:6.900   3rd Qu.:3.175   3rd Qu.:5.875   3rd Qu.:2.300  \n##  Max.   :7.900   Max.   :3.800   Max.   :6.900   Max.   :2.500  \n##        Species  \n##  setosa    : 0  \n##  versicolor: 0  \n##  virginica :50  \n##                 \n##                 \n## \nstr(warpbreaks)## 'data.frame':    54 obs. of  3 variables:\n##  $ breaks : num  26 30 54 25 70 52 51 26 67 18 ...\n##  $ wool   : Factor w/ 2 levels \"A\",\"B\": 1 1 1 1 1 1 1 1 1 1 ...\n##  $ tension: Factor w/ 3 levels \"L\",\"M\",\"H\": 1 1 1 1 1 1 1 1 1 2 ...\nhead(warpbreaks)##   breaks wool tension\n## 1     26    A       L\n## 2     30    A       L\n## 3     54    A       L\n## 4     25    A       L\n## 5     70    A       L\n## 6     52    A       L\nave(warpbreaks$breaks, warpbreaks$wool)##  [1] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704\n##  [9] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704\n## [17] 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704 31.03704\n## [25] 31.03704 31.03704 31.03704 25.25926 25.25926 25.25926 25.25926 25.25926\n## [33] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926\n## [41] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926\n## [49] 25.25926 25.25926 25.25926 25.25926 25.25926 25.25926\nwith(warpbreaks, ave(breaks, tension, FUN = function(x) mean(x, trim = 0.1)))##  [1] 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875\n## [10] 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125\n## [19] 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625\n## [28] 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875 35.6875\n## [37] 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125 26.3125\n## [46] 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625 21.0625\n# 分组求和\nwith(warpbreaks, ave(breaks, tension, FUN = function(x) sum(x)))##  [1] 655 655 655 655 655 655 655 655 655 475 475 475 475 475 475 475 475 475 390\n## [20] 390 390 390 390 390 390 390 390 655 655 655 655 655 655 655 655 655 475 475\n## [39] 475 475 475 475 475 475 475 390 390 390 390 390 390 390 390 390\n# 分组求和\nwith(iris, ave(Sepal.Length, Species, FUN = function(x) sum(x)))##   [1] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3\n##  [13] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3\n##  [25] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3\n##  [37] 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3 250.3\n##  [49] 250.3 250.3 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8\n##  [61] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8\n##  [73] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8\n##  [85] 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8 296.8\n##  [97] 296.8 296.8 296.8 296.8 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4\n## [109] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4\n## [121] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4\n## [133] 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4 329.4\n## [145] 329.4 329.4 329.4 329.4 329.4 329.4"},{"path":"chap-data-manipulation.html","id":"dm-table","chapter":"第 6 章 数据操作","heading":"6.11 表格统计","text":"介绍操作表格的 table, addmargins, prop.table, xtabs, margin.table, ftabe 等函数table 多个分类变量分组计数统计介绍 warpbreaks 和 airquality 纽约空气质量监测数据集 二维的数据框UCBAdmissions 1973 年加州大学伯克利分校的院系录取数据集 3维的列联表Titanic 4维的列联表数据 泰坦尼克号幸存者数据集以 iris 数据集为例，table 的第一个参数是自己制造的第二个分类变量，原始分类变量是 Species以 airquality 数据集为例，看看月份中臭氧含量比较高的几天对表格按行和列求和，即求表格的边际，查看总体情况臭氧含量超 80 的天数在每个月的占比，addmargins 的第二个参数 1 表示对列求和转换成百分比，将小数四舍五入转化为百分数，保留两位小数点以 UCBAdmissions 数据集为例，使用 xtabs 函数把数据组织成列联表，先查看数据的内容接着将 UCBA2DF 数据集转化为表格的形式将录取性别和院系进行对比男生倾向于申请院系 和 B，女生倾向于申请院系 C 到 F，院系 和 B 是最容易录取的。","code":"\nwith(warpbreaks, table(wool, tension))##     tension\n## wool L M H\n##    A 9 9 9\n##    B 9 9 9\nwith(iris, table(Sepal.check = Sepal.Length > 7, Species))##            Species\n## Sepal.check setosa versicolor virginica\n##       FALSE     50         50        38\n##       TRUE       0          0        12\nwith(iris, table(Sepal.check = Sepal.Length > mean(Sepal.Length), Species))##            Species\n## Sepal.check setosa versicolor virginica\n##       FALSE     50         24         6\n##       TRUE       0         26        44\naiq.tab <- with(airquality, table(Oz.high = Ozone > 80, Month))\naiq.tab##        Month\n## Oz.high  5  6  7  8  9\n##   FALSE 25  9 20 19 27\n##   TRUE   1  0  6  7  2\naddmargins(aiq.tab, 1:2)##        Month\n## Oz.high   5   6   7   8   9 Sum\n##   FALSE  25   9  20  19  27 100\n##   TRUE    1   0   6   7   2  16\n##   Sum    26   9  26  26  29 116\naiq.prop <- prop.table(aiq.tab, 2)\naiq.prop##        Month\n## Oz.high          5          6          7          8          9\n##   FALSE 0.96153846 1.00000000 0.76923077 0.73076923 0.93103448\n##   TRUE  0.03846154 0.00000000 0.23076923 0.26923077 0.06896552\naiq.marprop <- addmargins(aiq.prop, 1)\naiq.marprop##        Month\n## Oz.high          5          6          7          8          9\n##   FALSE 0.96153846 1.00000000 0.76923077 0.73076923 0.93103448\n##   TRUE  0.03846154 0.00000000 0.23076923 0.26923077 0.06896552\n##   Sum   1.00000000 1.00000000 1.00000000 1.00000000 1.00000000\nround(100 * aiq.marprop, 2)##        Month\n## Oz.high      5      6      7      8      9\n##   FALSE  96.15 100.00  76.92  73.08  93.10\n##   TRUE    3.85   0.00  23.08  26.92   6.90\n##   Sum   100.00 100.00 100.00 100.00 100.00\npairs(airquality, panel = panel.smooth, main = \"airquality data\")\nUCBAdmissions## , , Dept = A\n## \n##           Gender\n## Admit      Male Female\n##   Admitted  512     89\n##   Rejected  313     19\n....\nUCBA2DF <- as.data.frame(UCBAdmissions)\nUCBA2DF##       Admit Gender Dept Freq\n## 1  Admitted   Male    A  512\n## 2  Rejected   Male    A  313\n## 3  Admitted Female    A   89\n## 4  Rejected Female    A   19\n## 5  Admitted   Male    B  353\n....\nUCBA2DF.tab <- xtabs(Freq ~ Gender + Admit + Dept, data = UCBA2DF)\nftable(UCBA2DF.tab)##                 Dept   A   B   C   D   E   F\n## Gender Admit                                \n## Male   Admitted      512 353 120 138  53  22\n##        Rejected      313 207 205 279 138 351\n## Female Admitted       89  17 202 131  94  24\n##        Rejected       19   8 391 244 299 317\nprop.table(margin.table(UCBA2DF.tab, c(1, 3)), 1)##         Dept\n## Gender            A          B          C          D          E          F\n##   Male   0.30657748 0.20810108 0.12077295 0.15496098 0.07097733 0.13861018\n##   Female 0.05885559 0.01362398 0.32316076 0.20435967 0.21416894 0.18583106"},{"path":"chap-data-manipulation.html","id":"dm-index","chapter":"第 6 章 数据操作","heading":"6.12 索引访问","text":"与引用 [ 性能比较，在区间 \\([0,1]\\) 上生成 10 万个服从均匀分布的随机数，随机抽取其中\\(\\frac{1}{4}\\)。使用 subset 函数与 [ 比较","code":"\nn <- 100000\nx <- runif(n)\ni <- logical(n)\ni[sample(n, n / 4)] <- TRUE\nmicrobenchmark::microbenchmark(x[i], x[which(i)], times = 1000)"},{"path":"chap-data-manipulation.html","id":"dm-array","chapter":"第 6 章 数据操作","heading":"6.13 多维数组","text":"多维数组的行列是怎么定义的 ?array 轴的概念，画个图表示数组垂直于Z轴的平面去截三维立方体，3 代表 z 轴，得到三个截面（二维矩阵）对每个二维矩阵按列求和asplit 和 lapply 组合处理多维数组的计算问题三维数组的矩阵运算 abind 包提供更多的数组操作，如合并，替换数组操作 aperm 数组转置 Array Transpositionasplit 数组拆分 其后接 lapply 或者 vapplyapply 数组计算rray 包 https://github.com/r-lib/rray","code":"\narray(1:27, c(3, 3, 3))## , , 1\n## \n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n## \n## , , 2\n## \n##      [,1] [,2] [,3]\n## [1,]   10   13   16\n## [2,]   11   14   17\n## [3,]   12   15   18\n## \n## , , 3\n## \n##      [,1] [,2] [,3]\n## [1,]   19   22   25\n## [2,]   20   23   26\n## [3,]   21   24   27\nasplit(array(1:27, c(3, 3, 3)), 3)## [[1]]\n##      [,1] [,2] [,3]\n## [1,]    1    4    7\n## [2,]    2    5    8\n## [3,]    3    6    9\n## \n## [[2]]\n##      [,1] [,2] [,3]\n## [1,]   10   13   16\n## [2,]   11   14   17\n## [3,]   12   15   18\n## \n## [[3]]\n##      [,1] [,2] [,3]\n## [1,]   19   22   25\n## [2,]   20   23   26\n## [3,]   21   24   27\nlapply(asplit(array(1:27, c(3, 3, 3)), 3), apply, 2, sum)## [[1]]\n## [1]  6 15 24\n## \n## [[2]]\n## [1] 33 42 51\n## \n## [[3]]\n## [1] 60 69 78"},{"path":"chap-data-manipulation.html","id":"dm-others","chapter":"第 6 章 数据操作","heading":"6.14 其它操作","text":"成对的数据操作有 list 与 unlist、stack 与 unstack、class 与 unclass、attach 与 detach 以及 和 within，它们在数据操作过程中有时会起到一定的补充作用。","code":""},{"path":"chap-data-manipulation.html","id":"relist-or-unlist","chapter":"第 6 章 数据操作","heading":"6.14.1 列表属性","text":"list 函数用来构造、转化和检查 R 列表对象。下面创建一个临时列表对象 tmp ，它包含两个元素 和 B，两个元素都是向量，前者是数值型，后者是字符型unlist 函数将给定的列表对象 x 简化为原子向量 (atomic vector)，我们发现简化之后变成一个字符型向量unlist 的逆操作是 relist","code":"\n# 创建列表\nlist(...)\npairlist(...)\n# 转化列表\nas.list(x, ...)\n## S3 method for class 'environment'\nas.list(x, all.names = FALSE, sorted = FALSE, ...)\nas.pairlist(x)\n# 检查列表\nis.list(x)\nis.pairlist(x)\n\nalist(...)\n(tmp <- list(A = c(1, 2, 3), B = c(\"a\", \"b\")))## $A\n## [1] 1 2 3\n## \n## $B\n## [1] \"a\" \"b\"\nunlist(x, recursive = TRUE, use.names = TRUE)\nunlist(tmp)##  A1  A2  A3  B1  B2 \n## \"1\" \"2\" \"3\" \"a\" \"b\"\nunlist(tmp, use.names = FALSE)## [1] \"1\" \"2\" \"3\" \"a\" \"b\""},{"path":"chap-data-manipulation.html","id":"stack-or-unstack","chapter":"第 6 章 数据操作","heading":"6.14.2 堆叠向量","text":"stack 与 unstack 将多个向量堆在一起组成一个向量现在再将变量 pg 堆叠起来，还可以指定要堆叠的列形式上和 reshape 有一些相似之处，数据框可以由长变宽或由宽变长","code":"\nstack(x, ...)\n## Default S3 method:\nstack(x, drop = FALSE, ...)\n## S3 method for class 'data.frame'\nstack(x, select, drop = FALSE, ...)\n\nunstack(x, ...)\n## Default S3 method:\nunstack(x, form, ...)\n## S3 method for class 'data.frame'\nunstack(x, form, ...)\n# 查看数据集 PlantGrowth\nclass(PlantGrowth)## [1] \"data.frame\"\nhead(PlantGrowth)##   weight group\n## 1   4.17  ctrl\n## 2   5.58  ctrl\n## 3   5.18  ctrl\n## 4   6.11  ctrl\n## 5   4.50  ctrl\n## 6   4.61  ctrl\n# 检查默认的公式\nformula(PlantGrowth) ## weight ~ group\n# 根据公式解除堆叠\n# 下面等价于 unstack(PlantGrowth, form = weight ~ group)\n(pg <- unstack(PlantGrowth)) ##    ctrl trt1 trt2\n## 1  4.17 4.81 6.31\n## 2  5.58 4.17 5.12\n## 3  5.18 4.41 5.54\n## 4  6.11 3.59 5.50\n## 5  4.50 5.87 5.37\n## 6  4.61 3.83 5.29\n## 7  5.17 6.03 4.92\n## 8  4.53 4.89 6.15\n## 9  5.33 4.32 5.80\n## 10 5.14 4.69 5.26\nstack(pg)##    values  ind\n## 1    4.17 ctrl\n## 2    5.58 ctrl\n## 3    5.18 ctrl\n## 4    6.11 ctrl\n## 5    4.50 ctrl\n....\nstack(pg, select = -ctrl)##    values  ind\n## 1    4.81 trt1\n## 2    4.17 trt1\n## 3    4.41 trt1\n## 4    3.59 trt1\n## 5    5.87 trt1\n...."},{"path":"chap-data-manipulation.html","id":"class-or-unclass","chapter":"第 6 章 数据操作","heading":"6.14.3 属性转化","text":"class 和 unclass 函数用来查看、设置类属性和取消类属性，常用于面向对象的编程设计中","code":"\nclass(x)\nclass(x) <- value\nunclass(x)\ninherits(x, what, which = FALSE)\n\noldClass(x)\noldClass(x) <- value\nclass(iris)## [1] \"data.frame\"\nclass(iris$Species)## [1] \"factor\"\nunclass(iris$Species)##   [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\n##  [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2\n##  [75] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 3 3\n## [112] 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3\n## [149] 3 3\n## attr(,\"levels\")\n...."},{"path":"chap-data-manipulation.html","id":"attach-or-detach","chapter":"第 6 章 数据操作","heading":"6.14.4 绑定环境","text":"attach 和 detach 是否绑定数据框的列名，不推荐操作，推荐使用 ","code":"\nattach(what,\n  pos = 2L, name = deparse(substitute(what), backtick = FALSE),\n  warn.conflicts = TRUE\n)\ndetach(name,\n  pos = 2L, unload = FALSE, character.only = FALSE,\n  force = FALSE\n)\nattach(iris)\nhead(Species)## [1] setosa setosa setosa setosa setosa setosa\n## Levels: setosa versicolor virginica\ndetach(iris)"},{"path":"chap-data-manipulation.html","id":"with-or-within","chapter":"第 6 章 数据操作","heading":"6.14.5 数据环境","text":"data参数 data 用来构造表达式计算的环境。其默认值可以是一个环境，列表，数据框。在 within 函数中 data 参数只能是列表或数据框。\nexpr参数 expr 包含要计算的表达式。在 within 中通常包含一个复合表达式，比如\n\n{\n  <- somefun()\n  b <- otherfun()\n  ...\n  rm(unused1, temp)\n}\n参数 expr 包含要计算的表达式。在 within 中通常包含一个复合表达式，比如with 和 within 计算一组表达式，计算的环境是由数据构造的，后者可以修改原始的数据和下面计算的结果一样，但是更加简洁漂亮within 函数可以修改原数据环境中的多个变量，比如删除、修改和添加等下面再举一个复杂的绘图例子，这个例子来自 boxplot 函数将 boxplot 函数的 subset 参数单独提出来，调用数据子集选择函数 subset ，这里 中只包含一个表达式，所以也可以不用大括号可以作为数据变换 transform 的一种替代，它也比较像 dplyr 包的 mutate 函数transform 只能使用已有的列，变换中间生成的列不能用，所以相比于 transform 函数， within 显得更为灵活","code":"\nwith(data, expr, ...)\nwithin(data, expr, ...)\n## S3 method for class 'list'\nwithin(data, expr, keepAttrs = TRUE, ...)\n{\n  a <- somefun()\n  b <- otherfun()\n  ...\n  rm(unused1, temp)\n}\nwith(mtcars, mpg[cyl == 8 & disp > 350])## [1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8\nmtcars$mpg[mtcars$cyl == 8 & mtcars$disp > 350]## [1] 18.7 14.3 10.4 10.4 14.7 19.2 15.8\n# 原数据集 airquality\nhead(airquality)##   Ozone Solar.R Wind Temp Month Day\n## 1    41     190  7.4   67     5   1\n## 2    36     118  8.0   72     5   2\n## 3    12     149 12.6   74     5   3\n## 4    18     313 11.5   62     5   4\n## 5    NA      NA 14.3   56     5   5\n## 6    28      NA 14.9   66     5   6\naq <- within(airquality, {\n  lOzone <- log(Ozone) # 取对数\n  Month <- factor(month.abb[Month]) # 字符串型转因子型\n  cTemp <- round((Temp - 32) * 5 / 9, 1) # 从华氏温度到摄氏温度转化\n  S.cT <- Solar.R / cTemp # 使用新创建的变量\n  rm(Day, Temp)\n})\n# 修改后的数据集\nhead(aq)##   Ozone Solar.R Wind Month      S.cT cTemp   lOzone\n## 1    41     190  7.4   May  9.793814  19.4 3.713572\n## 2    36     118  8.0   May  5.315315  22.2 3.583519\n## 3    12     149 12.6   May  6.394850  23.3 2.484907\n## 4    18     313 11.5   May 18.742515  16.7 2.890372\n## 5    NA      NA 14.3   May        NA  13.3       NA\n## 6    28      NA 14.9   May        NA  18.9 3.332205\nwith(ToothGrowth, {\n  boxplot(len ~ dose,\n    boxwex = 0.25, at = 1:3 - 0.2,\n    subset = (supp == \"VC\"), col = \"#4285f4\",\n    main = \"Guinea Pigs' Tooth Growth\",\n    xlab = \"Vitamin C dose mg\",\n    ylab = \"tooth length\", ylim = c(0, 35)\n  )\n  boxplot(len ~ dose,\n    add = TRUE, boxwex = 0.25, at = 1:3 + 0.2,\n    subset = supp == \"OJ\", col = \"#EA4335\"\n  )\n  legend(2, 9, c(\"Ascorbic acid\", \"Orange juice\"),\n    fill = c(\"#4285f4\", \"#EA4335\")\n  )\n})\nwith(\n  subset(ToothGrowth, supp == \"VC\"),\n  boxplot(len ~ dose,\n    boxwex = 0.25, at = 1:3 - 0.2,\n    col = \"#4285f4\", main = \"Guinea Pigs' Tooth Growth\",\n    xlab = \"Vitamin C dose mg\",\n    ylab = \"tooth length\", ylim = c(0, 35)\n  )\n)\nwith(\n  subset(ToothGrowth, supp == \"OJ\"),\n  boxplot(len ~ dose,\n    add = TRUE, boxwex = 0.25, at = 1:3 + 0.2,\n    col = \"#EA4335\"\n  )\n)\nlegend(2, 9, c(\"Ascorbic acid\", \"Orange juice\"),\n  fill = c(\"#4285f4\", \"#EA4335\")\n)\nwithin(mtcars[1:5,1:3],{\n  disp.cc <- disp * 2.54^3\n  disp.l <- disp.cc / 1e3\n})##                    mpg cyl disp   disp.l  disp.cc\n## Mazda RX4         21.0   6  160 2.621930 2621.930\n## Mazda RX4 Wag     21.0   6  160 2.621930 2621.930\n## Datsun 710        22.8   4  108 1.769803 1769.803\n## Hornet 4 Drive    21.4   6  258 4.227863 4227.863\n## Hornet Sportabout 18.7   8  360 5.899343 5899.343\n# 只能使用已有的列，刚生成的列不能用\n# transform(\n#   mtcars[1:5, 1:3],\n#   disp.cc = disp * 2.54^3,\n#   disp.l = disp.cc / 1e3\n# )\ntransform(\n  mtcars[1:5, 1:3],\n  disp.cc = disp * 2.54^3\n)##                    mpg cyl disp  disp.cc\n## Mazda RX4         21.0   6  160 2621.930\n## Mazda RX4 Wag     21.0   6  160 2621.930\n## Datsun 710        22.8   4  108 1769.803\n## Hornet 4 Drive    21.4   6  258 4227.863\n## Hornet Sportabout 18.7   8  360 5899.343"},{"path":"chap-data-manipulation.html","id":"dm-apply-family","chapter":"第 6 章 数据操作","heading":"6.15 apply 族","text":"表 6.1:  apply 函数除此之外，还有 dendrapply() 专门处理层次聚类或分类回归树型结构， 而函数 kernapply() 用于时间序列的平滑处理\n图 6.3: 太阳黑子的频谱\n将函数应用到多个向量，返回一个列表，生成四组服从正态分布 \\(\\mathcal{N}(\\mu_i,\\sigma_i)\\) 的随机数，它们的均值和方差依次是 \\(\\mu_i = \\sigma_i = 1 \\ldots 4\\)我们借用图6.4来看一下 mapply 的效果，多组随机数生成非常有助于快速模拟。\n图 6.4:  lapply 函数\n分别计算每个样本的平均值分别计算每个样本的1，2，3 分位点仅用 sapply() 函数替换上面的 lapply()，我们可以得到一个矩阵，值得注意的是函数 quantile() 和 fivenum() 算出来的结果有一些差异vapply 和 sapply 类似，但是预先指定返回值类型，这样可以更加安全，有时也更快。以数据集 presidents 为例，它是一个 ts 对象类型的时间序列数据，记录了 1945 年至 1974 年每个季度美国总统的支持率，这组数据中存在缺失值，以 NA 表示。支持率的变化趋势见图 6.5。\n图 6.5: 1945-1974美国总统的支持率\n计算这 30 年每个季度的平均支持率cycle() 函数计算序列中每个观察值在周期中的位置，presidents 的周期为 4，根据位置划分组，然后分组求平均，也可以化作如下计算步骤，虽然看起来复杂，但是数据操作的过程很清晰，不再看起来像是一个黑箱。tapply 函数来做分组求和","code":"\n# Reproduce example 10.4.3 from Brockwell and Davis (1991) [@Brockwell_1991_Time]\nspectrum(sunspot.year, kernel = kernel(\"daniell\", c(11, 7, 3)), log = \"no\")\nmeans <- 1:4\nsds <- 1:4\nset.seed(2020)\nsamples <- mapply(rnorm,\n  mean = means, sd = sds,\n  MoreArgs = list(n = 10), SIMPLIFY = FALSE\n)\nsamples## [[1]]\n##  [1]  1.37697212  1.30154837 -0.09802317 -0.13040590 -1.79653432  1.72057350\n##  [7]  1.93912102  0.77062225  2.75913135  1.11736679\n## \n## [[2]]\n##  [1]  0.2937544  3.8185184  4.3927459  1.2568322  1.7534795  5.6000862\n##  [7]  5.4079918 -4.0775292 -2.5779499  2.1166070\n## \n## [[3]]\n##  [1] 9.523096 6.294548 3.954661 2.780557 5.502806 3.596252 6.893524 5.810155\n##  [9] 2.557700 3.331296\n## \n## [[4]]\n##  [1]  0.7499813  1.0251913  8.3813803 13.7414948  5.5524739  5.1625107\n##  [7]  2.8576069  4.3040589  1.7588056  5.7887535\npar(mfrow = c(2, 2), mar = c(2, 2, 2, 2))\ninvisible(lapply(samples, function(x) {\n  plot(x, pch = 16, col = \"grey\")\n  abline(h = mean(x), lwd = 2, col = \"darkorange\")\n}))\nsapply(samples, mean)## [1] 0.8960372 1.7984536 5.0244596 4.9322257\nlapply(samples, quantile, probs = 1:3 / 4)## [[1]]\n##       25%       50%       75% \n## 0.1191382 1.2094576 1.6346732 \n## \n## [[2]]\n##       25%       50%       75% \n## 0.5345238 1.9350433 4.2491890 \n## \n## [[3]]\n##      25%      50%      75% \n## 3.397535 4.728734 6.173450 \n## \n## [[4]]\n##      25%      50%      75% \n## 2.033506 4.733285 5.729684\nsapply(samples, quantile, probs = 1:3 / 4)##          [,1]      [,2]     [,3]     [,4]\n## 25% 0.1191382 0.5345238 3.397535 2.033506\n## 50% 1.2094576 1.9350433 4.728734 4.733285\n## 75% 1.6346732 4.2491890 6.173450 5.729684\nvapply(samples, fivenum, c(Min. = 0, \"1st Qu.\" = 0, Median = 0, \"3rd Qu.\" = 0, Max. = 0))##                [,1]       [,2]     [,3]       [,4]\n## Min.    -1.79653432 -4.0775292 2.557700  0.7499813\n## 1st Qu. -0.09802317  0.2937544 3.331296  1.7588056\n## Median   1.20945758  1.9350433 4.728734  4.7332848\n## 3rd Qu.  1.72057350  4.3927459 6.294548  5.7887535\n## Max.     2.75913135  5.6000862 9.523096 13.7414948\nplot(presidents)\ntapply(presidents, cycle(presidents), mean, na.rm = TRUE)##        1        2        3        4 \n## 58.44828 56.43333 57.22222 53.07143\n# 一个变量分组求和\ntapply(warpbreaks$breaks, warpbreaks[, 3, drop = FALSE], sum)## tension\n##   L   M   H \n## 655 475 390\n# 两个变量分组计数\nwith(warpbreaks, table(wool, tension))##     tension\n## wool L M H\n##    A 9 9 9\n##    B 9 9 9\n# 两个变量分组求和\ndat <- aggregate(breaks ~ wool + tension, data = warpbreaks, sum) |>\n  reshape(v.names = \"breaks\", idvar = \"wool\", timevar = \"tension\", direction = \"wide\", sep = \"\")\n\n`colnames<-`(dat, gsub(pattern = \"(breaks)\", x = colnames(dat), replacement = \"\"))##   wool   L   M   H\n## 1    A 401 216 221\n## 2    B 254 259 169"},{"path":"chap-data-manipulation.html","id":"sec-option-with","chapter":"第 6 章 数据操作","heading":"6.16 with 选项","text":"注意 data.table 与 Base R 不同的地方需要使用 = FALSE 选项不使用 选项，用函数 mget() 将字符串转变量更加 data.table 风格的方式见with 还可以这样用，直接修改、添加一列\n图 6.6: 操作\n","code":"\n# https://github.com/Rdatatable/data.table/issues/4513\n# https://d.cosx.org/d/421532-datatable-base-r\nlibrary(data.table)\niris <- as.data.table(iris)\niris[Species == \"setosa\" & Sepal.Length > 5.5, grepl(\"Sepal\", colnames(iris))]## [1]  TRUE  TRUE FALSE FALSE FALSE\niris[Species == \"setosa\" & Sepal.Length > 5.5,\n  grepl(\"Sepal\", colnames(iris)),\n  with = FALSE\n]##    Sepal.Length Sepal.Width\n## 1:          5.8         4.0\n## 2:          5.7         4.4\n## 3:          5.7         3.8\niris[\n  Species == \"setosa\" & Sepal.Length > 5.5,\n  mget(grep(\"Sepal\", colnames(iris), value = TRUE))\n]##    Sepal.Length Sepal.Width\n## 1:          5.8         4.0\n## 2:          5.7         4.4\n## 3:          5.7         3.8\niris[Species == \"setosa\" & Sepal.Length > 5.5, .SD, .SDcols = patterns(\"Sepal\")]##    Sepal.Length Sepal.Width\n## 1:          5.8         4.0\n## 2:          5.7         4.4\n## 3:          5.7         3.8\ndf <- expand.grid(x = 1:10, y = 1:10)\ndf$z <- with(df, x^2 + y^2)\ndf <- subset(df, z < 100)\ndf <- df[sample(nrow(df)), ]\nhead(df)##    x y  z\n## 7  7 1 50\n## 8  8 1 65\n## 65 5 7 74\n## 14 4 2 20\n## 37 7 4 65\n## 5  5 1 26\nlibrary(ggplot2)\nggplot(df, aes(x, y, z = z)) +\n  geom_contour()"},{"path":"chap-data-manipulation.html","id":"sec-aggregate","chapter":"第 6 章 数据操作","heading":"6.17 分组聚合","text":"按 Species 分组，对 Sepal.Length 中大于平均值的数取平均shiny 前端传递字符串向量，借助 mget() 函数根据选择的变量分组统计计算，只有一个变量可以使用 get() 传递变量给 data.table","code":"\nmethods(\"aggregate\")## [1] aggregate.data.frame aggregate.default*   aggregate.formula*  \n## [4] aggregate.ts        \n## see '?methods' for accessing help and source code\nargs(\"aggregate.data.frame\")## function (x, by, FUN, ..., simplify = TRUE, drop = TRUE) \n## NULL\nargs(\"aggregate.ts\")## function (x, nfrequency = 1, FUN = sum, ndeltat = 1, ts.eps = getOption(\"ts.eps\"), \n##     ...) \n## NULL\n# getAnywhere(aggregate.formula)\naggregate(Sepal.Length ~ Species, iris, function(x) mean(x[x > mean(x)]))##      Species Sepal.Length\n## 1     setosa     5.313636\n## 2 versicolor     6.375000\n## 3  virginica     7.159091\nlibrary(data.table)\n\ndt <- data.table(\n  x = rep(1:3, each = 3), y = rep(1:3, 3),\n  z = rep(c(\"A\", \"B\", \"C\"), 3), w = rep(c(\"a\", \"b\", \"a\"), each = 3)\n)\n\ndt[, .(x_sum = sum(x), y_sum = sum(y)), by = .(z, w)]##    z w x_sum y_sum\n## 1: A a     4     2\n## 2: B a     4     4\n## 3: C a     4     6\n## 4: A b     2     1\n## 5: B b     2     2\n## 6: C b     2     3\ndt[, .(x_sum = sum(x), y_sum = sum(y)), by = mget(c(\"z\", \"w\"))]##    z w x_sum y_sum\n## 1: A a     4     2\n## 2: B a     4     4\n## 3: C a     4     6\n## 4: A b     2     1\n## 5: B b     2     2\n## 6: C b     2     3\nlibrary(shiny)\n\nui <- fluidPage(\n  fluidRow(\n    column(\n      6,\n      selectInput(\"input_vars\",\n        label = \"变量\", # 给筛选框取名\n        choices = c(z = \"z\", w = \"w\"), # 待选的值\n        selected = \"z\", # 指定默认值\n        multiple = TRUE # 允许多选\n      ),\n      DT::dataTableOutput(\"output_table\")\n    )\n  )\n)\n\nlibrary(data.table)\nlibrary(magrittr)\n\ndt <- data.table(\n  x = rep(1:3, each = 3), y = rep(1:3, 3),\n  z = rep(c(\"A\", \"B\", \"C\"), 3), w = rep(c(\"a\", \"b\", \"a\"), each = 3)\n)\n\nserver <- function(input, output, session) {\n  output$output_table <- DT::renderDataTable(\n    {\n      dt[, .(x_sum = sum(x), y_sum = sum(y)), by = mget(input$input_vars)] |>\n        DT::datatable()\n    },\n    server = FALSE\n  )\n}\n\n# 执行\nshinyApp(ui = ui, server = server)"},{"path":"chap-data-manipulation.html","id":"sec-merge-two-tables","chapter":"第 6 章 数据操作","heading":"6.18 合并操作","text":"保留两个数据集中的所有行","code":"\ndat1 <- data.frame(x = c(0, 0, 10, 10, 20, 20, 30, 30), y = c(1, 1, 2, 2, 3, 3, 4, 4))\ndat2 <- data.frame(x = c(0, 10, 20, 30), z = c(3, 4, 5, 6))\n\ndata.frame(dat1, z = dat2$z[match(dat1$x, dat2$x)])##    x y z\n## 1  0 1 3\n## 2  0 1 3\n## 3 10 2 4\n## 4 10 2 4\n## 5 20 3 5\n## 6 20 3 5\n## 7 30 4 6\n## 8 30 4 6\nmerge(dat1, dat2)##    x y z\n## 1  0 1 3\n## 2  0 1 3\n## 3 10 2 4\n## 4 10 2 4\n## 5 20 3 5\n## 6 20 3 5\n## 7 30 4 6\n## 8 30 4 6"},{"path":"chap-data-manipulation.html","id":"sec-reshape","chapter":"第 6 章 数据操作","heading":"6.19 长宽转换","text":"PlantGrowth 数据集的重塑操作也可以使用内置的函数 reshape() 实现表 6.2: 不同生长环境下植物的干重或者，我们也可以使用 tidyr 包提供的 pivot_wider() 函数或者，我们还可以使用 data.table 包提供的 dcast() 函数，用于将长格式的数据框重塑为宽格式的","code":"\nargs(\"reshape\")## function (data, varying = NULL, v.names = NULL, timevar = \"time\", \n##     idvar = \"id\", ids = 1L:NROW(data), times = seq_along(varying[[1L]]), \n##     drop = NULL, direction, new.row.names = NULL, sep = \".\", \n##     split = if (sep == \"\") {\n##         list(regexp = \"[A-Za-z][0-9]\", include = TRUE)\n##     } else {\n##         list(regexp = sep, include = FALSE, fixed = TRUE)\n##     }) \n## NULL\nPlantGrowth$id <- rep(1:10, 3)\ndat <- reshape(\n  data = PlantGrowth, idvar = \"group\", v.names = \"weight\",\n  timevar = \"id\", direction = \"wide\",\n  sep = \"\"\n)\nknitr::kable(dat,\n  caption = \"不同生长环境下植物的干重\", row.names = FALSE,\n  col.names = gsub(\"(weight)\", \"\", names(dat)),\n  align = \"c\"\n)\ntidyr::pivot_wider(\n  data = PlantGrowth, id_cols = id,\n  names_from = group, values_from = weight\n)## # A tibble: 10 × 4\n##       id  ctrl  trt1  trt2\n##    <int> <dbl> <dbl> <dbl>\n##  1     1  4.17  4.81  6.31\n##  2     2  5.58  4.17  5.12\n##  3     3  5.18  4.41  5.54\n##  4     4  6.11  3.59  5.5 \n##  5     5  4.5   5.87  5.37\n##  6     6  4.61  3.83  5.29\n##  7     7  5.17  6.03  4.92\n##  8     8  4.53  4.89  6.15\n##  9     9  5.33  4.32  5.8 \n## 10    10  5.14  4.69  5.26\nPlantGrowth_DT <- as.data.table(PlantGrowth)\n# 纵\ndcast(PlantGrowth_DT, id ~ group, value.var = \"weight\")##     id ctrl trt1 trt2\n##  1:  1 4.17 4.81 6.31\n##  2:  2 5.58 4.17 5.12\n##  3:  3 5.18 4.41 5.54\n##  4:  4 6.11 3.59 5.50\n##  5:  5 4.50 5.87 5.37\n##  6:  6 4.61 3.83 5.29\n##  7:  7 5.17 6.03 4.92\n##  8:  8 4.53 4.89 6.15\n##  9:  9 5.33 4.32 5.80\n## 10: 10 5.14 4.69 5.26\n# 横\ndcast(PlantGrowth_DT, group ~ id, value.var = \"weight\")##    group    1    2    3    4    5    6    7    8    9   10\n## 1:  ctrl 4.17 5.58 5.18 6.11 4.50 4.61 5.17 4.53 5.33 5.14\n## 2:  trt1 4.81 4.17 4.41 3.59 5.87 3.83 6.03 4.89 4.32 4.69\n## 3:  trt2 6.31 5.12 5.54 5.50 5.37 5.29 4.92 6.15 5.80 5.26"},{"path":"chap-data-manipulation.html","id":"sec-filter-columns","chapter":"第 6 章 数据操作","heading":"6.20 对符合条件的列操作","text":"用 Base R 提供的管道符号 |> 将 data.table 数据操作与 ggplot2 数据可视化连接起来\n图 6.7: 管道连接数据操作和可视化\n","code":"\n# 数值型变量的列的位置\nwhich(sapply(iris, is.numeric))## Sepal.Length  Sepal.Width Petal.Length  Petal.Width \n##            1            2            3            4\niris[, sapply(iris, is.numeric), with = F][Sepal.Length > 7.5]##    Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 1:          7.6         3.0          6.6         2.1\n## 2:          7.7         3.8          6.7         2.2\n## 3:          7.7         2.6          6.9         2.3\n## 4:          7.7         2.8          6.7         2.0\n## 5:          7.9         3.8          6.4         2.0\n## 6:          7.7         3.0          6.1         2.3\nclass(iris)## [1] \"data.table\" \"data.frame\"\nlibrary(ggplot2)\niris |>\n  subset(Species == \"setosa\" & Sepal.Length > 5.5) |>\n  # 行过滤\n  # subset(select = grep(\"Sepal\", colnames(iris), value = TRUE)) |> # 列过滤\n  subset(select = grepl(\"Sepal\", colnames(iris))) |>\n  ggplot(aes(x = Sepal.Length, y = Sepal.Width)) + # 绘图\n  geom_point()"},{"path":"chap-data-manipulation.html","id":"sec-case-when","chapter":"第 6 章 数据操作","heading":"6.21 CASE WHEN 和 fcase","text":"CASE 是 SQL 中的条件判断语句，data.table 中的函数 fcase() 可与之等价。值得注意的是，fcase() 需要 data.table 版本 1.13.0 及以上。","code":"\ndat <- data.table(\n  weights = c(56.8, 57.2, 46.3, 38.5),\n  gender = c(\"1\", \"0\", \"\", \"0\")\n)\n# 1 表示男，0表示女，空表示未知\ntransform(dat, gender_cn = fcase(\n  gender == \"1\", \"男\",\n  gender == \"0\", \"女\",\n  gender == \"\", \"未知\"\n))##    weights gender gender_cn\n## 1:    56.8      1        男\n## 2:    57.2      0        女\n## 3:    46.3             未知\n## 4:    38.5      0        女"},{"path":"chap-data-manipulation.html","id":"sec-datatable-in-action","chapter":"第 6 章 数据操作","heading":"6.22 数据操作实战","text":"Toby Dylan Hocking 在 useR! 2020 大会上分享的幻灯片 https://github.com/tdhock/r-devel-emails","code":""},{"path":"chap-data-manipulation.html","id":"sec-faq-operations","chapter":"第 6 章 数据操作","heading":"6.23 高频数据操作","text":"以数据集 dat 为例介绍常用的数据操作","code":"\nset.seed(2020)\ndat <- data.frame(\n  num_a = rep(seq(4), each = 4), num_b = rep(seq(4), times = 4),\n  group_a = sample(x = letters[1:3], size = 16, replace = T),\n  group_b = sample(x = LETTERS[1:3], size = 16, replace = T)\n)\ndat <- as.data.table(dat)\ndat##     num_a num_b group_a group_b\n##  1:     1     1       c       B\n##  2:     1     2       b       B\n##  3:     1     3       a       B\n##  4:     1     4       a       C\n##  5:     2     1       b       B\n##  6:     2     2       b       C\n##  7:     2     3       a       B\n##  8:     2     4       a       A\n##  9:     3     1       b       C\n## 10:     3     2       b       B\n## 11:     3     3       b       B\n## 12:     3     4       a       B\n## 13:     4     1       b       C\n## 14:     4     2       c       B\n## 15:     4     3       b       C\n## 16:     4     4       a       C"},{"path":"chap-data-manipulation.html","id":"subsec-reduce-merge","chapter":"第 6 章 数据操作","heading":"6.23.1 循环合并","text":"问题来源 Faster version Reduce(merge, list(DT1,DT2,DT3,…)) called mergelist (la rbindlist)","code":""},{"path":"chap-data-manipulation.html","id":"subsec-count-by-group","chapter":"第 6 章 数据操作","heading":"6.23.2 分组计数","text":"","code":"\ndat[, .(length(num_a)), by = .(group_a)] # dat[, .N , by = .(group_a)]##    group_a V1\n## 1:       c  2\n## 2:       b  8\n## 3:       a  6\ndat[, .(length(num_a)), by = .(group_b)]##    group_b V1\n## 1:       B  9\n## 2:       C  6\n## 3:       A  1\ndat[, .(length(num_a)), by = .(group_a, group_b)]##    group_a group_b V1\n## 1:       c       B  2\n## 2:       b       B  4\n## 3:       a       B  3\n## 4:       a       C  2\n## 5:       b       C  4\n## 6:       a       A  1"},{"path":"chap-data-manipulation.html","id":"subsec-sample-by-group","chapter":"第 6 章 数据操作","heading":"6.23.3 分组抽样","text":"以 group_a 为组别， 、 b、 c 分别有 6、 8、 2 条记录可能存在该组样本不平衡，有的组的样本量不足你想要的样本量。每个组无放回地抽取 4 个样本，如果该组样本量不足 4，则全部抽取全部样本量。还可以按照指定的比例抽取样本量 22","code":"\n# 无放回的抽样\ndt_sample_1 <- dat[, .SD[sample(x = .N, size = 2, replace = FALSE)], by = group_a]\n# 有放回的随机抽样\ndt_sample_2 <- dat[, .SD[sample(x = .N, size = 3, replace = TRUE)], by = group_a]\ndat[, .SD[sample(x = .N, size = min(4, .N))], by = group_a]##     group_a num_a num_b group_b\n##  1:       c     1     1       B\n##  2:       c     4     2       B\n##  3:       b     3     2       B\n##  4:       b     2     2       C\n##  5:       b     2     1       B\n##  6:       b     3     3       B\n##  7:       a     1     3       B\n##  8:       a     2     3       B\n##  9:       a     2     4       A\n## 10:       a     1     4       C"},{"path":"chap-data-manipulation.html","id":"subsec-order-by-group","chapter":"第 6 章 数据操作","heading":"6.23.4 分组排序","text":"data.table 包的分组排序问题 https://d.cosx.org/d/421650-datatable/3setorder() 函数直接修改原始数据记录的排序参考多个列分组排序 23如果数据集 dat 包含缺失值，考虑去掉缺失值如果数据集 dat 包含重复值，考虑去掉重复值按 Species 分组，对 Sepal.Length 降序排列，取 Top 3对 iris 各个列排序按 Species 分组，对 Sepal.Length 降序排列，取 Top 3对 iris 各个列排序，依次对第 5、1、2、3 列升序排列\n表 6.3: iris 数据集原顺序（左）和新顺序（右）\n","code":"\ndat[with(dat, order(-ave(num_a, group_a, FUN = max), -num_a)), ]##     num_a num_b group_a group_b\n##  1:     4     1       b       C\n##  2:     4     2       c       B\n##  3:     4     3       b       C\n##  4:     4     4       a       C\n##  5:     3     1       b       C\n##  6:     3     2       b       B\n##  7:     3     3       b       B\n##  8:     3     4       a       B\n##  9:     2     1       b       B\n## 10:     2     2       b       C\n## 11:     2     3       a       B\n## 12:     2     4       a       A\n## 13:     1     1       c       B\n## 14:     1     2       b       B\n## 15:     1     3       a       B\n## 16:     1     4       a       C\n# num_a 降序排列，然后对 group_a 升序排列\ndat[with(dat, order(-num_a, group_a)), ]##     num_a num_b group_a group_b\n##  1:     4     4       a       C\n##  2:     4     1       b       C\n##  3:     4     3       b       C\n##  4:     4     2       c       B\n##  5:     3     4       a       B\n##  6:     3     1       b       C\n##  7:     3     2       b       B\n##  8:     3     3       b       B\n##  9:     2     3       a       B\n## 10:     2     4       a       A\n## 11:     2     1       b       B\n## 12:     2     2       b       C\n## 13:     1     3       a       B\n## 14:     1     4       a       C\n## 15:     1     2       b       B\n## 16:     1     1       c       B\n# 简写\ndat[order(-num_a, group_a)]##     num_a num_b group_a group_b\n##  1:     4     4       a       C\n##  2:     4     1       b       C\n##  3:     4     3       b       C\n##  4:     4     2       c       B\n##  5:     3     4       a       B\n##  6:     3     1       b       C\n##  7:     3     2       b       B\n##  8:     3     3       b       B\n##  9:     2     3       a       B\n## 10:     2     4       a       A\n## 11:     2     1       b       B\n## 12:     2     2       b       C\n## 13:     1     3       a       B\n## 14:     1     4       a       C\n## 15:     1     2       b       B\n## 16:     1     1       c       B\nsetorder(dat, -num_a, group_a)\ndat[, .(length(!is.na(num_a))), by = .(group_a)]##    group_a V1\n## 1:       c  2\n## 2:       b  8\n## 3:       a  6\ndat[, .(length(unique(num_a))), by = .(group_a)]##    group_a V1\n## 1:       c  2\n## 2:       b  4\n## 3:       a  4\niris <- as.data.table(iris)\niris[order(-Sepal.Length), .SD[1:3], by = \"Species\"]##       Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 1:  virginica          7.9         3.8          6.4         2.0\n## 2:  virginica          7.7         3.8          6.7         2.2\n## 3:  virginica          7.7         2.6          6.9         2.3\n## 4: versicolor          7.0         3.2          4.7         1.4\n## 5: versicolor          6.9         3.1          4.9         1.5\n## 6: versicolor          6.8         2.8          4.8         1.4\n## 7:     setosa          5.8         4.0          1.2         0.2\n## 8:     setosa          5.7         4.4          1.5         0.4\n## 9:     setosa          5.7         3.8          1.7         0.3\ndat <- head(iris)\nind <- do.call(what = \"order\", args = dat[, c(5, 1, 2, 3)])\ndat[ind, ]##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1:          4.6         3.1          1.5         0.2  setosa\n## 2:          4.7         3.2          1.3         0.2  setosa\n## 3:          4.9         3.0          1.4         0.2  setosa\n## 4:          5.0         3.6          1.4         0.2  setosa\n## 5:          5.1         3.5          1.4         0.2  setosa\n## 6:          5.4         3.9          1.7         0.4  setosa\niris = as.data.table(iris)\niris[order(-Sepal.Length), .SD[1:3], by=\"Species\"]##       Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 1:  virginica          7.9         3.8          6.4         2.0\n## 2:  virginica          7.7         3.8          6.7         2.2\n## 3:  virginica          7.7         2.6          6.9         2.3\n## 4: versicolor          7.0         3.2          4.7         1.4\n## 5: versicolor          6.9         3.1          4.9         1.5\n## 6: versicolor          6.8         2.8          4.8         1.4\n## 7:     setosa          5.8         4.0          1.2         0.2\n## 8:     setosa          5.7         4.4          1.5         0.4\n## 9:     setosa          5.7         3.8          1.7         0.3\nind <- do.call(what = \"order\", args = iris[,c(5,1,2,3)])\nhead(iris[ind, ])##    Sepal.Length Sepal.Width Petal.Length Petal.Width Species\n## 1:          4.3         3.0          1.1         0.1  setosa\n## 2:          4.4         2.9          1.4         0.2  setosa\n## 3:          4.4         3.0          1.3         0.2  setosa\n## 4:          4.4         3.2          1.3         0.2  setosa\n## 5:          4.5         2.3          1.3         0.3  setosa\n## 6:          4.6         3.1          1.5         0.2  setosa"},{"path":"chap-advanced-manipulation.html","id":"chap-advanced-manipulation","chapter":"第 7 章 高级数据操作","heading":"第 7 章 高级数据操作","text":"介绍 data.table 处理数据的方式，对标 dplyr 的基本操作","code":"\nlibrary(data.table)"},{"path":"chap-advanced-manipulation.html","id":"intro","chapter":"第 7 章 高级数据操作","heading":"7.1 基础介绍","text":"","code":"\n# 用一个真实的数据集替换，让每一个操作都有实际含义和价值 mtcars\nDT <- data.table(\n  x = rep(c(\"b\", \"a\", \"c\"), each = 3),\n  v = c(1, 1, 1, 2, 2, 1, 1, 2, 2),\n  y = c(1, 3, 6), a = 1:9, b = 9:1\n)\nDT##    x v y a b\n## 1: b 1 1 1 9\n## 2: b 1 3 2 8\n## 3: b 1 6 3 7\n## 4: a 2 1 4 6\n## 5: a 2 3 5 5\n## 6: a 1 6 6 4\n## 7: c 1 1 7 3\n## 8: c 2 3 8 2\n## 9: c 2 6 9 1\n# 分组求和\nDT[, sum(v), by = .(y %% 2)]##    y V1\n## 1: 1  9\n## 2: 0  4\nDT[, sum(v), by = .(bool = y %% 2)]##    bool V1\n## 1:    1  9\n## 2:    0  4\nDT[, .SD[2], by = x] # 每组第二行##    x v y a b\n## 1: b 1 3 2 8\n## 2: a 2 3 5 5\n## 3: c 2 3 8 2\nDT[, tail(.SD, 2), by = x] # 每组最后两行##    x v y a b\n## 1: b 1 3 2 8\n## 2: b 1 6 3 7\n## 3: a 2 3 5 5\n## 4: a 1 6 6 4\n## 5: c 2 3 8 2\n## 6: c 2 6 9 1\n# 除了 x 列外，所有列都按 x 分组求和\nDT[, lapply(.SD, sum), by = x]##    x v  y  a  b\n## 1: b 3 10  6 24\n## 2: a 5 10 15 15\n## 3: c 5 10 24  6\n# 各个列都按 x 分组取最小\nDT[, .SD[which.min(v)], by = x] # 分组嵌套查询##    x v y a b\n## 1: b 1 1 1 9\n## 2: a 1 6 6 4\n## 3: c 1 1 7 3\nDT[, list(MySum = sum(v), MyMin = min(v), MyMax = max(v)), by = .(x, y %% 2)] # 表达式嵌套##    x y MySum MyMin MyMax\n## 1: b 1     2     1     1\n## 2: b 0     1     1     1\n## 3: a 1     4     2     2\n## 4: a 0     1     1     1\n## 5: c 1     3     1     2\n## 6: c 0     2     2     2\nDT[, .(a = .(a), b = .(b)), by = x] # 按 x 分组，将 a,b 两列的值列出来##    x     a     b\n## 1: b 1,2,3 9,8,7\n## 2: a 4,5,6 6,5,4\n## 3: c 7,8,9 3,2,1\nDT[, .(seq = min(a):max(b)), by = x] # 列操作不仅仅是聚合##     x seq\n##  1: b   1\n##  2: b   2\n##  3: b   3\n##  4: b   4\n##  5: b   5\n##  6: b   6\n##  7: b   7\n##  8: b   8\n##  9: b   9\n## 10: a   4\n## 11: a   5\n## 12: a   6\n## 13: c   7\n## 14: c   6\n## 15: c   5\n## 16: c   4\n## 17: c   3\n# 按 x 分组对 v 求和，然后过滤出和小于 20 的行\nDT[, sum(v), by = x][V1 < 20] # 组合查询##    x V1\n## 1: b  3\n## 2: a  5\n## 3: c  5\nDT[, sum(v), by = x][order(-V1)] # 对结果排序##    x V1\n## 1: a  5\n## 2: c  5\n## 3: b  3\nDT[, c(.N, lapply(.SD, sum)), by = x] # 计算每一组的和，每一组的观测数##    x N v  y  a  b\n## 1: b 3 3 10  6 24\n## 2: a 3 5 10 15 15\n## 3: c 3 5 10 24  6\n# 两个复杂的操作，还没弄清楚这个技术存在的意义\nDT[,\n  {\n    tmp <- mean(y)\n    .(a = a - tmp, b = b - tmp)\n  },\n  by = x\n] # anonymous lambda in 'j', j accepts any valid##    x          a          b\n## 1: b -2.3333333  5.6666667\n## 2: b -1.3333333  4.6666667\n## 3: b -0.3333333  3.6666667\n## 4: a  0.6666667  2.6666667\n## 5: a  1.6666667  1.6666667\n## 6: a  2.6666667  0.6666667\n## 7: c  3.6666667 -0.3333333\n## 8: c  4.6666667 -1.3333333\n## 9: c  5.6666667 -2.3333333\n# using rleid, get max(y) and min of all cols in .SDcols for each consecutive run of 'v'\nDT[, c(.(y = max(y)), lapply(.SD, min)), by = rleid(v), .SDcols = v:b]##    rleid y v y a b\n## 1:     1 6 1 1 1 7\n## 2:     2 3 2 1 4 5\n## 3:     3 6 1 1 6 3\n## 4:     4 6 2 3 8 1"},{"path":"chap-advanced-manipulation.html","id":"subsec-filter-i","chapter":"第 7 章 高级数据操作","heading":"7.1.1 过滤","text":"过滤 cyl = 6 并且 gear = 4 的记录过滤操作是针对数据框的行（记录）","code":"\nmtcars_df <- as.data.table(mtcars)\nmtcars_df[cyl == 6 & gear == 4]##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## 3: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## 4: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nmtcars_df[cyl == 6 & gear == 4, .(mpg, disp)]##     mpg  disp\n## 1: 21.0 160.0\n## 2: 21.0 160.0\n## 3: 19.2 167.6\n## 4: 17.8 167.6\nsubset(x = mtcars_df, subset = cyl == 6 & gear == 4, select = c(mpg, disp))##     mpg  disp\n## 1: 21.0 160.0\n## 2: 21.0 160.0\n## 3: 19.2 167.6\n## 4: 17.8 167.6\nmtcars |> \n  dplyr::filter(cyl == 6 & gear == 4) |> \n  dplyr::select(mpg, disp)##                mpg  disp\n## Mazda RX4     21.0 160.0\n## Mazda RX4 Wag 21.0 160.0\n## Merc 280      19.2 167.6\n## Merc 280C     17.8 167.6"},{"path":"chap-advanced-manipulation.html","id":"subsec-mutate-j","chapter":"第 7 章 高级数据操作","heading":"7.1.2 变换","text":"根据已有的列生成新的列，或者修改已有的列，一次只能修改一列","code":"\nmtcars_df[, mean_mpg := mean(mpg)][, mean_disp := mean(disp)]\nmtcars_df[1:6, ]##     mpg cyl disp  hp drat    wt  qsec vs am gear carb mean_mpg mean_disp\n## 1: 21.0   6  160 110 3.90 2.620 16.46  0  1    4    4 20.09062  230.7219\n## 2: 21.0   6  160 110 3.90 2.875 17.02  0  1    4    4 20.09062  230.7219\n## 3: 22.8   4  108  93 3.85 2.320 18.61  1  1    4    1 20.09062  230.7219\n## 4: 21.4   6  258 110 3.08 3.215 19.44  1  0    3    1 20.09062  230.7219\n## 5: 18.7   8  360 175 3.15 3.440 17.02  0  0    3    2 20.09062  230.7219\n## 6: 18.1   6  225 105 2.76 3.460 20.22  1  0    3    1 20.09062  230.7219\nmtcars_df[, .(mean_mpg = mean(mpg), mean_disp = mean(disp))]##    mean_mpg mean_disp\n## 1: 20.09062  230.7219\n# mtcars_df[, .(mean_mpg := mean(mpg), mean_disp := mean(disp))] # 报错\n# 正确的姿势\nmtcars_df[, `:=`(mean_mpg = mean(mpg), mean_disp = mean(disp))][, .(mpg, disp, mean_mpg, mean_disp)] |>  head()##     mpg disp mean_mpg mean_disp\n## 1: 21.0  160 20.09062  230.7219\n## 2: 21.0  160 20.09062  230.7219\n## 3: 22.8  108 20.09062  230.7219\n## 4: 21.4  258 20.09062  230.7219\n## 5: 18.7  360 20.09062  230.7219\n## 6: 18.1  225 20.09062  230.7219\nmtcars |> \n  dplyr::summarise(mean_mpg = mean(mpg), mean_disp = mean(disp))##   mean_mpg mean_disp\n## 1 20.09062  230.7219\nmtcars |> \n  dplyr::mutate(mean_mpg = mean(mpg), mean_disp = mean(disp)) |> \n  dplyr::select(mpg, disp, mean_mpg, mean_disp) |> \n  head()##                    mpg disp mean_mpg mean_disp\n## Mazda RX4         21.0  160 20.09062  230.7219\n## Mazda RX4 Wag     21.0  160 20.09062  230.7219\n## Datsun 710        22.8  108 20.09062  230.7219\n## Hornet 4 Drive    21.4  258 20.09062  230.7219\n## Hornet Sportabout 18.7  360 20.09062  230.7219\n## Valiant           18.1  225 20.09062  230.7219"},{"path":"chap-advanced-manipulation.html","id":"subsec-summarise-j","chapter":"第 7 章 高级数据操作","heading":"7.1.3 聚合","text":"分组统计 多个分组变量","code":"\ndcast(mtcars_df, cyl ~ gear, value.var = \"mpg\", fun = mean)##    cyl     3      4    5\n## 1:   4 21.50 26.925 28.2\n## 2:   6 19.75 19.750 19.7\n## 3:   8 15.05    NaN 15.4\ntapply(mtcars$mpg, list(mtcars$cyl, mtcars$gear), mean)##       3      4    5\n## 4 21.50 26.925 28.2\n## 6 19.75 19.750 19.7\n## 8 15.05     NA 15.4\nmtcars_df[, .(mean_mpg = mean(mpg)), by = .(cyl, gear)]##    cyl gear mean_mpg\n## 1:   6    4   19.750\n## 2:   4    4   26.925\n## 3:   6    3   19.750\n## 4:   8    3   15.050\n## 5:   4    3   21.500\n## 6:   4    5   28.200\n## 7:   8    5   15.400\n## 8:   6    5   19.700\naggregate(data = mtcars_df, mpg ~ cyl + gear, FUN = mean)##   cyl gear    mpg\n## 1   4    3 21.500\n## 2   6    3 19.750\n## 3   8    3 15.050\n## 4   4    4 26.925\n## 5   6    4 19.750\n## 6   4    5 28.200\n## 7   6    5 19.700\n## 8   8    5 15.400\nmtcars |> \n  dplyr::group_by(cyl, gear) |> \n  dplyr::summarise(mean_mpg = mean(mpg))## # A tibble: 8 × 3\n## # Groups:   cyl [3]\n##     cyl  gear mean_mpg\n##   <dbl> <dbl>    <dbl>\n## 1     4     3     21.5\n## 2     4     4     26.9\n## 3     4     5     28.2\n## 4     6     3     19.8\n## 5     6     4     19.8\n## 6     6     5     19.7\n## 7     8     3     15.0\n## 8     8     5     15.4"},{"path":"chap-advanced-manipulation.html","id":"subsec-setname","chapter":"第 7 章 高级数据操作","heading":"7.1.4 命名","text":"修改列名，另存一份生效修改列名并直接起作用，在原来的数据集上生效修改列名最好使用 data.table 包的函数 setnames() 明确指出了要修改的列名，","code":"\nsub_mtcars_df <- mtcars_df[, .(mean_mpg = mean(mpg)), by = .(cyl, gear)]\nsetNames(sub_mtcars_df, c(\"cyl\", \"gear\", \"ave_mpg\"))##    cyl gear ave_mpg\n## 1:   6    4  19.750\n## 2:   4    4  26.925\n## 3:   6    3  19.750\n## 4:   8    3  15.050\n## 5:   4    3  21.500\n## 6:   4    5  28.200\n## 7:   8    5  15.400\n## 8:   6    5  19.700\n# 注意 sub_mtcars_df 并没有修改列名\nsub_mtcars_df##    cyl gear mean_mpg\n## 1:   6    4   19.750\n## 2:   4    4   26.925\n## 3:   6    3   19.750\n## 4:   8    3   15.050\n## 5:   4    3   21.500\n## 6:   4    5   28.200\n## 7:   8    5   15.400\n## 8:   6    5   19.700\nsetnames(sub_mtcars_df, old = c(\"mean_mpg\"), new = c(\"ave_mpg\"))\n# sub_mtcars_df 已经修改了列名\nsub_mtcars_df##    cyl gear ave_mpg\n## 1:   6    4  19.750\n## 2:   4    4  26.925\n## 3:   6    3  19.750\n## 4:   8    3  15.050\n## 5:   4    3  21.500\n## 6:   4    5  28.200\n## 7:   8    5  15.400\n## 8:   6    5  19.700"},{"path":"chap-advanced-manipulation.html","id":"subsec-order-by-j","chapter":"第 7 章 高级数据操作","heading":"7.1.5 排序","text":"按照某（些）列从大到小或从小到大的顺序排列， 先按 cyl 升序，然后按 gear 降序","code":"\nmtcars_df[, .(mpg, cyl, gear)][cyl == 4][order(cyl, -gear)]##      mpg cyl gear\n##  1: 26.0   4    5\n##  2: 30.4   4    5\n##  3: 22.8   4    4\n##  4: 24.4   4    4\n##  5: 22.8   4    4\n##  6: 32.4   4    4\n##  7: 30.4   4    4\n##  8: 33.9   4    4\n##  9: 27.3   4    4\n## 10: 21.4   4    4\n## 11: 21.5   4    3\nmtcars |> \n  dplyr::select(mpg, cyl, gear) |> \n  dplyr::filter(cyl == 4) |> \n  dplyr::arrange(cyl, desc(gear))##                 mpg cyl gear\n## Porsche 914-2  26.0   4    5\n## Lotus Europa   30.4   4    5\n## Datsun 710     22.8   4    4\n## Merc 240D      24.4   4    4\n## Merc 230       22.8   4    4\n## Fiat 128       32.4   4    4\n## Honda Civic    30.4   4    4\n## Toyota Corolla 33.9   4    4\n## Fiat X1-9      27.3   4    4\n## Volvo 142E     21.4   4    4\n## Toyota Corona  21.5   4    3"},{"path":"chap-advanced-manipulation.html","id":"subsec-reshape","chapter":"第 7 章 高级数据操作","heading":"7.1.6 变形","text":"melt 宽的变长的dcast 长的变宽的tidyr 包提供数据变形的函数 tidyr::pivot_longer() 和 tidyr::pivot_wider() 相比于 Base R 提供的 reshape() 和 data.table 提供的 melt() 和 dcast() 更加形象的命名idvar 分组变量timevar 组内编号v.names 个体观察值sep 新的列名是由参数 v.names (extra) 和参数值 timevar (ID) 拼接起来的，默认 sep = \".\" 推荐使用下划线来做分割 sep = \"_\"以数据集 ToothGrowth 为例，变量 supp（大组），dose（小组） 和 time（组内个体编号） 一起决定唯一的一个数据 len，特别适合纵向数据的变形操作","code":"\nDT <- data.table(\n  i_1 = c(1:5, NA),\n  i_2 = c(NA, 6, 7, 8, 9, 10),\n  f_1 = factor(sample(c(letters[1:3], NA), 6, TRUE)),\n  f_2 = factor(c(\"z\", \"a\", \"x\", \"c\", \"x\", \"x\"), ordered = TRUE),\n  c_1 = sample(c(letters[1:3], NA), 6, TRUE),\n  d_1 = as.Date(c(1:3, NA, 4:5), origin = \"2013-09-01\"),\n  d_2 = as.Date(6:1, origin = \"2012-01-01\")\n)\nDT[, .(i_1, i_2, f_1, f_2)]##    i_1 i_2  f_1 f_2\n## 1:   1  NA    c   z\n## 2:   2   6 <NA>   a\n## 3:   3   7 <NA>   x\n## 4:   4   8    a   c\n## 5:   5   9 <NA>   x\n## 6:  NA  10    b   x\nmelt(DT, id = 1:2, measure = c(\"f_1\", \"f_2\"))##     i_1 i_2 variable value\n##  1:   1  NA      f_1     c\n##  2:   2   6      f_1  <NA>\n##  3:   3   7      f_1  <NA>\n##  4:   4   8      f_1     a\n##  5:   5   9      f_1  <NA>\n##  6:  NA  10      f_1     b\n##  7:   1  NA      f_2     z\n##  8:   2   6      f_2     a\n##  9:   3   7      f_2     x\n## 10:   4   8      f_2     c\n## 11:   5   9      f_2     x\n## 12:  NA  10      f_2     x\nsleep <- as.data.table(sleep)\ndcast(sleep, group ~ ID, value.var = \"extra\")##    group   1    2    3    4    5   6   7   8   9  10\n## 1:     1 0.7 -1.6 -0.2 -1.2 -0.1 3.4 3.7 0.8 0.0 2.0\n## 2:     2 1.9  0.8  1.1  0.1 -0.1 4.4 5.5 1.6 4.6 3.4\n# 如果有多个值\ndcast(mtcars_df, cyl ~ gear, value.var = \"mpg\")##    cyl  3 4 5\n## 1:   4  1 8 2\n## 2:   6  2 4 1\n## 3:   8 12 0 2\ndcast(mtcars_df, cyl ~ gear, value.var = \"mpg\", fun = mean)##    cyl     3      4    5\n## 1:   4 21.50 26.925 28.2\n## 2:   6 19.75 19.750 19.7\n## 3:   8 15.05    NaN 15.4\ntidyr::pivot_wider(data = sleep, names_from = \"ID\", values_from = \"extra\")## # A tibble: 2 × 11\n##   group   `1`   `2`   `3`   `4`   `5`   `6`   `7`   `8`   `9`  `10`\n##   <fct> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n## 1 1       0.7  -1.6  -0.2  -1.2  -0.1   3.4   3.7   0.8   0     2  \n## 2 2       1.9   0.8   1.1   0.1  -0.1   4.4   5.5   1.6   4.6   3.4\nreshape(data = sleep, v.names = \"extra\", idvar = \"group\", timevar = \"ID\", direction = \"wide\")##    group extra.1 extra.2 extra.3 extra.4 extra.5 extra.6 extra.7 extra.8\n## 1:     1     0.7    -1.6    -0.2    -1.2    -0.1     3.4     3.7     0.8\n## 2:     2     1.9     0.8     1.1     0.1    -0.1     4.4     5.5     1.6\n##    extra.9 extra.10\n## 1:     0.0      2.0\n## 2:     4.6      3.4\nhead(ToothGrowth)##    len supp dose\n## 1  4.2   VC  0.5\n## 2 11.5   VC  0.5\n## 3  7.3   VC  0.5\n## 4  5.8   VC  0.5\n## 5  6.4   VC  0.5\n## 6 10.0   VC  0.5\nToothGrowth$time <- rep(1:10, 6)\nreshape(ToothGrowth,\n  v.names = \"len\", idvar = c(\"supp\", \"dose\"),\n  timevar = \"time\", direction = \"wide\"\n)##    supp dose len.1 len.2 len.3 len.4 len.5 len.6 len.7 len.8 len.9 len.10\n## 1    VC  0.5   4.2  11.5   7.3   5.8   6.4  10.0  11.2  11.2   5.2    7.0\n## 11   VC  1.0  16.5  16.5  15.2  17.3  22.5  17.3  13.6  14.5  18.8   15.5\n## 21   VC  2.0  23.6  18.5  33.9  25.5  26.4  32.5  26.7  21.5  23.3   29.5\n## 31   OJ  0.5  15.2  21.5  17.6   9.7  14.5  10.0   8.2   9.4  16.5    9.7\n## 41   OJ  1.0  19.7  23.3  23.6  26.4  20.0  25.2  25.8  21.2  14.5   27.3\n## 51   OJ  2.0  25.5  26.4  22.4  24.5  24.8  30.9  26.4  27.3  29.4   23.0"},{"path":"chap-advanced-manipulation.html","id":"subsec-group-by","chapter":"第 7 章 高级数据操作","heading":"7.1.7 分组","text":"分组切片，取每组第一个和最后一个值dplyr::slice() 和函数 slice.index() 有关系吗？","code":"\nLoblolly |> \n  dplyr::group_by(Seed) |> \n  dplyr::arrange(height, age, Seed) |> \n  dplyr::slice(1, dplyr::n())## # A tibble: 28 × 3\n## # Groups:   Seed [14]\n##    height   age Seed \n##     <dbl> <dbl> <ord>\n##  1   3.93     3 329  \n##  2  56.4     25 329  \n##  3   4.12     3 327  \n##  4  56.8     25 327  \n##  5   4.38     3 325  \n##  6  58.5     25 325  \n##  7   3.91     3 307  \n##  8  59.1     25 307  \n##  9   3.46     3 331  \n## 10  59.5     25 331  \n## # … with 18 more rows"},{"path":"chap-advanced-manipulation.html","id":"subsec-merge","chapter":"第 7 章 高级数据操作","heading":"7.1.8 合并","text":"合并操作对应于数据库中的连接操作， dplyr 包的哲学就来源于对数据库操作的进一步抽象， data.table 包的 merge 函数就对应为 dplyr 包的 join 函数data.table::merge 和 dplyr::join给出一个表格，数据操作， data.table 实现， dplyr 实现参数 key 的作用相当于建立一个索引，通过它实现更快的数据操作速度key = c(\"x\",\"y\",\"z\") 或者 key = \"x,y,z\" 其中 x,y,z 是列名list 列表里每个元素都是 data.frame 时，最适合用 data.table::rbindlist 合并","code":"\ndt1 <- data.table(A = letters[1:10], X = 1:10, key = \"A\")\ndt2 <- data.table(A = letters[5:14], Y = 1:10, key = \"A\")\nmerge(dt1, dt2) # 内连接##    A  X Y\n## 1: e  5 1\n## 2: f  6 2\n## 3: g  7 3\n## 4: h  8 4\n## 5: i  9 5\n## 6: j 10 6\ndata(band_members, band_instruments, package = \"dplyr\")\nband_members## # A tibble: 3 × 2\n##   name  band   \n##   <chr> <chr>  \n## 1 Mick  Stones \n## 2 John  Beatles\n## 3 Paul  Beatles\nband_instruments## # A tibble: 3 × 2\n##   name  plays \n##   <chr> <chr> \n## 1 John  guitar\n## 2 Paul  bass  \n## 3 Keith guitar\ndplyr::inner_join(band_members, band_instruments)## # A tibble: 2 × 3\n##   name  band    plays \n##   <chr> <chr>   <chr> \n## 1 John  Beatles guitar\n## 2 Paul  Beatles bass\n# 合并列表 https://recology.info/2018/10/limiting-dependencies/\nfunction(x) {\n  tibble::as_tibble((x <- data.table::setDF(\n    data.table::rbindlist(x, use.names = TRUE, fill = TRUE, idcol = \"id\")\n  )\n  ))\n}## function(x) {\n##   tibble::as_tibble((x <- data.table::setDF(\n##     data.table::rbindlist(x, use.names = TRUE, fill = TRUE, idcol = \"id\")\n##   )\n##   ))\n## }"},{"path":"chap-advanced-manipulation.html","id":"chap:data-manipulation","chapter":"第 7 章 高级数据操作","heading":"7.2 高频操作","text":"以面向问题的方式介绍 Base R 提供的数据操作，然后过渡到 data.table，它是加强版的 Base R。表 7.1:  单表的操作表 7.2:  两表的操作","code":"\nclass(mtcars)## [1] \"data.frame\"\nlibrary(data.table)\nmtcars <- as.data.table(mtcars)\nclass(mtcars)## [1] \"data.table\" \"data.frame\""},{"path":"chap-advanced-manipulation.html","id":"sec-select","chapter":"第 7 章 高级数据操作","heading":"7.2.1 选择多列","text":"反选多列，选择除了 cyl 和 gear 的列","code":"\n# base\nmtcars[, c(\"cyl\", \"gear\")] |>  head(3)##    cyl gear\n## 1:   6    4\n## 2:   6    4\n## 3:   4    4\n# data.table\nmtcars[, c(\"cyl\", \"gear\")] |>  head(3)##    cyl gear\n## 1:   6    4\n## 2:   6    4\n## 3:   4    4\n# dplyr\ndplyr::select(mtcars, cyl, gear) |>  head(3)##    cyl gear\n## 1:   6    4\n## 2:   6    4\n## 3:   4    4\n## 或者 mtcars[, setdiff(names(mtcars), c(\"cyl\", \"gear\"))]\nmtcars[, !(names(mtcars) %in% c(\"cyl\", \"gear\"))] |>  head(3)## [1]  TRUE FALSE  TRUE\nsubset(mtcars, select = -c(cyl, gear)) |>  head(3)##     mpg disp  hp drat    wt  qsec vs am carb\n## 1: 21.0  160 110 3.90 2.620 16.46  0  1    4\n## 2: 21.0  160 110 3.90 2.875 17.02  0  1    4\n## 3: 22.8  108  93 3.85 2.320 18.61  1  1    1"},{"path":"chap-advanced-manipulation.html","id":"sec-filter","chapter":"第 7 章 高级数据操作","heading":"7.2.2 过滤多行","text":"","code":"\n# base\nmtcars[mtcars$cyl == 6 & mtcars$gear == 4, ]##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## 3: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## 4: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nsubset(mtcars, subset = cyl == 6 & gear == 4)##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## 3: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## 4: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n# data.table\nmtcars[cyl == 6 & gear == 4, ]##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## 3: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## 4: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\n# dplyr\ndplyr::filter(mtcars, cyl == 6 & gear == 4)##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\n## 3: 19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\n## 4: 17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4"},{"path":"chap-advanced-manipulation.html","id":"sec-duplicated","chapter":"第 7 章 高级数据操作","heading":"7.2.3 去重多行","text":"","code":"\n# base\nmtcars[!duplicated(mtcars[, c(\"cyl\", \"gear\")])]##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n## 3: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n## 4: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n## 5: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n## 6: 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n## 7: 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n## 8: 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n# data.table\nmtcars[!duplicated(mtcars, by = c(\"cyl\", \"gear\")), ]##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n## 3: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n## 4: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n## 5: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n## 6: 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n## 7: 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n## 8: 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nunique(mtcars, by = c(\"cyl\", \"gear\"))##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n## 3: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n## 4: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n## 5: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n## 6: 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n## 7: 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n## 8: 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\n# dplyr\ndplyr::distinct(mtcars, cyl, gear, .keep_all = TRUE)##     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n## 1: 21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\n## 2: 22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n## 3: 21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\n## 4: 18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\n## 5: 21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\n## 6: 26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\n## 7: 15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\n## 8: 19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6"},{"path":"chap-advanced-manipulation.html","id":"sec-merge","chapter":"第 7 章 高级数据操作","heading":"7.2.4 合并操作","text":"在数据库的操作中，合并又称为连接","code":""},{"path":"chap-advanced-manipulation.html","id":"subsec-left-join","chapter":"第 7 章 高级数据操作","heading":"7.2.4.1 左合并","text":"","code":"\n# dplyr::inner_join()\n# dplyr::left_join()\n# dplyr::right_join()\n# dplyr::full_join()"},{"path":"chap-advanced-manipulation.html","id":"subsec-right-join","chapter":"第 7 章 高级数据操作","heading":"7.2.4.2 右合并","text":"","code":""},{"path":"chap-advanced-manipulation.html","id":"sec-add-columns","chapter":"第 7 章 高级数据操作","heading":"7.2.5 新添多列","text":"","code":"\nmtcars[cyl == 6, `:=`(disp_mean = mean(disp), hp_mean = mean(hp))][cyl == 6, .(cyl, disp, hp, disp_mean, hp_mean)]##    cyl  disp  hp disp_mean  hp_mean\n## 1:   6 160.0 110  183.3143 122.2857\n## 2:   6 160.0 110  183.3143 122.2857\n## 3:   6 258.0 110  183.3143 122.2857\n## 4:   6 225.0 105  183.3143 122.2857\n## 5:   6 167.6 123  183.3143 122.2857\n## 6:   6 167.6 123  183.3143 122.2857\n## 7:   6 145.0 175  183.3143 122.2857"},{"path":"chap-advanced-manipulation.html","id":"sec-delete-columns","chapter":"第 7 章 高级数据操作","heading":"7.2.6 删除多列","text":"删除列就是将该列的值清空，置为 NULL，下面将新添的两个列删除，根据列名的特点用正则表达式匹配","code":"\nmtcars[, colnames(mtcars)[grep(\"_mean$\", colnames(mtcars))] := NULL]"},{"path":"chap-advanced-manipulation.html","id":"sec-select-columns","chapter":"第 7 章 高级数据操作","heading":"7.2.7 筛选多列","text":"按照某一规则筛选多列","code":"\nlibrary(data.table)\niris <- as.data.table(iris)\niris[, head(.SD, 6), .SDcols = function(x) is.numeric(x)]##    Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 1:          5.1         3.5          1.4         0.2\n## 2:          4.9         3.0          1.4         0.2\n## 3:          4.7         3.2          1.3         0.2\n## 4:          4.6         3.1          1.5         0.2\n## 5:          5.0         3.6          1.4         0.2\n## 6:          5.4         3.9          1.7         0.4"},{"path":"chap-advanced-manipulation.html","id":"sec-modify-columns-type","chapter":"第 7 章 高级数据操作","heading":"7.2.8 修改多列类型","text":"","code":"\nmtcars[, (c(\"cyl\", \"disp\")) := lapply(.SD, as.integer), .SDcols = c(\"cyl\", \"disp\")]\nstr(mtcars)## Classes 'data.table' and 'data.frame':   32 obs. of  11 variables:\n##  $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n##  $ cyl : int  6 6 4 6 8 6 8 4 4 6 ...\n##  $ disp: int  160 160 108 258 360 225 360 146 140 167 ...\n##  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n##  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n##  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n##  $ qsec: num  16.5 17 18.6 19.4 17 ...\n##  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n##  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n##  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n##  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n##  - attr(*, \".internal.selfref\")=<externalptr> \n##  - attr(*, \"index\")= int(0)"},{"path":"chap-advanced-manipulation.html","id":"sec-select-first-row","chapter":"第 7 章 高级数据操作","heading":"7.2.9 取每组第一行","text":"先将 mtcars 按 cyl 升序，gear 降序排列，然后按 cyl, gear 和 分组取第一行","code":"\nmtcars[order(cyl, -gear)][, head(.SD, 1), by = list(cyl, gear, am)]##     cyl gear am  mpg disp  hp drat    wt  qsec vs carb\n##  1:   4    5  1 26.0  120  91 4.43 2.140 16.70  0    2\n##  2:   4    4  1 22.8  108  93 3.85 2.320 18.61  1    1\n##  3:   4    4  0 24.4  146  62 3.69 3.190 20.00  1    2\n##  4:   4    3  0 21.5  120  97 3.70 2.465 20.01  1    1\n##  5:   6    5  1 19.7  145 175 3.62 2.770 15.50  0    6\n##  6:   6    4  1 21.0  160 110 3.90 2.620 16.46  0    4\n##  7:   6    4  0 19.2  167 123 3.92 3.440 18.30  1    4\n##  8:   6    3  0 21.4  258 110 3.08 3.215 19.44  1    1\n##  9:   8    5  1 15.8  351 264 4.22 3.170 14.50  0    4\n## 10:   8    3  0 18.7  360 175 3.15 3.440 17.02  0    2\n# 或者\nmtcars[order(cyl, -gear)][, .SD[1], by = list(cyl, gear, am)]##     cyl gear am  mpg disp  hp drat    wt  qsec vs carb\n##  1:   4    5  1 26.0  120  91 4.43 2.140 16.70  0    2\n##  2:   4    4  1 22.8  108  93 3.85 2.320 18.61  1    1\n##  3:   4    4  0 24.4  146  62 3.69 3.190 20.00  1    2\n##  4:   4    3  0 21.5  120  97 3.70 2.465 20.01  1    1\n##  5:   6    5  1 19.7  145 175 3.62 2.770 15.50  0    6\n##  6:   6    4  1 21.0  160 110 3.90 2.620 16.46  0    4\n##  7:   6    4  0 19.2  167 123 3.92 3.440 18.30  1    4\n##  8:   6    3  0 21.4  258 110 3.08 3.215 19.44  1    1\n##  9:   8    5  1 15.8  351 264 4.22 3.170 14.50  0    4\n## 10:   8    3  0 18.7  360 175 3.15 3.440 17.02  0    2"},{"path":"chap-advanced-manipulation.html","id":"subsec-mom-vs-yoy","chapter":"第 7 章 高级数据操作","heading":"7.2.10 计算环比同比","text":"以数据集 AirPassengers 为例，重新整理后见表 7.3表 7.3: 1949-1960年国际航班乘客数量变化横向计算环比，如1949年2月相比1月增长多少、3月相比2月增长多少，以此类推，就是计算环比？纵向计算同比，如1950年1月相比1949年1月增长多少、1951年相比1950年1月增长多少？","code":"\nlibrary(magrittr)\ndat <- data.frame(\n  year = rep(1949:1960, each = 12),\n  month = month.abb, num = AirPassengers\n) %>%\n  reshape(.,\n    v.names = \"num\", idvar = \"year\", timevar = \"month\",\n    direction = \"wide\", sep = \"\"\n  ) %>%\n  setNames(., gsub(pattern = \"(num)\", replacement = \"\", x = colnames(.)))\n\nrownames(dat) <- subset(dat, select = year, drop = TRUE)\nair_passengers <- subset(dat, select = -year)\n\nknitr::kable(air_passengers,\n  caption = \"1949-1960年国际航班乘客数量变化\",\n  align = \"c\", row.names = TRUE\n)\n# 环比横向/同比纵向\nmom <- function(x) diff(x, lag = 1) / x[-length(x)] # month to month\n# 格式化输出\nformat_mom <- function(x) formatC(mom(x), format = \"f\", digits = 4)\nlibrary(formattable)\n# 同比变化\nair_passengers %>%\n  apply(., 2, format_mom) %>%\n  as.data.frame() %>%\n  formattable(., list(\n    Jan = color_tile(\"white\", \"pink\"),\n    Feb = color_tile(\"white\", \"springgreen4\"),\n    Mar = percent\n  ))\n\nlibrary(DT)\ndatatable(air_passengers)"},{"path":"chap-advanced-manipulation.html","id":"sec-merge-multi-dfs","chapter":"第 7 章 高级数据操作","heading":"7.2.11 合并多个数据框","text":"将所有列都保留，以 full_join() 方式合并合并完应该有30行，为啥只有24行？这是因为 merge() 函数对主键 key 相同的记录会合并，要想不合并，需要调用 rbindlist() 函数 https://d.cosx.org/d/421235rbind() 列数相同的两个 data.frame 按行合并，cbind() 行数相同的两个 data.frame 按列合并，merge() 对行、列数没有要求","code":"\ndf1 <- iris[1:10, c(1, 5)]\ndf2 <- iris[11:15, c(1, 2, 5)]\ndf3 <- iris[16:30, c(1, 3, 5)]\nall_dfs <- list(df1, df2, df3)\n# base\nReduce(function(x, y, ...) merge(x, y, ..., all = TRUE), all_dfs)##     Sepal.Length Species Sepal.Width Petal.Length\n##  1:          4.3  setosa         3.0           NA\n##  2:          4.4  setosa          NA           NA\n##  3:          4.6  setosa          NA          1.0\n##  4:          4.6  setosa          NA          1.0\n##  5:          4.7  setosa          NA          1.6\n##  6:          4.8  setosa         3.4          1.9\n##  7:          4.8  setosa         3.0          1.9\n##  8:          4.9  setosa          NA           NA\n##  9:          4.9  setosa          NA           NA\n## 10:          5.0  setosa          NA          1.6\n## 11:          5.0  setosa          NA          1.6\n## 12:          5.0  setosa          NA          1.6\n## 13:          5.0  setosa          NA          1.6\n## 14:          5.1  setosa          NA          1.4\n## 15:          5.1  setosa          NA          1.5\n## 16:          5.1  setosa          NA          1.5\n## 17:          5.1  setosa          NA          1.7\n## 18:          5.2  setosa          NA          1.5\n## 19:          5.2  setosa          NA          1.4\n## 20:          5.4  setosa         3.7          1.3\n## 21:          5.4  setosa         3.7          1.7\n## 22:          5.7  setosa          NA          1.5\n## 23:          5.7  setosa          NA          1.7\n## 24:          5.8  setosa         4.0           NA\n##     Sepal.Length Species Sepal.Width Petal.Length\n# dplyr\nReduce(function(x, y, ...) dplyr::full_join(x, y, ...), all_dfs)##     Sepal.Length Species Sepal.Width Petal.Length\n##  1:          5.1  setosa          NA          1.4\n##  2:          5.1  setosa          NA          1.5\n##  3:          5.1  setosa          NA          1.5\n##  4:          5.1  setosa          NA          1.7\n##  5:          4.9  setosa          NA           NA\n##  6:          4.7  setosa          NA          1.6\n##  7:          4.6  setosa          NA          1.0\n##  8:          5.0  setosa          NA          1.6\n##  9:          5.0  setosa          NA          1.6\n## 10:          5.4  setosa         3.7          1.3\n## 11:          5.4  setosa         3.7          1.7\n## 12:          4.6  setosa          NA          1.0\n## 13:          5.0  setosa          NA          1.6\n## 14:          5.0  setosa          NA          1.6\n## 15:          4.4  setosa          NA           NA\n## 16:          4.9  setosa          NA           NA\n## 17:          4.8  setosa         3.4          1.9\n## 18:          4.8  setosa         3.0          1.9\n## 19:          4.3  setosa         3.0           NA\n## 20:          5.8  setosa         4.0           NA\n## 21:          5.7  setosa          NA          1.5\n## 22:          5.7  setosa          NA          1.7\n## 23:          5.2  setosa          NA          1.5\n## 24:          5.2  setosa          NA          1.4\n##     Sepal.Length Species Sepal.Width Petal.Length\nrbindlist(all_dfs, fill = TRUE)##     Sepal.Length Species Sepal.Width Petal.Length\n##  1:          5.1  setosa          NA           NA\n##  2:          4.9  setosa          NA           NA\n##  3:          4.7  setosa          NA           NA\n##  4:          4.6  setosa          NA           NA\n##  5:          5.0  setosa          NA           NA\n##  6:          5.4  setosa          NA           NA\n##  7:          4.6  setosa          NA           NA\n##  8:          5.0  setosa          NA           NA\n##  9:          4.4  setosa          NA           NA\n## 10:          4.9  setosa          NA           NA\n## 11:          5.4  setosa         3.7           NA\n## 12:          4.8  setosa         3.4           NA\n## 13:          4.8  setosa         3.0           NA\n## 14:          4.3  setosa         3.0           NA\n## 15:          5.8  setosa         4.0           NA\n## 16:          5.7  setosa          NA          1.5\n## 17:          5.4  setosa          NA          1.3\n## 18:          5.1  setosa          NA          1.4\n## 19:          5.7  setosa          NA          1.7\n## 20:          5.1  setosa          NA          1.5\n## 21:          5.4  setosa          NA          1.7\n## 22:          5.1  setosa          NA          1.5\n## 23:          4.6  setosa          NA          1.0\n## 24:          5.1  setosa          NA          1.7\n## 25:          4.8  setosa          NA          1.9\n## 26:          5.0  setosa          NA          1.6\n## 27:          5.0  setosa          NA          1.6\n## 28:          5.2  setosa          NA          1.5\n## 29:          5.2  setosa          NA          1.4\n## 30:          4.7  setosa          NA          1.6\n##     Sepal.Length Species Sepal.Width Petal.Length\n# dplyr\ndplyr::bind_rows(all_dfs)##     Sepal.Length Species Sepal.Width Petal.Length\n##  1:          5.1  setosa          NA           NA\n##  2:          4.9  setosa          NA           NA\n##  3:          4.7  setosa          NA           NA\n##  4:          4.6  setosa          NA           NA\n##  5:          5.0  setosa          NA           NA\n##  6:          5.4  setosa          NA           NA\n##  7:          4.6  setosa          NA           NA\n##  8:          5.0  setosa          NA           NA\n##  9:          4.4  setosa          NA           NA\n## 10:          4.9  setosa          NA           NA\n## 11:          5.4  setosa         3.7           NA\n## 12:          4.8  setosa         3.4           NA\n## 13:          4.8  setosa         3.0           NA\n## 14:          4.3  setosa         3.0           NA\n## 15:          5.8  setosa         4.0           NA\n## 16:          5.7  setosa          NA          1.5\n## 17:          5.4  setosa          NA          1.3\n## 18:          5.1  setosa          NA          1.4\n## 19:          5.7  setosa          NA          1.7\n## 20:          5.1  setosa          NA          1.5\n## 21:          5.4  setosa          NA          1.7\n## 22:          5.1  setosa          NA          1.5\n## 23:          4.6  setosa          NA          1.0\n## 24:          5.1  setosa          NA          1.7\n## 25:          4.8  setosa          NA          1.9\n## 26:          5.0  setosa          NA          1.6\n## 27:          5.0  setosa          NA          1.6\n## 28:          5.2  setosa          NA          1.5\n## 29:          5.2  setosa          NA          1.4\n## 30:          4.7  setosa          NA          1.6\n##     Sepal.Length Species Sepal.Width Petal.Length"},{"path":"chap-advanced-manipulation.html","id":"sec-multiple-aggregations","chapter":"第 7 章 高级数据操作","heading":"7.2.12 分组聚合多个指标","text":"https://stackoverflow.com/questions/24151602/calculate-multiple-aggregations--lapply-sd","code":"\n# base\naggregate(\n  data = mtcars, cbind(mpg, hp) ~ cyl,\n  FUN = function(x) c(mean = mean(x), median = median(x))\n)##   cyl mpg.mean mpg.median   hp.mean hp.median\n## 1   4 26.66364   26.00000  82.63636  91.00000\n## 2   6 19.74286   19.70000 122.28571 110.00000\n## 3   8 15.10000   15.20000 209.21429 192.50000\n# 数据一致性 https://d.cosx.org/d/420763-base-r\nwith(\n  aggregate(cbind(mpg, hp) ~ cyl, mtcars,\n    FUN = function(x) c(mean = mean(x), median = median(x))\n  ),\n  cbind.data.frame(cyl, mpg, hp)\n)##   cyl     mean median      mean median\n## 1   4 26.66364   26.0  82.63636   91.0\n## 2   6 19.74286   19.7 122.28571  110.0\n## 3   8 15.10000   15.2 209.21429  192.5\n# data.table\nmtcars[, as.list(unlist(lapply(.SD, function(x) {\n  list(\n    mean = mean(x),\n    median = median(x)\n  )\n}))),\nby = \"cyl\", .SDcols = c(\"mpg\", \"hp\")\n]##    cyl mpg.mean mpg.median   hp.mean hp.median\n## 1:   6 19.74286       19.7 122.28571     110.0\n## 2:   4 26.66364       26.0  82.63636      91.0\n## 3:   8 15.10000       15.2 209.21429     192.5\n# dplyr\nmtcars |> \n  dplyr::group_by(cyl) |> \n  dplyr::summarise(\n    mean_mpg = mean(mpg), mean_hp = mean(hp),\n    median_mpg = mean(mpg), median_hp = mean(hp)\n  )## # A tibble: 3 × 5\n##     cyl mean_mpg mean_hp median_mpg median_hp\n##   <int>    <dbl>   <dbl>      <dbl>     <dbl>\n## 1     4     26.7    82.6       26.7      82.6\n## 2     6     19.7   122.        19.7     122. \n## 3     8     15.1   209.        15.1     209."},{"path":"chap-advanced-manipulation.html","id":"sec-rename-multi-cols","chapter":"第 7 章 高级数据操作","heading":"7.2.13 重命名多个列","text":"","code":"\ntmp <- aggregate(\n  data = mtcars, cbind(mpg, hp) ~ cyl,\n  FUN = median\n)\ntmp <- as.data.table(tmp)\nsetnames(tmp, old = c(\"mpg\", \"hp\"), new = c(\"median_mpg\", \"median_hp\"))\ntmp##    cyl median_mpg median_hp\n## 1:   4       26.0      91.0\n## 2:   6       19.7     110.0\n## 3:   8       15.2     192.5"},{"path":"chap-advanced-manipulation.html","id":"sec-sort-multi-cols","chapter":"第 7 章 高级数据操作","heading":"7.2.14 对多个列依次排序","text":"https://stackoverflow.com/questions/1296646/--sort--dataframe--multiple-columns","code":"\n# base\ntmp[order(median_mpg, -median_hp), ]##    cyl median_mpg median_hp\n## 1:   8       15.2     192.5\n## 2:   6       19.7     110.0\n## 3:   4       26.0      91.0\n# data.table\nsetorder(tmp, median_mpg, -median_hp)\n# dplyr\ndplyr::arrange(tmp, median_mpg, desc(median_hp))##    cyl median_mpg median_hp\n## 1:   8       15.2     192.5\n## 2:   6       19.7     110.0\n## 3:   4       26.0      91.0"},{"path":"chap-advanced-manipulation.html","id":"sec-rearrange-position-multi-cols","chapter":"第 7 章 高级数据操作","heading":"7.2.15 重排多个列的位置","text":"","code":"\n# https://stackoverflow.com/questions/19619666/change-column-position-of-data-table\nsetcolorder(tmp, c(\"median_mpg\", setdiff(names(tmp), \"median_mpg\")))\ntmp##    median_mpg cyl median_hp\n## 1:       15.2   8     192.5\n## 2:       19.7   6     110.0\n## 3:       26.0   4      91.0\n# dplyr\ndplyr::select(tmp, \"median_mpg\", setdiff(names(tmp), \"median_mpg\"))##    median_mpg cyl median_hp\n## 1:       15.2   8     192.5\n## 2:       19.7   6     110.0\n## 3:       26.0   4      91.0"},{"path":"chap-advanced-manipulation.html","id":"sec-tidy-output","chapter":"第 7 章 高级数据操作","heading":"7.2.16 整理回归结果","text":"","code":"\ndat <- split(iris, iris$Species)\nmod <- lapply(dat, function(x) lm(Petal.Length ~ Sepal.Length, x))\nmod <- lapply(mod, function(x) coef(summary(x)))\nmod <- Map(function(x, y) {\n  x <- as.data.frame(x)\n  x$Species <- y\n  x\n}, mod, names(dat))\nmod <- do.call(rbind, mod)\nmod##                          Estimate Std. Error    t value     Pr(>|t|)    Species\n## setosa.(Intercept)      0.8030518 0.34387807  2.3352806 2.375647e-02     setosa\n## setosa.Sepal.Length     0.1316317 0.06852690  1.9208760 6.069778e-02     setosa\n## versicolor.(Intercept)  0.1851155 0.51421351  0.3599974 7.204283e-01 versicolor\n## versicolor.Sepal.Length 0.6864698 0.08630708  7.9538056 2.586190e-10 versicolor\n## virginica.(Intercept)   0.6104680 0.41710685  1.4635770 1.498279e-01  virginica\n## virginica.Sepal.Length  0.7500808 0.06302606 11.9011203 6.297786e-16  virginica\n# 管道操作\nsplit(iris, iris$Species) %>%\n  lapply(., function(x) coef(summary(lm(Petal.Length ~ Sepal.Length, x)))) %>%\n  Map(function(x, y) {\n    x <- as.data.frame(x)\n    x$Species <- y\n    x\n  }, ., levels(iris$Species)) %>%\n  do.call(rbind, .)##                          Estimate Std. Error    t value     Pr(>|t|)    Species\n## setosa.(Intercept)      0.8030518 0.34387807  2.3352806 2.375647e-02     setosa\n## setosa.Sepal.Length     0.1316317 0.06852690  1.9208760 6.069778e-02     setosa\n## versicolor.(Intercept)  0.1851155 0.51421351  0.3599974 7.204283e-01 versicolor\n## versicolor.Sepal.Length 0.6864698 0.08630708  7.9538056 2.586190e-10 versicolor\n## virginica.(Intercept)   0.6104680 0.41710685  1.4635770 1.498279e-01  virginica\n## virginica.Sepal.Length  0.7500808 0.06302606 11.9011203 6.297786e-16  virginica\n# dplyr 操作，需要 dplyr >= 1.0.0 \niris %>%\n  dplyr::group_by(Species) %>%\n  dplyr::summarise(broom::tidy(lm(Petal.Length ~ Sepal.Length)))## # A tibble: 6 × 6\n## # Groups:   Species [3]\n##   Species    term         estimate std.error statistic  p.value\n##   <fct>      <chr>           <dbl>     <dbl>     <dbl>    <dbl>\n## 1 setosa     (Intercept)     0.803    0.344      2.34  2.38e- 2\n## 2 setosa     Sepal.Length    0.132    0.0685     1.92  6.07e- 2\n## 3 versicolor (Intercept)     0.185    0.514      0.360 7.20e- 1\n## 4 versicolor Sepal.Length    0.686    0.0863     7.95  2.59e-10\n## 5 virginica  (Intercept)     0.610    0.417      1.46  1.50e- 1\n## 6 virginica  Sepal.Length    0.750    0.0630    11.9   6.30e-16"},{"path":"chap-advanced-manipulation.html","id":"sec-assignment-by-reference","chapter":"第 7 章 高级数据操作","heading":"7.2.17 := 和 .()","text":"","code":"\nmtcars[, mpg_rate := round(mpg / sum(mpg) * 100, digits = 2), by = .(cyl, vs, am)]\nmtcars[, .(mpg_rate, mpg, cyl, vs, am)]##     mpg_rate  mpg cyl vs am\n##  1:    34.04 21.0   6  0  1\n##  2:    34.04 21.0   6  0  1\n##  3:    11.48 22.8   4  1  1\n##  4:    27.97 21.4   6  1  0\n##  5:    10.35 18.7   8  0  0\n##  6:    23.66 18.1   6  1  0\n##  7:     7.92 14.3   8  0  0\n##  8:    35.52 24.4   4  1  0\n##  9:    33.19 22.8   4  1  0\n## 10:    25.10 19.2   6  1  0\n## 11:    23.27 17.8   6  1  0\n## 12:     9.08 16.4   8  0  0\n## 13:     9.58 17.3   8  0  0\n## 14:     8.42 15.2   8  0  0\n## 15:     5.76 10.4   8  0  0\n## 16:     5.76 10.4   8  0  0\n## 17:     8.14 14.7   8  0  0\n## 18:    16.31 32.4   4  1  1\n## 19:    15.31 30.4   4  1  1\n## 20:    17.07 33.9   4  1  1\n## 21:    31.30 21.5   4  1  0\n## 22:     8.58 15.5   8  0  0\n## 23:     8.42 15.2   8  0  0\n## 24:     7.36 13.3   8  0  0\n## 25:    10.63 19.2   8  0  0\n## 26:    13.75 27.3   4  1  1\n## 27:   100.00 26.0   4  0  1\n## 28:    15.31 30.4   4  1  1\n## 29:    51.30 15.8   8  0  1\n## 30:    31.93 19.7   6  0  1\n## 31:    48.70 15.0   8  0  1\n## 32:    10.78 21.4   4  1  1\n##     mpg_rate  mpg cyl vs am\nmtcars[, .(mpg_rate = round(mpg / sum(mpg) * 100, digits = 2)), by = .(cyl, vs, am)]##     cyl vs am mpg_rate\n##  1:   6  0  1    34.04\n##  2:   6  0  1    34.04\n##  3:   6  0  1    31.93\n##  4:   4  1  1    11.48\n##  5:   4  1  1    16.31\n##  6:   4  1  1    15.31\n##  7:   4  1  1    17.07\n##  8:   4  1  1    13.75\n##  9:   4  1  1    15.31\n## 10:   4  1  1    10.78\n## 11:   6  1  0    27.97\n## 12:   6  1  0    23.66\n## 13:   6  1  0    25.10\n## 14:   6  1  0    23.27\n## 15:   8  0  0    10.35\n## 16:   8  0  0     7.92\n## 17:   8  0  0     9.08\n## 18:   8  0  0     9.58\n## 19:   8  0  0     8.42\n## 20:   8  0  0     5.76\n## 21:   8  0  0     5.76\n## 22:   8  0  0     8.14\n## 23:   8  0  0     8.58\n## 24:   8  0  0     8.42\n## 25:   8  0  0     7.36\n## 26:   8  0  0    10.63\n## 27:   4  1  0    35.52\n## 28:   4  1  0    33.19\n## 29:   4  1  0    31.30\n## 30:   4  0  1   100.00\n## 31:   8  0  1    51.30\n## 32:   8  0  1    48.70\n##     cyl vs am mpg_rate"},{"path":"chap-advanced-manipulation.html","id":"sec-remove-na","chapter":"第 7 章 高级数据操作","heading":"7.2.18 去掉含有缺失值的记录","text":"","code":"\nairquality[complete.cases(airquality), ] |>  head()##   Ozone Solar.R Wind Temp Month Day\n## 1    41     190  7.4   67     5   1\n## 2    36     118  8.0   72     5   2\n## 3    12     149 12.6   74     5   3\n## 4    18     313 11.5   62     5   4\n## 7    23     299  8.6   65     5   7\n## 8    19      99 13.8   59     5   8\n# 或着\nairquality[!apply(airquality, 1, anyNA), ] |>  head()##   Ozone Solar.R Wind Temp Month Day\n## 1    41     190  7.4   67     5   1\n## 2    36     118  8.0   72     5   2\n## 3    12     149 12.6   74     5   3\n## 4    18     313 11.5   62     5   4\n## 7    23     299  8.6   65     5   7\n## 8    19      99 13.8   59     5   8"},{"path":"chap-advanced-manipulation.html","id":"sec-match-set","chapter":"第 7 章 高级数据操作","heading":"7.2.19 集合操作","text":"match 和 %%\nhttps://d.cosx.org/d/421314返回一个逻辑向量，x 中的元素匹配到了就返回 TRUE，否则 FALSE， %nin% 是 %% 的取反效果x 在 y 中的匹配情况，匹配到了，就返回在 y 中匹配的位置，没有匹配到就返回 NA","code":"\n`%nin%` <- Negate(\"%in%\")\n# `%in%` <- function(x, table) match(x, table, nomatch = 0) > 0 # %in% 函数的定义\nx <- letters[1:5]\ny <- letters[3:8]\n\nx %in% y## [1] FALSE FALSE  TRUE  TRUE  TRUE\nx %nin% y## [1]  TRUE  TRUE FALSE FALSE FALSE\nmatch(x, y)## [1] NA NA  1  2  3\nsetdiff(x, y)## [1] \"a\" \"b\"\nintersect(x, y)## [1] \"c\" \"d\" \"e\"\nunion(x, y)## [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\""},{"path":"chap-advanced-manipulation.html","id":"transform-cut-aggregate","chapter":"第 7 章 高级数据操作","heading":"7.2.20 对数值向量按既定分组计数","text":"此数据处理过程陆续使用了 transform()、cut() 和 aggregate() 三个函数对数值向量按分位数分组计数","code":"\n# 对数值向量按既定分组计数\ndat <- data.frame(y = 1:12)\ndat <- transform(dat, x = cut(y, breaks = c(0, 6, 9, 15)))\ndat <- aggregate(data = dat, y ~ x, FUN = length)\nggplot(data = dat, aes(x = x, y = y)) +\n  geom_col()\n\ndata.frame(y = 1:12) %>%\n  transform(x = cut(y, breaks = c(0, 6, 9, 15))) %>%\n  aggregate(data = ., y ~ x, FUN = length) %>%\n  ggplot(data = ., aes(x = x, y = y)) +\n  geom_col()\ndat <- data.frame(y = 1:12)\ndat <- transform(dat, x = cut(\n  x = y,\n  breaks = quantile(y, prob = seq(0, 1, 0.25), na.rm = TRUE)\n))\n\n# dat <- transform(dat, x = cut(\n#   x = y,\n#   breaks = quantile(y, prob = seq(0, 1, 0.25)),\n#   include.lowest = T\n# ))\n\ndat1 <- aggregate(data = dat, y ~ x, FUN = length)\nggplot(data = dat1, aes(x = x, y = y)) +\n  geom_col()"},{"path":"chap-advanced-manipulation.html","id":"aggregate-order","chapter":"第 7 章 高级数据操作","heading":"7.2.21 分组排序","text":"按变量 分组计算，之后按变量 b 降序排列","code":"\ndat <- aggregate(data = iris, cbind(Sepal.Width, Sepal.Length) ~ Species, FUN = mean)\n# 按 Species 降序排列\ndat[order(dat$Species, decreasing = T), ]##      Species Sepal.Width Sepal.Length\n## 3  virginica       2.974        6.588\n## 2 versicolor       2.770        5.936\n## 1     setosa       3.428        5.006"},{"path":"chap-advanced-manipulation.html","id":"lapply-split-order","chapter":"第 7 章 高级数据操作","heading":"7.2.22 分组获取 Top 值","text":"分组按既定规律取数，比如按 Species 分组取 Top 6","code":"\n# 分组取前6个\ndo.call(\"rbind.data.frame\", lapply(base::split(x = iris, ~Species), head))\n# 分组取 Top 6\ndo.call(rbind, lapply(split(iris, iris$Species),\n  FUN = function(x) head(x[order(x$Sepal.Length, decreasing = T), ], 6)\n))##     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n##  1:          5.8         4.0          1.2         0.2     setosa\n##  2:          5.7         4.4          1.5         0.4     setosa\n##  3:          5.7         3.8          1.7         0.3     setosa\n##  4:          5.5         4.2          1.4         0.2     setosa\n##  5:          5.5         3.5          1.3         0.2     setosa\n##  6:          5.4         3.9          1.7         0.4     setosa\n##  7:          7.0         3.2          4.7         1.4 versicolor\n##  8:          6.9         3.1          4.9         1.5 versicolor\n##  9:          6.8         2.8          4.8         1.4 versicolor\n## 10:          6.7         3.1          4.4         1.4 versicolor\n## 11:          6.7         3.0          5.0         1.7 versicolor\n## 12:          6.7         3.1          4.7         1.5 versicolor\n## 13:          7.9         3.8          6.4         2.0  virginica\n## 14:          7.7         3.8          6.7         2.2  virginica\n## 15:          7.7         2.6          6.9         2.3  virginica\n## 16:          7.7         2.8          6.7         2.0  virginica\n## 17:          7.7         3.0          6.1         2.3  virginica\n## 18:          7.6         3.0          6.6         2.1  virginica"},{"path":"chap-advanced-manipulation.html","id":"lapply-split-sample","chapter":"第 7 章 高级数据操作","heading":"7.2.23 分组抽样","text":"","code":"\n# 分组抽样\ndo.call(rbind, lapply(split(iris, iris$Species),\n  FUN = function(x) x[sample(1:nrow(x), size = 6), ]\n))##     Sepal.Length Sepal.Width Petal.Length Petal.Width    Species\n##  1:          5.4         3.9          1.3         0.4     setosa\n##  2:          4.7         3.2          1.3         0.2     setosa\n##  3:          5.0         3.0          1.6         0.2     setosa\n##  4:          5.1         3.7          1.5         0.4     setosa\n##  5:          4.8         3.0          1.4         0.3     setosa\n##  6:          5.4         3.4          1.7         0.2     setosa\n##  7:          6.1         3.0          4.6         1.4 versicolor\n##  8:          6.2         2.2          4.5         1.5 versicolor\n##  9:          6.0         2.9          4.5         1.5 versicolor\n## 10:          5.7         2.9          4.2         1.3 versicolor\n## 11:          6.6         3.0          4.4         1.4 versicolor\n## 12:          5.7         2.8          4.5         1.3 versicolor\n## 13:          7.6         3.0          6.6         2.1  virginica\n## 14:          5.6         2.8          4.9         2.0  virginica\n## 15:          6.5         3.0          5.8         2.2  virginica\n## 16:          6.3         3.3          6.0         2.5  virginica\n## 17:          7.7         3.0          6.1         2.3  virginica\n## 18:          6.7         3.3          5.7         2.5  virginica"},{"path":"chap-advanced-manipulation.html","id":"lapply-split-quantile","chapter":"第 7 章 高级数据操作","heading":"7.2.24 分组计算分位数","text":"","code":"\n# 分组计算分位数，如何分组呢\ndo.call(rbind, lapply(iris[, sapply(iris, class) == \"numeric\"], quantile))##              0% 25% 50% 75% 100%\n## Sepal.Length  1   1   1   1    1\n## Sepal.Width   1   1   1   1    1\n## Petal.Length  1   1   1   1    1\n## Petal.Width   1   1   1   1    1\n## Species       0   0   0   0    0\naggregate(data = iris, cbind(Sepal.Length, Sepal.Width) ~ Species, FUN = quantile)##      Species Sepal.Length.0% Sepal.Length.25% Sepal.Length.50% Sepal.Length.75%\n## 1     setosa           4.300            4.800            5.000            5.200\n## 2 versicolor           4.900            5.600            5.900            6.300\n## 3  virginica           4.900            6.225            6.500            6.900\n##   Sepal.Length.100% Sepal.Width.0% Sepal.Width.25% Sepal.Width.50%\n## 1             5.800          2.300           3.200           3.400\n## 2             7.000          2.000           2.525           2.800\n## 3             7.900          2.200           2.800           3.000\n##   Sepal.Width.75% Sepal.Width.100%\n## 1           3.675            4.400\n## 2           3.000            3.400\n## 3           3.175            3.800\n# 对 Sepal.Length 按 Species 分组计算分位数\ndo.call(\"rbind\", tapply(iris$Sepal.Length, iris$Species, quantile))##             0%   25% 50% 75% 100%\n## setosa     4.3 4.800 5.0 5.2  5.8\n## versicolor 4.9 5.600 5.9 6.3  7.0\n## virginica  4.9 6.225 6.5 6.9  7.9\n# 分组取平均 mean /中位数 median\naggregate(data = iris, . ~ Species, FUN = mean)##      Species Sepal.Length Sepal.Width Petal.Length Petal.Width\n## 1     setosa        5.006       3.428        1.462       0.246\n## 2 versicolor        5.936       2.770        4.260       1.326\n## 3  virginica        6.588       2.974        5.552       2.026"},{"path":"chap-advanced-manipulation.html","id":"shift-lag","chapter":"第 7 章 高级数据操作","heading":"7.2.25 计算日粒度的 DoD/WoW/MoM/YoY","text":"截止写作时间，data.table 提供的滑动窗口聚合统计函数 frollmean()、frollsum() 和 frollapply() 还处于实验阶段。 shift 提供漂移功能，向前前置 lead 或向后延迟 lag。移动平均、求和和计算","code":"\ndat <- data.frame(dt = seq(\n  from = as.Date(\"2021-01-01\"),\n  to = Sys.Date(), by = \"1 day\"\n))\n\ndat <- within(dat, {\n  uv = round(1000 * runif(n = nrow(dat)))\n  uv_dod_d = ifelse(nrow(dat) <= 1, NA, c(NA, diff(uv, lag = 1)))\n  uv_wow_d = ifelse(nrow(dat) <= 7, NA, c(rep(NA, 7), diff(uv, lag = 7)))\n  uv_mom_d = ifelse(nrow(dat) <= 30, NA, c(rep(NA, 30), diff(uv, lag = 30)))\n  uv_yoy_d = ifelse(nrow(dat) <= 365, NA, c(rep(NA, 365), diff(uv, lag = 365)))\n})"},{"path":"chap-advanced-manipulation.html","id":"sec-adm-sessioninfo","chapter":"第 7 章 高级数据操作","heading":"7.3 运行环境","text":"","code":"\nsessionInfo()## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-pc-linux-gnu (64-bit)\n## Running under: Ubuntu 20.04.4 LTS\n## \n## Matrix products: default\n## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\n## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n## \n## locale:\n##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n## \n## attached base packages:\n## [1] stats     graphics  grDevices utils     datasets  methods   base     \n## \n## other attached packages:\n## [1] magrittr_2.0.3    data.table_1.14.2\n## \n## loaded via a namespace (and not attached):\n##  [1] highr_0.9        bslib_0.3.1      compiler_4.2.0   pillar_1.7.0    \n##  [5] jquerylib_0.1.4  tools_4.2.0      sysfonts_0.8.8   digest_0.6.29   \n##  [9] downlit_0.4.0    jsonlite_1.8.0   evaluate_0.15    memoise_2.0.1   \n## [13] lifecycle_1.0.1  tibble_3.1.7     pkgconfig_2.0.3  rlang_1.0.2     \n## [17] DBI_1.1.2        cli_3.3.0        curl_4.3.2       yaml_2.3.5      \n## [21] xfun_0.31        fastmap_1.1.0    stringr_1.4.0    dplyr_1.0.9     \n## [25] xml2_1.3.3       knitr_1.39       generics_0.1.2   fs_1.5.2        \n## [29] sass_0.4.1       vctrs_0.4.1      tidyselect_1.1.2 glue_1.6.2      \n## [33] R6_2.5.1         fansi_1.0.3      rmarkdown_2.14   bookdown_0.26   \n## [37] tidyr_1.2.0      purrr_0.3.4      backports_1.4.1  htmltools_0.5.2 \n## [41] ellipsis_0.3.2   assertthat_0.2.1 utf8_1.2.2       stringi_1.7.6   \n## [45] broom_0.8.0      cachem_1.0.6     crayon_1.5.1"},{"path":"chap-parallel-manipulation.html","id":"chap-parallel-manipulation","chapter":"第 8 章 并行化操作","heading":"第 8 章 并行化操作","text":"向量化运算、并行运算和分布式运算future 在 R 语言中提供统一的并行和分布式处理框架future.apply 可以替代 base R 提供的 apply 族函数future.batchtools 使用 batchtools 实现并行和分布式处理batchtools Map 函数的并行实现，用于高性能计算系统和分布式处理，可以单机多核并行也可以多机并行，还提供了一种抽象的机制去定义大规模计算机实验。multidplyr 是 dplyr 的后端，多核环境下实现数据分块，提高并行处理性能disk.frame 是基于磁盘的超出内存容量的快速并行数据操作框架parallelMap R package interface popular parallelization back-ends unified interfacebig.data.table 基于 data.table 的分布式并行计算","code":""},{"path":"chap-parallel-manipulation.html","id":"apply","chapter":"第 8 章 并行化操作","heading":"8.1 apply","text":"apply 家族和 .call","code":""},{"path":"chap-parallel-manipulation.html","id":"map-reduce","chapter":"第 8 章 并行化操作","heading":"8.2 MapReduce","text":"高阶函数，简单来说，就是参数为函数，返回值也是函数。Base R 提供了 Reduce 、Filter 、Find 、Map 、Negate 和 Position 等常用函数，此外还有 *apply 族。与 purrr::map 比较在 R 语言里玩转apply， Map() 和 Reduce()24，下面分别以提取合并多张 XLSX 表格25，分组计算26 和子集操作 27 为例，从函数式编程到 MapReduce 28，制作数据透视表29，用于数据处理的函数式编程和单元测试 Functional programming unit testing data munging R 特别是第三章 https://b-rodrigues.github.io/fput/，然后是函数式编程与数据建模 Modeling data functional programming R30","code":"\nadd <- function(x) Reduce(\"+\", x)\nadd(list(1, 2, 3))## [1] 6\nadd_accuml <- function(x) Reduce(\"+\", x, accumulate = TRUE)\nadd_accuml(list(1, 2, 3))## [1] 1 3 6"},{"path":"chap-parallel-manipulation.html","id":"parallel","chapter":"第 8 章 并行化操作","heading":"8.3 parallel","text":"并行计算小抄 将共享内存的 R 包整理在一起","code":"\nlibrary(parallel)"},{"path":"chap-parallel-manipulation.html","id":"rmpi","chapter":"第 8 章 并行化操作","heading":"8.4 Rmpi","text":"Rmpi 由卡尔顿大学的 Hao Yu 开发和维护首先安装 openmpi-devel 开发环境（以 Fedora 30 为例）然后进入 R 安装 R 包 Rmpi使用 Rmpi 包生成两组服从均匀分布的随机数调用 mpi.apply 函数用完要关闭pbdMPI 包处于活跃维护状态，是 pbdR 项目 的核心组件，能够以分布式计算的方式轻松处理 TB 级数据31Rhpc 包同样基于 MPI 方式，但是集 Rmpi 和 snow 两个包的优点于一身，在保持 apply 编程风格的同时，能够提供更好的高性能计算环境，支持长向量，能够处理一些大数据。","code":"yum install -y openmpi-devel\necho \"export ORTED=/usr/lib64/openmpi/bin\" >> ~/.bashrc\n# 或者\necho \"PATH=/usr/lib64/openmpi/bin:$PATH; export PATH\" | tee -a ~/.bashrc\nsource ~/.bashrc\ninstall.packages('Rmpi')\n# 加载 R 包\nlibrary(Rmpi)\n# 检测可用的逻辑 CPU 核心数\nparallel::detectCores()\n# 虚拟机分配四个逻辑CPU核 \n# 1个 master 2个 worker 主机 cloud\nmpi.spawn.Rslaves(nslaves=2)#         2 slaves are spawned successfully. 0 failed.\n# master (rank 0, comm 1) of size 3 is running on: cloud\n# slave1 (rank 1, comm 1) of size 3 is running on: cloud\n# slave2 (rank 2, comm 1) of size 3 is running on: cloud\nset.seed(1234)\nmpi.apply(c(10, 20), runif)[[1]]\n [1] 0.33684269 0.84638494 0.82776590 0.23707947 0.07593769 0.27981368\n [7] 0.45307675 0.02878214 0.32807421 0.92854275\n\n[[2]]\n [1] 0.63474442 0.04025071 0.01996498 0.01922093 0.41258827 0.84150414\n [7] 0.74705002 0.07635368 0.32807392 0.94570363 0.89187667 0.67069020\n[13] 0.92996997 0.22486589 0.22118236 0.15807970 0.65619450 0.16473730\n[19] 0.85833484 0.11416449\nmpi.close.Rslaves()"},{"path":"chap-parallel-manipulation.html","id":"gpur","chapter":"第 8 章 并行化操作","heading":"8.5 gpuR","text":"Charles Determan 开发的 gpuR 基于 OpenCL 加速，目前处于活跃维护状态。而 Charles Determan 开发的另一个 gpuRcuda 包是基于 CUDA 加速赵鹏 的博客 ParallelR 关注基于 CUDA 的 GPU 加速此外还有 gputools","code":"\nlibrary(gpuR)\nset.seed(2019)\ngpuA <- gpuMatrix(rnorm(16), nrow = 4, ncol = 4)\ngpuAAn object of class \"fgpuMatrix\"\nSlot \"address\":\n<pointer: 0x000000000fbe9760>\n\nSlot \".context_index\":\n[1] 1\n\nSlot \".platform_index\":\n[1] 1\n\nSlot \".platform\":\n[1] \"Intel(R) OpenCL\"\n\nSlot \".device_index\":\n[1] 1\n\nSlot \".device\":\n[1] \"Intel(R) HD Graphics 4600\"\ngpuB <- gpuA %*% gpuA\nprint(gpuB)Source: gpuR Matrix [4 x 4]\n\n            [,1]      [,2]      [,3]       [,4]\n[1,]  2.61787200 -1.274909 -2.150301 -2.0073860\n[2,] -0.02231596  1.566433  0.986027  0.7339008\n[3,] -0.12862393  1.848340  3.261899  1.6919358\n[4,] -1.90084898 -1.863014 -1.312350 -0.2553876"},{"path":"chap-parallel-manipulation.html","id":"parallel-sessioninfo","chapter":"第 8 章 并行化操作","heading":"8.6 运行环境","text":"create--empty-data-frame\npipe-r","code":"\nxfun::session_info()## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-pc-linux-gnu (64-bit)\n## Running under: Ubuntu 20.04.4 LTS\n## \n## Locale:\n##   LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n##   LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n##   LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n##   LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n##   LC_ADDRESS=C               LC_TELEPHONE=C            \n##   LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n## \n## Package version:\n##   base64enc_0.1.3 bookdown_0.26   brio_1.1.3      bslib_0.3.1    \n##   cachem_1.0.6    cli_3.3.0       compiler_4.2.0  curl_4.3.2     \n##   desc_1.4.1      digest_0.6.29   downlit_0.4.0   evaluate_0.15  \n##   fansi_1.0.3     fastmap_1.1.0   fs_1.5.2        glue_1.6.2     \n##   graphics_4.2.0  grDevices_4.2.0 highr_0.9       htmltools_0.5.2\n##   jquerylib_0.1.4 jsonlite_1.8.0  knitr_1.39      magrittr_2.0.3 \n##   memoise_2.0.1   methods_4.2.0   R6_2.5.1        rappdirs_0.3.3 \n##   rlang_1.0.2     rmarkdown_2.14  rprojroot_2.0.3 sass_0.4.1     \n##   stats_4.2.0     stringi_1.7.6   stringr_1.4.0   sysfonts_0.8.8 \n##   tinytex_0.39    tools_4.2.0     utils_4.2.0     vctrs_0.4.1    \n##   xfun_0.31       xml2_1.3.3      yaml_2.3.5"},{"path":"chap-dplyr-manipulation.html","id":"chap-dplyr-manipulation","chapter":"第 9 章 净土化操作","heading":"第 9 章 净土化操作","text":"","code":"\nlibrary(dplyr)"},{"path":"chap-dplyr-manipulation.html","id":"common-operations","chapter":"第 9 章 净土化操作","heading":"9.1 常用操作","text":"dplyr 由 Hadley Wickham 主要由开发和维护，是Rstudio公司开源的用于数据处理的一大利器，该包号称「数据操作的语法」，与 ggplot2 的「图形语法」 对应，也就是说数据处理那一套已经建立完整的和SQL一样的功能。它们都遵循同样的处理逻辑，只不过一个用SQL写，一个用R语言写，处理效率差不多，R语言写的 SQL 会被翻译为 SQL 语句，再传至数据库查询，当然它也支持内存内的数据操作。目前 dplyr 以 dbplyr 为后端支持的数据库有：MySQL、PostgreSQL，SQLite等，完整的支持列表请看 这里，连接特定数据库，都是基于 DBI，DBI 即 Database Interface， 是使用C/C++开发的底层数据库接口，是一个统一的关系型数据库连接框架，需要根据不同的具体的数据库进行实例化，才可使用。dplyr 常用的函数是 7 个： arrange 排序 filter 过滤行 select 选择列 mutate 变换 summarise 汇总 group_by 分组 distinct 去重以 ggplot2 包自带的钻石数据集 diamonds 为例介绍","code":""},{"path":"chap-dplyr-manipulation.html","id":"tibble-show","chapter":"第 9 章 净土化操作","heading":"9.1.1 查看","text":"除了直接打印数据集的前几行，tibble 包还提供 glimpse 函数查看数据集，而 Base R 默认查看方式是调用 str 函数表 9.1:  dplyr 定义的数据对象类型表 9.1 中 dttm 和 date 类型代指 lubridate 包指定的日期对象 POSIXct、 POSIXlt、 Date、 chron、 yearmon、 yearqtr、 zoo、 zooreg、 timeDate、 xts、 、 ti、 jul、 timeSeries 和 fts。","code":"\ndata(\"diamonds\", package = \"ggplot2\")\nglimpse(diamonds)## Rows: 53,940\n## Columns: 10\n## $ carat   <dbl> 0.23, 0.21, 0.23, 0.29, 0.31, 0.24, 0.24, 0.26, 0.22, 0.23, 0.…\n## $ cut     <ord> Ideal, Premium, Good, Premium, Good, Very Good, Very Good, Ver…\n## $ color   <ord> E, E, E, I, J, J, I, H, E, H, J, J, F, J, E, E, I, J, J, J, I,…\n## $ clarity <ord> SI2, SI1, VS1, VS2, SI2, VVS2, VVS1, SI1, VS2, VS1, SI1, VS1, …\n## $ depth   <dbl> 61.5, 59.8, 56.9, 62.4, 63.3, 62.8, 62.3, 61.9, 65.1, 59.4, 64…\n## $ table   <dbl> 55, 61, 65, 58, 58, 57, 57, 55, 61, 61, 55, 56, 61, 54, 62, 58…\n## $ price   <int> 326, 326, 327, 334, 335, 336, 336, 337, 337, 338, 339, 340, 34…\n## $ x       <dbl> 3.95, 3.89, 4.05, 4.20, 4.34, 3.94, 3.95, 4.07, 3.87, 4.00, 4.…\n## $ y       <dbl> 3.98, 3.84, 4.07, 4.23, 4.35, 3.96, 3.98, 4.11, 3.78, 4.05, 4.…\n## $ z       <dbl> 2.43, 2.31, 2.31, 2.63, 2.75, 2.48, 2.47, 2.53, 2.49, 2.39, 2.…"},{"path":"chap-dplyr-manipulation.html","id":"dplyr-filter","chapter":"第 9 章 净土化操作","heading":"9.1.2 筛选","text":"按条件筛选数据的子集，按行筛选先按行，再按列筛选","code":"\ndiamonds |>  filter(cut == \"Ideal\" , carat >= 3)## # A tibble: 4 × 10\n##   carat cut   color clarity depth table price     x     y     z\n##   <dbl> <ord> <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n## 1  3.22 Ideal I     I1       62.6    55 12545  9.49  9.42  5.92\n## 2  3.5  Ideal H     I1       62.8    57 12587  9.65  9.59  6.03\n## 3  3.01 Ideal J     SI2      61.7    58 16037  9.25  9.2   5.69\n## 4  3.01 Ideal J     I1       65.4    60 16538  8.99  8.93  5.86\ndiamonds |>  \n  filter(carat >= 3, color == \"I\") |>  \n  select(cut, carat)## # A tibble: 16 × 2\n##    cut       carat\n##    <ord>     <dbl>\n##  1 Premium    3.01\n##  2 Fair       3.02\n##  3 Good       3   \n##  4 Ideal      3.22\n##  5 Premium    4.01\n##  6 Very Good  3.04\n##  7 Very Good  4   \n##  8 Premium    3.67\n##  9 Premium    3   \n## 10 Fair       3   \n## 11 Premium    3.01\n## 12 Fair       3.01\n## 13 Fair       3.01\n## 14 Good       3.01\n## 15 Good       3.01\n## 16 Premium    3.04"},{"path":"chap-dplyr-manipulation.html","id":"dplyr-arrange","chapter":"第 9 章 净土化操作","heading":"9.1.3 排序","text":"arrange 默认升序排列，按钻石重量升序，按价格降序","code":"\ndiamonds |>  \n  filter(cut == \"Ideal\" , carat >= 3) |>  \n  arrange(carat, desc(price))## # A tibble: 4 × 10\n##   carat cut   color clarity depth table price     x     y     z\n##   <dbl> <ord> <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n## 1  3.01 Ideal J     I1       65.4    60 16538  8.99  8.93  5.86\n## 2  3.01 Ideal J     SI2      61.7    58 16037  9.25  9.2   5.69\n## 3  3.22 Ideal I     I1       62.6    55 12545  9.49  9.42  5.92\n## 4  3.5  Ideal H     I1       62.8    57 12587  9.65  9.59  6.03"},{"path":"chap-dplyr-manipulation.html","id":"dplyr-summarise","chapter":"第 9 章 净土化操作","heading":"9.1.4 聚合","text":"分组求和，求平均，计数","code":"\ndiamonds |>  \n  filter(carat > 3, color == \"I\") |>  \n  group_by(cut, clarity) |>  \n  summarise(sum_carat = sum(carat), mean_carat = mean(carat), n_count = n())## # A tibble: 8 × 5\n## # Groups:   cut [5]\n##   cut       clarity sum_carat mean_carat n_count\n##   <ord>     <ord>       <dbl>      <dbl>   <int>\n## 1 Fair      I1           3.02       3.02       1\n## 2 Fair      SI2          6.02       3.01       2\n## 3 Good      SI2          6.02       3.01       2\n## 4 Very Good I1           4          4          1\n## 5 Very Good SI2          3.04       3.04       1\n## 6 Premium   I1          10.7        3.56       3\n## 7 Premium   SI2          6.05       3.02       2\n## 8 Ideal     I1           3.22       3.22       1"},{"path":"chap-dplyr-manipulation.html","id":"dplyr-merge","chapter":"第 9 章 净土化操作","heading":"9.1.5 合并","text":"按行合并按列合并","code":"\nset.seed(2018)\none <- diamonds |>  \n  filter(color == \"I\") |>  \n  sample_n(5)\ntwo <- diamonds |>  \n  filter(color == \"J\") |>  \n  sample_n(5)\n# 按行合并数据框 one 和 two\nbind_rows(one, two)## # A tibble: 10 × 10\n##    carat cut       color clarity depth table price     x     y     z\n##    <dbl> <ord>     <ord> <ord>   <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n##  1  0.42 Ideal     I     VVS1     62.5  57     884  4.77  4.8   2.99\n##  2  0.3  Ideal     I     VVS2     62.5  53.6   532  4.29  4.33  2.69\n##  3  2.02 Good      I     VS1      57.9  63   17533  8.13  8.21  4.73\n##  4  0.9  Premium   I     VS2      61.9  58    3398  6.18  6.23  3.84\n##  5  1.98 Very Good I     VS2      62.7  60   15083  7.9   7.96  4.98\n##  6  1.51 Very Good J     VVS2     62.6  63    8706  7.29  7.24  4.55\n##  7  0.7  Very Good J     SI1      61.7  57    1979  5.65  5.69  3.5 \n##  8  1.16 Premium   J     VS2      62.2  59    4702  6.74  6.69  4.18\n##  9  1.5  Premium   J     VVS2     61.8  60    8760  7.36  7.33  4.54\n## 10  1.51 Premium   J     SI1      60.4  62    6680  7.42  7.32  4.45\nset.seed(2018)\nthree <- diamonds |>  \n  select(carat, color) |>  \n  sample_n(5)\nfour <- diamonds |>  \n  select(carat, color) |>  \n  sample_n(5)\nbind_cols(three, four)## # A tibble: 5 × 4\n##   carat...1 color...2 carat...3 color...4\n##       <dbl> <ord>         <dbl> <ord>    \n## 1      0.33 H              0.52 F        \n## 2      1.09 F              0.51 F        \n## 3      1.52 I              0.5  G        \n## 4      0.95 G              0.38 E        \n## 5      0.35 E              0.51 J"},{"path":"chap-dplyr-manipulation.html","id":"dplyr-mutate","chapter":"第 9 章 净土化操作","heading":"9.1.6 变换","text":"添加一列，新的列或者改变原来的列","code":"\ndiamonds |>  \n  filter(carat > 3, color == \"I\") |>  \n  select(cut, carat) |>  \n  mutate(vol = if_else(carat > 3.5, \"A\", \"B\"))## # A tibble: 13 × 3\n##    cut       carat vol  \n##    <ord>     <dbl> <chr>\n##  1 Premium    3.01 B    \n##  2 Fair       3.02 B    \n##  3 Ideal      3.22 B    \n##  4 Premium    4.01 A    \n##  5 Very Good  3.04 B    \n##  6 Very Good  4    A    \n##  7 Premium    3.67 A    \n##  8 Premium    3.01 B    \n##  9 Fair       3.01 B    \n## 10 Fair       3.01 B    \n## 11 Good       3.01 B    \n## 12 Good       3.01 B    \n## 13 Premium    3.04 B"},{"path":"chap-dplyr-manipulation.html","id":"dplyr-duplicated","chapter":"第 9 章 净土化操作","heading":"9.1.7 去重","text":"数据去重在 dplyr 中的实现32。去掉列重复的数据点 (x, y)","code":"\nset.seed(123)\ndf <- data.frame(\n  x = sample(0:1, 10, replace = T),\n  y = sample(0:1, 10, replace = T),\n  z = 1:10\n)\ndf##    x y  z\n## 1  0 1  1\n## 2  0 1  2\n## 3  0 1  3\n## 4  1 0  4\n## 5  0 1  5\n## 6  1 0  6\n## 7  1 1  7\n## 8  1 0  8\n## 9  0 0  9\n## 10 0 0 10\ndf |>  \n  group_by(x, y) |> \n  filter(row_number(z) == 1)## # A tibble: 4 × 3\n## # Groups:   x, y [4]\n##       x     y     z\n##   <int> <int> <int>\n## 1     0     1     1\n## 2     1     0     4\n## 3     1     1     7\n## 4     0     0     9\n# 此处不对，没有了 z \ndf |> \n  distinct(x, y)##   x y\n## 1 0 1\n## 2 1 0\n## 3 1 1\n## 4 0 0\n# 应该为\ndf |> \n  distinct(x, y, .keep_all = TRUE)##   x y z\n## 1 0 1 1\n## 2 1 0 4\n## 3 1 1 7\n## 4 0 0 9"},{"path":"chap-dplyr-manipulation.html","id":"common-dataframe-operations","chapter":"第 9 章 净土化操作","heading":"9.2 高频问题","text":"常用的数据操作包含创建空的数据框或者说初始化一个数据框，按指定的列对数据框排序，选择特定的一些列，复杂情况是可能需要正则表达式从列名或者值中筛选合并两个数据框，分为 (inner outer left right) 四种情况宽格式和长格式互相转换，即重塑操作 reshape，单独的 tidyr 包操作，是 reshape2 包的进化版，提供 spread 和 gather 两个主要函数","code":""},{"path":"chap-dplyr-manipulation.html","id":"create-empty-dataframe","chapter":"第 9 章 净土化操作","heading":"9.2.1 初始化数据框","text":"创建空的数据框，就是不包含任何行、记录如果数据框 df 包含数据，现在要依据它创建一个空的数据框还可以使用 structure 构造一个数据框，并且我们发现它的效率更高","code":"\nempty_df <- data.frame(\n  Doubles = double(),\n  Ints = integer(),\n  Factors = factor(),\n  Logicals = logical(),\n  Characters = character(),\n  stringsAsFactors = FALSE\n)\nstr(empty_df)## 'data.frame':    0 obs. of  5 variables:\n##  $ Doubles   : num \n##  $ Ints      : int \n##  $ Factors   : Factor w/ 0 levels: \n##  $ Logicals  : logi \n##  $ Characters: chr\nempty_df = df[FALSE,]\ns <- function() structure(list(\n    Date = as.Date(character()),\n    File = character(),\n    User = character()\n  ),\n  class = \"data.frame\"\n  )\nd <- function() data.frame(\n    Date = as.Date(character()),\n    File = character(),\n    User = character(),\n    stringsAsFactors = FALSE\n  )\nmicrobenchmark::microbenchmark(s(), d())## Unit: microseconds\n##  expr   min     lq    mean median     uq    max neval\n##   s()  17.6  20.35  51.113  27.00  28.95 2294.3   100\n##   d() 187.5 196.70 224.955 200.05 205.40 2202.0   100"},{"path":"chap-dplyr-manipulation.html","id":"remove-missing-values","chapter":"第 9 章 净土化操作","heading":"9.2.2 移除缺失记录","text":"只要行中包含缺失值，我们就把这样的行移除出去","code":"\nairquality[complete.cases(airquality), ] |> head()##   Ozone Solar.R Wind Temp Month Day\n## 1    41     190  7.4   67     5   1\n## 2    36     118  8.0   72     5   2\n## 3    12     149 12.6   74     5   3\n## 4    18     313 11.5   62     5   4\n## 7    23     299  8.6   65     5   7\n## 8    19      99 13.8   59     5   8"},{"path":"chap-dplyr-manipulation.html","id":"coerce-data-type","chapter":"第 9 章 净土化操作","heading":"9.2.3 数据类型转化","text":"","code":"\nstr(PlantGrowth)## 'data.frame':    30 obs. of  2 variables:\n##  $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n##  $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\nbob <- PlantGrowth\ni <- sapply(bob, is.factor)\nbob[i] <- lapply(bob[i], as.character)\nstr(bob)## 'data.frame':    30 obs. of  2 variables:\n##  $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n##  $ group : chr  \"ctrl\" \"ctrl\" \"ctrl\" \"ctrl\" ..."},{"path":"chap-dplyr-manipulation.html","id":"cross-group-by","chapter":"第 9 章 净土化操作","heading":"9.2.4 跨列分组求和","text":"输入是一个数据框 data.frame，按照其中某一变量分组，然后计算任意数量的变量的行和和列和。空气质量数据集 airquality 按月份 Month 分组，然后求取满足条件的列的和什么是函数式编程，R 语言环境下的函数式编程是如何操作的","code":"\nReduce(rbind, lapply(unique(airquality$Month), function(gv) {\n  subdta <- subset(airquality, subset = Month == gv)\n  data.frame(\n    Colsum = as.numeric(\n      colSums(subdta[, grepl(\"[mM]\", names(airquality))], na.rm = TRUE)\n    ),\n    Month = gv\n  )\n}))##    Colsum Month\n## 1    2032     5\n## 2     155     5\n## 3    2373     6\n## 4     180     6\n## 5    2601     7\n## 6     217     7\n## 7    2603     8\n## 8     248     8\n## 9    2307     9\n## 10    270     9"},{"path":"chap-dplyr-manipulation.html","id":"pipe-manipulation","chapter":"第 9 章 净土化操作","heading":"9.3 管道操作","text":"Stefan Milton Bache 开发了 magrittr 包实现管道操作，增加代码的可读性和维护性，但是这个 R 包的名字取的太奇葩，因为 记不住，它其实是一个复杂的法语发音，中式英语就叫它马格里特吧！这下应该好记多了吧！我要查看是否需要新添加一个 R 包依赖，假设该 R 包是 reticulate 没有出现在 DESCRIPTION 文件中，但是可能已经被其中某（个）些 R 包依赖了安装 pkg 的依赖转化为管道操作，增加可读性再举一个关于数据模拟的例子模拟 0-1 序列，似然估计","code":"\n\"reticulate\" %in% sort(unique(unlist(tools::package_dependencies(desc::desc_get_deps()$package, recursive = TRUE))))## [1] TRUE\npkg <- c(\n  \"bookdown\",\n  \"e1071\",\n  \"formatR\",\n  \"lme4\",\n  \"mvtnorm\",\n  \"prettydoc\", \"psych\",\n  \"reticulate\", \"rstan\", \"rstanarm\", \"rticles\",\n  \"svglite\",\n  \"TMB\", \"glmmTMB\"\n)\n# 获取 pkg 的所有依赖\ndep_pkg <- tools::package_dependencies(pkg, recursive = TRUE)\n# 将列表 list 合并为向量 vector\nmerge_pkg <- Reduce(\"c\", dep_pkg, accumulate = FALSE)\n# 所有未安装的 R 包\nmiss_pkg <- setdiff(unique(merge_pkg), unique(.packages(TRUE)))\n# 除了 pkg 外，未安装的 R 包，安装 pkg 的依赖\nsort(setdiff(miss_pkg, pkg))## [1] \"mnormt\"\nset.seed(2019)\nbinom_sample <- function(n) {\n  sum(sample(x = c(0,1), size = n, prob = c(0.8, 0.2), replace = TRUE))/n\n}\n# 频率估计概率\none_prob <- sapply(10^(seq(8)), binom_sample)\n# 估计的误差\none_abs <- abs(one_prob - 0.2)\none_abs## [1] 1.000e-01 1.000e-02 1.100e-02 4.400e-03 1.460e-03 3.980e-04 4.700e-06\n## [8] 9.552e-05"},{"path":"chap-statistical-graphics.html","id":"chap-statistical-graphics","chapter":"介绍","heading":"介绍","text":"统计图形","code":""},{"path":"chap-graphics-foundations.html","id":"chap-graphics-foundations","chapter":"第 10 章 图形基础","heading":"第 10 章 图形基础","text":"数据可视化是一种重要的数据分析手段， R 提供了两套图形系统，分别是 graphics 包提供的基础绘图系统和 grid 包提供的栅格绘图系统，后者主要以两个 R 包为大家所熟知，一个是 lattice 包，另一个是 ggplot2 包。Base 图形系统的扩展包 basetheme 可以设置主题，prettyB 和 gridGraphics为了方便记忆函数 par 的各个参数，Paul Murrell 整理了一份 助记符，此外，LaTeX 宏包 geometry 对版面设置有很多专业的说明","code":"\nlibrary(survival)\nlibrary(lattice)\nlibrary(nlme)\nlibrary(MASS)\nlibrary(RColorBrewer)\nlibrary(latticeExtra)\nlibrary(shape)\nlibrary(splines)\nlibrary(mgcv)\nlibrary(maps)\nlibrary(mapproj)"},{"path":"chap-graphics-foundations.html","id":"graphics-elements","chapter":"第 10 章 图形基础","heading":"10.1 绘图基本要素","text":"","code":""},{"path":"chap-graphics-foundations.html","id":"base-points","chapter":"第 10 章 图形基础","heading":"10.1.1 点线","text":"点和线是最常见的画图元素，在 plot 函数中，分别用参数 pch 和 lty 来设定类型，点的大小、线的宽度分别用参数 cex 和 lwd 来指定，颜色由参数 col 设置。参数 type 不同的值设置如下，p 显示点，l 绘制线，b 同时绘制空心点，并用线连接，c 只有线，o 在线上绘制点，s 和 S 点线连接绘制阶梯图，h 绘制类似直方图一样的垂线，最后 n 表示什么也不画。点 points 、线 grid 背景线 abline lines rug 刻度线（线段segments、箭头arrows）、\n图 10.1: 不同的 pch 参数值\n\n图 10.2: pch 支持的字符\n\n图 10.3: pch 支持的字符\n\n图 10.4: pch 支持的字符\n\n图 10.5: pch 支持的字符\n\n图 10.6: 不同的 type 参数值\n颜色 col 连续型和离散型线帽/端和字体的样式\n图 10.7: 不同的线端样式\nlend：线端的样式，可用一个整数或字符串指定：0 或 “round” 圆形（默认）1 或 “butt” 对接形2 或 “square” 方形","code":"\n## -------- Showing all the extra & some char graphics symbols ---------\npchShow <-\n  function(extras = c(\"*\", \".\", \"o\", \"O\", \"0\", \"+\", \"-\", \"|\", \"%\", \"#\"),\n             cex = 2, ## good for both .Device==\"postscript\" and \"x11\"\n             col = \"red3\", bg = \"gold\", coltext = \"brown\", cextext = 1.2,\n             main = paste(\n               \"plot symbols :  points (...  pch = *, cex =\",\n               cex, \")\"\n             )) {\n    nex <- length(extras)\n    np <- 26 + nex\n    ipch <- 0:(np - 1)\n    k <- floor(sqrt(np))\n    dd <- c(-1, 1) / 2\n    rx <- dd + range(ix <- ipch %/% k)\n    ry <- dd + range(iy <- 3 + (k - 1) - ipch %% k)\n    pch <- as.list(ipch) # list with integers & strings\n    if (nex > 0) pch[26 + 1:nex] <- as.list(extras)\n    plot(rx, ry, type = \"n\", axes = FALSE, xlab = \"\", ylab = \"\", main = main)\n    abline(v = ix, h = iy, col = \"lightgray\", lty = \"dotted\")\n    for (i in 1:np) {\n      pc <- pch[[i]]\n      ## 'col' symbols with a 'bg'-colored interior (where available) :\n      points(ix[i], iy[i], pch = pc, col = col, bg = bg, cex = cex)\n      if (cextext > 0) {\n        text(ix[i] - 0.3, iy[i], pc, col = coltext, cex = cextext)\n      }\n    }\n  }\n\npchShow()\n## ------------ test code for various pch specifications -------------\n# Try this in various font families (including Hershey)\n# and locales.  Use sign = -1 asserts we want Latin-1.\n# Standard cases in a MBCS locale will not plot the top half.\nTestChars <- function(sign = 1, font = 1, ...) {\n  MB <- l10n_info()$MBCS\n  r <- if (font == 5) {\n    sign <- 1\n    c(32:126, 160:254)\n  } else if (MB) 32:126 else 32:255\n  if (sign == -1) r <- c(32:126, 160:255)\n  par(pty = \"s\")\n  plot(c(-1, 16), c(-1, 16),\n    type = \"n\", xlab = \"\", ylab = \"\",\n    xaxs = \"i\", yaxs = \"i\",\n    main = sprintf(\"sign = %d, font = %d\", sign, font)\n  )\n  grid(17, 17, lty = 1)\n  mtext(paste(\"MBCS:\", MB))\n  for (i in r) try(points(i %% 16, i %/% 16, pch = sign * i, font = font, ...))\n}\nTestChars()\ntry(TestChars(sign = -1))\nTestChars(font = 5) # Euro might be at 160 (0+10*16).\n# macOS has apple at 240 (0+15*16).\ntry(TestChars(-1, font = 2)) # bold\nx <- 0:12\ny <- sin(pi / 5 * x)\npar(mfrow = c(3, 3), mar = .1 + c(2, 2, 3, 1))\nfor (tp in c(\"p\", \"l\", \"b\", \"c\", \"o\", \"h\", \"s\", \"S\", \"n\")) {\n  plot(y ~ x, type = tp, main = paste0(\"plot(*, type = \\\"\", tp, \"\\\")\"))\n  if (tp == \"S\") {\n    lines(x, y, type = \"s\", col = \"red\", lty = 2)\n    mtext(\"lines(*, type = \\\"s\\\", ...)\", col = \"red\", cex = 0.8)\n  }\n}\n# 合并为一个图 三条粗横线 横线上三种字形\nplot(c(1, 20), c(1, 20), type = \"n\", ann = FALSE)\nlines(x = c(5, 15), y = c(5, 5), lwd = 15, lend = \"round\")\ntext(10, 5, \"Hello, Helvetica\", cex = 1.5, family = \"sans\", pos = 1, offset = 1.5)\ntext(5, 5, \"sans\", cex = 1.5, family = \"sans\", pos = 2, offset = .5)\ntext(15, 5, \"lend = round\", pos = 4, offset = .5)\n\nlines(x = c(5, 15), y = c(10, 10), lwd = 15, lend = \"butt\")\ntext(10, 10, \"Hello, Helvetica\", cex = 1.5, family = \"mono\", pos = 1, offset = 1.5)\ntext(5, 10, \"mono\", cex = 1.5, family = \"mono\", pos = 2, offset = .5)\ntext(15, 10, \"lend = butt\", pos = 4, offset = .5)\n\nlines(x = c(5, 15), y = c(15, 15), lwd = 15, lend = \"square\")\ntext(10, 15, \"Hello, Helvetica\", cex = 1.5, family = \"serif\", pos = 1, offset = 1.5)\ntext(5, 15, \"serif\", cex = 1.5, family = \"serif\", pos = 2, offset = .5)\ntext(15, 15, \"lend = square\", pos = 4, offset = .5)"},{"path":"chap-graphics-foundations.html","id":"base-rect","chapter":"第 10 章 图形基础","heading":"10.1.2 区域","text":"矩形，多边形，曲线交汇出来的区域\n面（矩形rect，多边形polygon）、路径 polypath\n面/多边形 rect 颜色填充\n图 10.8: rect 函数画长方形\nclip(x1, x2, y1, y2) 在用户坐标中设置剪切区域\n图 10.9: 区域重叠 polygon 函数\n各种符号 10.10\n图 10.10: cex 支持的符号\n点、线、多边形和圆聚集在图 10.11 中\n图 10.11: 多边形和符号元素\n在介绍各种统计图形之前，先介绍几个绘图函数 plot 和 text 还有 par 参数设置， 作为最简单的开始，尽量依次介绍其中的每个参数的含义并附上图形对比。\n图 10.12: pos 位置参数\n其中 labels， pos 都是向量化的参数","code":"\n# From the manual\nch.col <- c(\n  \"rainbow(n, start=.7, end=.1)\",\n  \"heat.colors(n)\",\n  \"terrain.colors(n)\",\n  \"topo.colors(n)\",\n  \"cm.colors(n)\"\n) # 选择颜色\nn <- 16\nnt <- length(ch.col)\ni <- 1:n\nj <- n / nt\nd <- j / 6\ndy <- 2 * d\nplot(i, i + d,\n  type = \"n\",\n  yaxt = \"n\",\n  ylab = \"\",\n  xlab = \"\",\n  main = paste(\"color palettes; n=\", n)\n)\nfor (k in 1:nt) {\n  rect(i - .5, (k - 1) * j + dy, i + .4, k * j,\n    col = eval(parse(text = ch.col[k]))\n  ) # 咬人的函数/字符串解析为/转函数\n  text(2 * j, k * j + dy / 4, ch.col[k])\n}\nx <- rnorm(1000)\nhist(x, xlim = c(-4, 4))\nusr <- par(\"usr\")\nclip(usr[1], -2, usr[3], usr[4])\nhist(x, col = \"red\", add = TRUE)\nclip(2, usr[2], usr[3], usr[4])\nhist(x, col = \"blue\", add = TRUE)\ndo.call(\"clip\", as.list(usr)) # reset to plot region\nmy.col <- function(f, g, xmin, xmax, col, N = 200,\n                   xlab = \"\", ylab = \"\", main = \"\") {\n  x <- seq(xmin, xmax, length = N)\n  fx <- f(x)\n  gx <- g(x)\n  plot(0, 0,\n    type = \"n\",\n    xlim = c(xmin, xmax),\n    ylim = c(min(fx, gx), max(fx, gx)),\n    xlab = xlab, ylab = ylab, main = main\n  )\n  polygon(c(x, rev(x)), c(fx, rev(gx)),\n    col = \"#EA4335\", border = 0\n  )\n  lines(x, fx, lwd = 3, col = \"#34A853\")\n  lines(x, gx, lwd = 3, col = \"#4285f4\")\n}\nmy.col(function(x) x^2, function(x) x^2 + 10 * sin(x),\n  -6, 6,\n  main = \"The \\\"polygon\\\" function\"\n)\nplot(0, 0,\n  xlim = c(1, 5), ylim = c(-.5, 4),\n  axes = F,\n  xlab = \"\", ylab = \"\"\n)\nfor (i in 0:4) {\n  for (j in 1:5) {\n    n <- 5 * i + j\n    points(j, i,\n      pch = n,\n      cex = 3\n    )\n    text(j, i - .3, as.character(n))\n  }\n}\n# https://jeroen.github.io/uros2018/#23\nplot.new()\nplot.window(xlim = c(0, 100), ylim = c(0, 100))\npolygon(c(10, 40, 80), c(10, 80, 40), col = \"hotpink\")\ntext(40, 90, labels = \"My drawing\", col = \"navyblue\", cex = 3)\nsymbols(c(70, 80, 90), c(20, 50, 80),\n  circles = c(10, 20, 10),\n  bg = c(\"#4285f4\", \"#EA4335\", \"red\"), add = TRUE, lty = \"dashed\"\n)\ny <- x <- 1:4\nplot(x, y, ann = F, col = \"blue\", pch = 16)\ntext(x, y,\n  labels = c(\"1st\", \"2nd\", \"3rd\", \"4th\"),\n  col = \"red\", pos = c(3, 4, 4, 1), offset = 0.6\n)\nahat <- \"sigma\"\n# title(substitute(hat(a) == ahat, list(ahat = ahat)))\ntitle(bquote(hat(a) == .(ahat)))"},{"path":"chap-graphics-foundations.html","id":"base-lines","chapter":"第 10 章 图形基础","heading":"10.1.3 参考线","text":"矩形网格线是用做背景参考线的，常常是淡灰色的细密虚线，plot 函数的 panel.first 参数和 grid 函数常用来画这种参考线\n图 10.13: 添加背景参考线\n","code":"\n# modified from https://yihui.name/cn/2018/02/cohen-s-d/\nn <- 30 # 样本量（只是一个例子）\nx <- seq(0, 12, 0.01)\npar(mar = c(4, 4, 0.2, 0.1))\nplot(x / sqrt(n), 2 * (1 - pt(x, n - 1)),\n  xlab = expression(d = x / sqrt(n)),\n  type = \"l\", panel.first = grid()\n)\nabline(v = c(0.01, 0.2, 0.5, 0.8, 1.2, 2), lty = 2)"},{"path":"chap-graphics-foundations.html","id":"base-axis","chapter":"第 10 章 图形基础","heading":"10.1.4 坐标轴","text":"图形控制参数默认设置下 par 通常的一幅图形，改变坐标轴标签是很简单的改变坐标轴标签和标题使用 axis 函数可以更加精细地控制坐标轴指定刻度标签的内容控制刻度线和轴线和刻度标签还可以把 box 移除，绘图区域的边框去掉，只保留坐标轴\n图 10.14: 两个 Y 轴\n调整坐标轴标签的距离\n图 10.15: gap.axis用法\n旋转坐标轴标签旋转坐标抽标签的例子来自手册《R FAQ》的第7章第27个问题 [12]，在基础图形中，旋转坐标轴标签需要 text() 而不是 mtext()，因为后者不支持par(\"srt\")\n图 10.16: 旋转坐标轴标签\nsrt = 45 表示文本旋转角度， xpd = TRUE 允许文本越出绘图区域，adj = 1 place right end text tick marks；can adjust value 0.5 offset required move axis labels relative x axis. 详细地参考 [13]","code":"\nx <- 1:100\ny <- runif(100, -2, 2)\nplot(x, y)\nplot(x, y, xlab = \"Index\", ylab = \"Uniform draws\")\nop <- par(no.readonly = TRUE) # 保存默认的 par 设置\npar(cex.lab = 1.5, cex.axis = 1.3)\nplot(x, y, xlab = \"Index\", ylab = \"Uniform draws\")\n\n# 设置更大的坐标轴标签内容\npar(mar = c(6, 6, 3, 3), cex.axis = 1.5, cex.lab = 2)\nplot(x, y, xlab = \"Index\", ylab = \"Uniform draws\")\npar(op) # 恢复默认的 par 设置\nplot(x, y, xaxt = \"n\") # 去掉 x 轴\naxis(side = 1, at = c(5, 50, 100)) # 添加指定的刻度标签\nplot(x, y, yaxt = \"n\")\naxis(side = 2, at = c(-2, 0, 2), labels = c(\"Small\", \"Medium\", \"Big\"))\nplot(x, y)\naxis(side = 3, at = c(5, 25, 75), lwd = 4, lwd.ticks = 2, col.ticks = \"red\")\nplot(x, y, bty = \"n\", xaxt = \"n\", yaxt = \"n\")\naxis(side = 1, at = seq(0, 100, 20), lwd = 3)\naxis(side = 2, at = seq(-2, 2, 2), lwd = 3)\n# 双Y轴\nN <- 200\nx <- seq(-4, 4, length = N)\ny1 <- sin(x)\ny2 <- cos(x)\nop <- par(mar = c(5, 4, 4, 4)) # Add some space in the right margin\n# The default is c(5,4,4,2) + .1\nxlim <- range(x)\nylim <- c(-1.1, 1.1)\nplot(x, y1,\n  col = \"blue\", type = \"l\",\n  xlim = xlim, ylim = ylim,\n  axes = F, xlab = \"\", ylab = \"\", main = \"Title\"\n)\naxis(1)\naxis(2, col = \"blue\")\npar(new = TRUE)\nplot(x, y2,\n  col = \"red\", type = \"l\",\n  xlim = xlim, ylim = ylim,\n  axes = F, xlab = \"\", ylab = \"\", main = \"\"\n)\naxis(4, col = \"red\")\nmtext(\"First Y axis\", 2, line = 2, col = \"blue\", cex = 1.2)\nmtext(\"Second Y axis\", 4, line = 2, col = \"red\", cex = 1.2)\n# 1,2,3,4 分别代表下左上右四个位置\n## Changing default gap between labels:\nplot(c(0, 100), c(0, 50), type = \"n\", axes = FALSE, ann = FALSE)\ntitle(quote(\"axis(1, .., gap.axis = f),\" ~ ~ f >= 0))\naxis(2, at = 5 * (0:10), las = 1, gap.axis = 1 / 4)\ngaps <- c(4, 2, 1, 1 / 2, 1 / 4, 0.1, 0)\nchG <- paste0(\n  ifelse(gaps == 1, \"default:  \", \"\"),\n  \"gap.axis=\", formatC(gaps)\n)\njj <- seq_along(gaps)\nlinG <- -2.5 * (jj - 1)\nfor (j in jj) {\n  isD <- gaps[j] == 1 # is default\n  axis(1,\n    at = 5 * (0:20), gap.axis = gaps[j], padj = -1, line = linG[j],\n    col.axis = if (isD) \"forest green\" else 1, font.axis = 1 + isD\n  )\n}\nmtext(chG,\n  side = 1, padj = -1, line = linG - 1 / 2, cex = 3 / 4,\n  col = ifelse(gaps == 1, \"forest green\", \"blue3\")\n)\n## now shrink the window (in x- and y-direction) and observe the axis labels drawn\n# Rotated axis labels in R plots\n# https://menugget.blogspot.com/2014/08/rotated-axis-labels-in-r-plots.html\n# Example data\ntmin <- as.Date(\"2000-01-01\")\ntmax <- as.Date(\"2001-01-01\")\ntlab <- seq(tmin, tmax, by = \"month\")\nlab <- format(tlab, format = \"%Y-%b\")\nset.seed(111)\nx <- seq(tmin, tmax, length.out = 100)\ny <- cumsum(rnorm(100))\n\n# Plot\n# png(\"plot_w_rotated_axis_labels.png\", height = 3,\n#     width = 6, units = \"in\", res = 300)\nop <- par(mar = c(6, 4, 1, 1))\nplot(x, y, t = \"l\", xaxt = \"n\", xlab = \"\")\naxis(1, at = tlab, labels = FALSE)\ntext(\n  x = tlab, y = par()$usr[3] - 0.1 * (par()$usr[4] - par()$usr[3]),\n  labels = lab, srt = 45, adj = 1, xpd = TRUE\n)\npar(op)\n# dev.off()\n## Increase bottom margin to make room for rotated labels\npar(mar = c(5, 4, .5, 2) + 0.1)\n## Create plot with no x axis and no x axis label\nplot(1:8, xaxt = \"n\", xlab = \"\")\n## Set up x axis with tick marks alone\naxis(1, labels = FALSE)\n## Create some text labels\nlabels <- paste(\"Label\", 1:8, sep = \" \")\n## Plot x axis labels at default tick marks\ntext(1:8, par(\"usr\")[3] - 0.5,\n  srt = 45, adj = 1,\n  labels = labels, xpd = TRUE\n)\n## Plot x axis label at line 6 (of 7)\nmtext(side = 1, text = \"X Axis Label\", line = 4)"},{"path":"chap-graphics-foundations.html","id":"base-tick","chapter":"第 10 章 图形基础","heading":"10.1.5 刻度线","text":"通过 par 或 axis 函数实现刻度线的精细操作，tcl 控制刻度线的长度，正值让刻度画在绘图区域内，负值正好相反，画在外面，mgp 参数有三个值，第一个值控制绘图区域和坐标轴标题之间的行数，第二个是绘图区域与坐标轴标签的行数，第三个绘图区域与轴线的行数，行数表示间距","code":"\npar(tcl = 0.4, mgp = c(1.5, 0, 0))\nplot(x, y)\n# 又一个例子\npar(op)\nplot(x, y, xaxt = \"n\", yaxt = \"n\", xlab = \"\", ylab = \"\")\naxis(side = 1, at = seq(5, 95, 30), tcl = 0.4, lwd.ticks = 3, mgp = c(0, 0.5, 0))\nmtext(side = 1, text = \"X axis\", line = 1.5) \n# mtext 设置坐标轴标签\naxis(side = 2, at = seq(-2, 2, 2), tcl = 0.3, lwd.ticks = 3, col.ticks = \"orange\", mgp = c(0, 0, 2))\nmtext(side = 2, text = \"Numbers taken randomly\", line = 2.2)"},{"path":"chap-graphics-foundations.html","id":"base-title","chapter":"第 10 章 图形基础","heading":"10.1.6 标题","text":"添加多个标题\n图 10.17: 图标题/子标题 x轴标题/子标题\n","code":"\nN <- 200\nx <- runif(N, -4, 4)\ny <- sin(x) + .5 * rnorm(N)\nplot(x, y, xlab = \"\", ylab = \"\", main = \"\")\nmtext(\"Subtitle\", 3, line = .8)\nmtext(\"Title\", 3, line = 2, cex = 1.5)\nmtext(\"X axis\", 1, line = 2.5, cex = 1.5)\nmtext(\"X axis subtitle\", 1, line = 3.7)"},{"path":"chap-graphics-foundations.html","id":"base-annotation","chapter":"第 10 章 图形基础","heading":"10.1.7 注释","text":"数学符号注释，图10.18 自定义坐标轴 [14]。\n图 10.18: 创建自定义的坐标轴和刻度标签\n在标题中添加数学公式\n图 10.19: 标题含有数学公式\n修改参数使用 substitute 函数批量生成\n图 10.20: 批量生成函数图形\n\n图 10.21: 批量生成函数图形\n\n图 10.22: 批量生成函数图形\n\n图 10.23: 批量生成函数图形\n基础绘图函数，如 plot 标签 xlab 支持 Unicode 代码表示的希腊字母，常用字母表备查，公式环境下，也可以用在绘图中表 10.1:  希腊字母表表 10.2:  数字上下标其它字母，请查看 Unicode 字母表","code":"\n# 自定义坐标轴\nplot(c(1, 1e6), c(-pi, pi),\n  type = \"n\",\n  axes = FALSE, ann = FALSE, log = \"x\"\n)\naxis(1,\n  at = c(1, 1e2, 1e4, 1e6),\n  labels = expression(1, 10^2, 10^4, 10^6)\n)\naxis(2,\n  at = c(-pi, -pi / 2, 0, pi / 2, pi),\n  labels = expression(-pi, -pi / 2, 0, pi / 2, pi)\n)\ntext(1e3, 0, expression(italic(\"Customized Axes\")))\nbox()\nx <- seq(-5, 5, length = 200)\ny <- sqrt(1 + x^2)\nplot(y ~ x,\n  type = \"l\",\n  ylab = expression(sqrt(1 + x^2))\n)\ntitle(main = expression(\n  \"graph of the function f\"(x) == sqrt(1 + x^2)\n))\nx <- seq(-5, 5, length = 200)\nfor (i in 1:4) { # 画四个图\n  y <- sqrt(i + x^2)\n  plot(y ~ x,\n    type = \"l\",\n    ylim = c(0, 6),\n    ylab = substitute(\n      expression(sqrt(i + x^2)),\n      list(i = i)\n    )\n  )\n  title(main = substitute(\n    \"graph of the function f\"(x) == sqrt(i + x^2),\n    list(i = i)\n  ))\n}"},{"path":"chap-graphics-foundations.html","id":"base-legend","chapter":"第 10 章 图形基础","heading":"10.1.8 图例","text":"\n图 10.24: 三角函数添加图例\n\n图 10.25: 设置图例的位置\n\n图 10.26: insert 函数微调图例位置\n\n图 10.27: 将图例放在绘图区域外面\nHmisc 包的 labcurve 函数可以在曲线上放置名称，而不是遥远的图例上","code":"\nx <- seq(-6, 6, length = 200)\ny <- sin(x)\nz <- cos(x)\nplot(y ~ x,\n  type = \"l\", lwd = 3,\n  ylab = \"\", xlab = \"angle\", main = \"Trigonometric functions\"\n)\nabline(h = 0, lty = 3)\nabline(v = 0, lty = 3)\nlines(z ~ x, type = \"l\", lwd = 3, col = \"red\")\nlegend(-6, -1,\n  yjust = 0,\n  c(\"Sine\", \"Cosine\"),\n  lwd = 3, lty = 1, col = c(par(\"fg\"), \"red\")\n)\nxmin <- par(\"usr\")[1]\nxmax <- par(\"usr\")[2]\nymin <- par(\"usr\")[3]\nymax <- par(\"usr\")[4]\n\nplot(y ~ x,\n  type = \"l\", lwd = 3,\n  ylab = \"\", xlab = \"angle\", main = \"Trigonometric functions\"\n)\nabline(h = 0, lty = 3)\nabline(v = 0, lty = 3)\nlines(z ~ x, type = \"l\", lwd = 3, col = \"red\")\nlegend(\"bottomleft\",\n  c(\"Sine\", \"Cosine\"),\n  lwd = 3, lty = 1, col = c(par(\"fg\"), \"red\")\n)\nplot(y ~ x,\n  type = \"l\", lwd = 3,\n  ylab = \"\", xlab = \"angle\", main = \"Trigonometric functions\"\n)\nabline(h = 0, lty = 3)\nabline(v = 0, lty = 3)\nlines(z ~ x, type = \"l\", lwd = 3, col = \"red\")\nlegend(\"bottomleft\",\n  c(\"Sine\", \"Cosine\"),\n  inset = c(.03, .03),\n  lwd = 3, lty = 1, col = c(par(\"fg\"), \"red\")\n)\nop <- par(no.readonly = TRUE)\nplot(y ~ x,\n  type = \"l\", lwd = 3,\n  ylab = \"\", xlab = \"angle\", main = \"Trigonometric functions\"\n)\nabline(h = 0, lty = 3)\nabline(v = 0, lty = 3)\nlines(z ~ x, type = \"l\", lwd = 3, col = \"red\")\npar(xpd = TRUE) # Do not clip to the drawing area 关键一行/允许出界\nlambda <- .025\nlegend(par(\"usr\")[1],\n  (1 + lambda) * par(\"usr\")[4] - lambda * par(\"usr\")[3],\n  c(\"Sine\", \"Cosine\"),\n  xjust = 0, yjust = 0,\n  lwd = 3, lty = 1, col = c(par(\"fg\"), \"red\")\n)\npar(op)"},{"path":"chap-graphics-foundations.html","id":"base-par","chapter":"第 10 章 图形基础","heading":"10.1.9 边空","text":"边空分为内边空和外边空\n图 10.28: 边空\nline 第一行\n图 10.29: 外边空在图的边缘添加文字\npar\n图 10.30: 多图排列共享一个大标题\npar 的 oma 用来设置外边空的大小，默认情形下没有外边空的我们可以自己设置外边空\n图 10.31: 设置外边空放置大标题\n除了内边空还有外边空，内外边空用来放注释说明外边空可以用来放图例坐标轴标签 xlab 和 ylab 的内容很长的时候需要内边空有时候，仅仅增加内边空还不够，坐标轴标签内容甚至可以出现在绘图区域外面，设置 outer = TRUE\n图 10.32: 设置每个子图的边空 mar\n","code":"\nN <- 200\nx <- runif(N, -4, 4)\ny <- sin(x) + .5 * rnorm(N)\nplot(x, y,\n  xlab = \"\", ylab = \"\",\n  main = paste(\n    \"The \\\"mtext\\\" function\",\n    paste(rep(\" \", 60), collapse = \"\")\n  )\n)\nfor (i in seq(from = 0, to = 1, by = 1)) {\n  mtext(paste(\"Line\", i), 3, line = i)\n}\n# 多图排列/分屏 page 47\n# 最常用的是 par mfrow mfcol分别按行/列放置图形\nop <- par(\n  mfrow = c(2, 2),\n  oma = c(0, 0, 4, 0) # Outer margins\n)\nfor (i in 1:4) {\n  plot(runif(20), runif(20),\n    main = paste(\"random plot (\", i, \")\", sep = \"\")\n  )\n}\npar(op)\nmtext(\"Four plots, without enough room for this title\",\n  side = 3, font = 2, cex = 1.5, col = \"red\"\n) # 总/大标题放不下\npar()$oma## [1] 0 0 0 0\nop <- par(\n  mfrow = c(2, 2),\n  oma = c(0, 0, 3, 0) # Outer margins\n)\nfor (i in 1:4) {\n  plot(runif(20), runif(20),\n    main = paste(\"random plot (\", i, \")\", sep = \"\")\n  )\n}\npar(op)\nmtext(\"Four plots, with some room for this title\",\n  side = 3, line = 1.5, font = 1, cex = 1.5, col = \"red\"\n)\nop <- par(no.readonly = TRUE)\npar(oma = c(2, 2, 2, 2))\nplot(1, 1, type = \"n\", xlab = \"\", ylab = \"\", xaxt = \"n\", yaxt = \"n\")\nfor (side in 1:4) {\n  inner <- round(par()$mar[side], 0) - 1\n  for (line in 0:inner) {\n    mtext(text = paste0(\"Inner line \", line), side = side, line = line)\n  }\n  outer <- round(par()$oma[side], 0) - 1\n  for (line in 0:inner) {\n    mtext(text = paste0(\"Outer line \", line), side = side, line = line, outer = TRUE)\n  }\n}\nset.seed(1234)\nx <- runif(10)\ny <- runif(10)\ncols <- rep(hcl.colors(5), each = 2)\nop <- par(oma = c(2, 2, 0, 4), mar = c(3, 3, 2, 0), mfrow = c(2, 2), pch = 16)\nfor (i in 1:4) {\n  plot(x, y, col = cols, ylab = \"\", xlab = \"\")\n}\nmtext(text = \"A common x-axis label\", side = 1, line = 0, outer = TRUE)\nmtext(text = \"A common y-axis label\", side = 2, line = 0, outer = TRUE)\nlegend(\n  x = 1, y = 1.2, legend = LETTERS[1:5],\n  col = unique(cols), pch = 16, bty = \"n\", xpd = NA\n)\npar(op)\npar(cex.lab = 1.7)\nplot(1, 1,\n  ylab = \"A very very long axis title\\nthat need special care\",\n  xlab = \"\", type = \"n\"\n)\n\n# 增加内边空的大小\npar(mar = c(5, 7, 4, 2))\nplot(1, 1,\n  ylab = \"A very very long axis title\\nthat need special care\",\n  xlab = \"\", type = \"n\"\n)\npar(oma = c(0, 4, 0, 0))\nplot(1, 1, ylab = \"\", xlab = \"\", type = \"n\")\nmtext(\n  text = \"A very very long axis title\\nthat need special care\",\n  side = 2, line = 0, outer = TRUE, cex = 1.7\n)\nop <- par(\n  mfrow = c(2, 2),\n  oma = c(0, 0, 3, 0),\n  mar = c(3, 3, 4, 1) + .1 # Margins\n)\nfor (i in 1:4) {\n  plot(runif(20), runif(20),\n    xlab = \"\", ylab = \"\",\n    main = paste(\"random plot (\", i, \")\", sep = \"\")\n  )\n}\npar(op)\nmtext(\"Title\",\n  side = 3, line = 1.5, font = 2, cex = 2, col = \"red\"\n)"},{"path":"chap-graphics-foundations.html","id":"base-layer","chapter":"第 10 章 图形基础","heading":"10.1.10 图层","text":"覆盖图形 add = T par(new=TRUE)\n图 10.33: 添加图层\n","code":"\nplot(runif(5), runif(5),\n  xlim = c(0, 1), ylim = c(0, 1)\n)\npoints(runif(5), runif(5),\n  col = \"#EA4335\", pch = 16, cex = 3\n)\nlines(runif(5), runif(5), col = \"red\")\nsegments(runif(5), runif(5), runif(5), runif(5),\n  col = \"blue\"\n)\ntitle(main = \"Overlaying points, segments, lines...\")"},{"path":"chap-graphics-foundations.html","id":"base-layout","chapter":"第 10 章 图形基础","heading":"10.1.11 布局","text":"layout 函数布局， 绘制复杂组合图形\n图 10.34: 更加复杂的组合图形\n","code":"\nop <- par(oma = c(0, 0, 3, 0))\nlayout(matrix(c(\n  1, 1, 1,\n  2, 3, 4,\n  2, 3, 4\n), nr = 3, byrow = TRUE))\nhist(rnorm(n), col = \"light blue\")\nhist(rnorm(n), col = \"light blue\")\nhist(rnorm(n), col = \"light blue\")\nhist(rnorm(n), col = \"light blue\")\nmtext(\"The \\\"layout\\\" function\",\n  side = 3, outer = TRUE,\n  font = 2, cex = 1.2\n)"},{"path":"chap-graphics-foundations.html","id":"base-combine","chapter":"第 10 章 图形基础","heading":"10.1.12 组合","text":"par 之 fig 参数很神奇，使得多个图可以叠加在一起，它接受一个数值向量c(x1, x2, y1, y2) ，是图形设备显示区域中的绘图区域的(NDC, normalized device coordinates)坐标。\n图 10.35: 多图叠加\nfig 参数控制图形的位置，用来绘制组合图形\n图 10.36: 组合图形\n","code":"\nplot(1:12,\n  type = \"b\", main = \"'fg' : axes, ticks and box in gray\",\n  fg = gray(0.7), bty = \"7\", sub = R.version.string\n)\npar(fig = c(1, 6, 5, 10) / 10, new = T)\nplot(6:10,\n  type = \"b\", main = \"\",\n  fg = gray(0.7), bty = \"7\", xlab = R.version.string\n)\nn <- 1000\nx <- rt(n, df = 10)\nhist(x,\n  col = \"light blue\",\n  probability = \"TRUE\", main = \"\",\n  ylim = c(0, 1.2 * max(density(x)$y))\n)\nlines(density(x),\n  col = \"red\",\n  lwd = 3\n)\nop <- par(\n  fig = c(.02, .4, .5, .98),\n  new = TRUE\n)\nqqnorm(x,\n  xlab = \"\", ylab = \"\", main = \"\",\n  axes = FALSE\n)\nqqline(x, col = \"red\", lwd = 2)\nbox(lwd = 2)\npar(op)"},{"path":"chap-graphics-foundations.html","id":"base-screen","chapter":"第 10 章 图形基础","heading":"10.1.13 分屏","text":"split.screen 分屏组合\n图 10.37: 分屏\n","code":"\nrandom.plot <- function() {\n  N <- 200\n  f <- sample(\n    list(\n      rnorm,\n      function(x) {\n        rt(x, df = 2)\n      },\n      rlnorm,\n      runif\n    ),\n    1\n  ) [[1]]\n  x <- f(N)\n  hist(x, col = \"lightblue\", main = \"\", xlab = \"\", ylab = \"\", axes = F)\n  axis(1)\n}\nop <- par(bg = \"white\", mar = c(2.5, 2, 1, 2))\nsplit.screen(c(2, 1))## [1] 1 2\nsplit.screen(c(1, 3), screen = 2)## [1] 3 4 5\nscreen(1)\nrandom.plot()\n# screen(2); random.plot() # Screen 2 was split into three screens: 3, 4, 5\nscreen(3)\nrandom.plot()\nscreen(4)\nrandom.plot()\nscreen(5)\nrandom.plot()\nclose.screen(all = TRUE)\npar(op)"},{"path":"chap-graphics-foundations.html","id":"identify-locator","chapter":"第 10 章 图形基础","heading":"10.1.14 交互","text":"辅助绘图 identify locator","code":""},{"path":"chap-graphics-foundations.html","id":"base-graphics","chapter":"第 10 章 图形基础","heading":"10.2 基础统计图形","text":"按图的类型划分，最后在小结部分给出各图适用的数据类型根据数据类型划分： 对于一元数据，可用什么图来描述；多元数据呢，连续数据和离散数据（分类数据）先找一个不重不漏的划分，指导原则是根据数据类型选择图，根据探索到的数据中的规律，选择图其它 assocplot fourfoldplot sunflowerplot","code":""},{"path":"chap-graphics-foundations.html","id":"plot-bar","chapter":"第 10 章 图形基础","heading":"10.2.1 条形图","text":"条形图简单条形图\n图 10.38: 条形图\n简单柱形图\n图 10.39: 柱形图\n复合条形图\n图 10.40: 复合条形图\n堆积条形图\n图 10.41: 堆积条形图\n堆积条形图 spineplot简单条形图Titanic 数据集是 table 数据类型简单条形图复合条形图堆积条形图","code":"\ndata(diamonds, package = \"ggplot2\") # 加载数据\npar(mar = c(2, 5, 1, 1))\nbarCenters <- barplot(table(diamonds$cut),\n  col = \"lightblue\", axes = FALSE,\n  axisnames = FALSE, horiz = TRUE, border = \"white\"\n)\ntext(\n  y = barCenters, x = par(\"usr\")[3],\n  adj = 1, labels = names(table(diamonds$cut)), xpd = TRUE\n)\naxis(1,\n  labels = seq(0, 25000, by = 5000), at = seq(0, 25000, by = 5000),\n  las = 1, col = \"gray\"\n)\ngrid()\nset.seed(123456)\nbarPois <- table(stats::rpois(1000, lambda = 5))\nplot(barPois, col = \"lightblue\", type = \"h\", lwd = 10, main = \"\")\nbox(col = \"gray\")\npar(mar = c(4.1, 2.1, 0.5, 4.5))\nbarplot(VADeaths,\n  border = \"white\", horiz = FALSE, col = hcl.colors(5),\n  legend.text = rownames(VADeaths), xpd = TRUE, beside = TRUE,\n  cex.names = 0.9,\n  args.legend = list(\n    x = \"right\", border = \"white\", title = \"Age\",\n    box.col = NA, horiz = FALSE, inset = c(-.2, 0),\n    xpd = TRUE\n  ),\n  panel.first = grid(nx = 0, ny = 7)\n)\npar(mar = c(4.1, 2.1, 0.5, 4.5))\nbarplot(VADeaths,\n  border = \"white\", horiz = FALSE, col = hcl.colors(5),\n  legend.text = rownames(VADeaths), xpd = TRUE, beside = FALSE,\n  cex.names = 0.9,\n  args.legend = list(\n    x = \"right\", border = \"white\", title = \"Age\",\n    box.col = NA, horiz = FALSE, inset = c(-.2, 0),\n    xpd = TRUE\n  ),\n  panel.first = grid(nx = 0, ny = 4)\n)\nbarplot(\n  data = BOD, demand ~ Time, ylim = c(0, 20),\n  border = \"white\", horiz = FALSE, col = hcl.colors(1)\n)\npg_mean <- aggregate(weight ~ group, data = PlantGrowth, mean)\nbarplot(\n  data = pg_mean, weight ~ group,\n  border = \"white\", horiz = FALSE, col = hcl.colors(3)\n)\nbarplot(Freq ~ Class + Survived,\n  data = Titanic,\n  subset = Age == \"Adult\" & Sex == \"Male\",\n  beside = TRUE,\n  border = \"white\", horiz = FALSE, col = hcl.colors(4),\n  args.legend = list(\n    border = \"white\", title = \"Class\",\n    box.col = NA, horiz = FALSE,\n    xpd = TRUE\n  ),\n  ylab = \"# {passengers}\", legend = TRUE\n)\nbarplot(Freq ~ Class + Survived,\n  data = Titanic,\n  subset = Age == \"Adult\" & Sex == \"Male\",\n  border = \"white\", horiz = FALSE, col = hcl.colors(4),\n  args.legend = list(\n    border = \"white\", title = \"Class\",\n    box.col = NA, horiz = FALSE,\n    xpd = TRUE\n  ),\n  ylab = \"# {passengers}\", legend = TRUE\n)"},{"path":"chap-graphics-foundations.html","id":"plot-hist","chapter":"第 10 章 图形基础","heading":"10.2.2 直方图","text":"\n图 10.42: 直方图\n\n图 10.43: 老忠实泉间歇性喷水的时间间隔分布\n\n图 10.44: 概率密度分布\n直方图有很多花样的，添加阴影线，angle 控制倾斜的角度\n图 10.45: density 数值越大阴影线越密\n","code":"\nset.seed(1234)\nn <- 2^24\nx <- runif(n, 0, 1)\ndelta <- 0.01\nlen <- diff(c(0, which(x < delta), n + 1)) - 1\nylim <- seq(0, 1800, by = 300)\nxlim <- seq(0, 100, by = 20)\np <- hist(len[len < 101], breaks = -1:100 + 0.5, plot = FALSE)\nplot(p, ann = FALSE, axes = FALSE, col = \"lightblue\", border = \"white\", main = \"\")\naxis(1, labels = xlim, at = xlim, las = 1) # x 轴\naxis(2, labels = ylim, at = ylim, las = 0) # y 轴\nbox(col = \"gray\")\nwith(faithful, plot(eruptions ~ waiting, pch = 16))\nwith(faithful, hist(waiting,\n  main = \"Time between Old Faithful eruptions\",\n  xlab = \"Minutes\", ylab = \"\",\n  cex.main = 1.5, cex.lab = 1.5, cex.axis = 1.4\n))\nwith(data = faithful, {\n  hist(eruptions, seq(1.6, 5.2, 0.2),\n    prob = TRUE,\n    main = \"\", col = \"lightblue\", border = \"white\"\n  )\n  lines(density(eruptions, bw = 0.1), col = \"#EA4335\")\n  rug(eruptions, col = \"#EA4335\") # 添加数据点\n})\nhist(longley$Unemployed,\n  probability = TRUE,\n  col = \"light blue\", main = \"\"\n)\n# 添加密度估计\nlines(density(longley$Unemployed),\n  col = \"red\",\n  lwd = 3\n)\n# hist(longley$Unemployed, density = 1, angle = 45)\n# hist(longley$Unemployed, density = 3, angle = 15)\n# hist(longley$Unemployed, density = 1, angle = 15)\nhist(longley$Unemployed, density = 3, angle = 45, main = \"\")"},{"path":"chap-graphics-foundations.html","id":"plot-density","chapter":"第 10 章 图形基础","heading":"10.2.3 密度图","text":"","code":"\ndata(galaxies, package = \"MASS\")\ngalaxies <- galaxies / 1000\n# Bandwidth Selection by Pilot Estimation of Derivatives\nc(MASS::width.SJ(galaxies, method = \"dpi\"), MASS::width.SJ(galaxies))## [1] 3.256151 2.566423\nplot(\n  x = c(5, 40), y = c(0, 0.2), type = \"n\", bty = \"l\",\n  xlab = \"velocity of galaxy (km/s)\", ylab = \"density\"\n)\nrug(galaxies)\nlines(density(galaxies, width = 3.25, n = 200), col = \"blue\", lty = 1)\nlines(density(galaxies, width = 2.56, n = 200), col = \"red\", lty = 3)\nx <- seq(from = 100, to = 174, by = 0.5)\ny1 <- dnorm(x, mean = 145, sd = 9)\ny2 <- dnorm(x, mean = 128, sd = 8)\nplot(x, y1,\n  type = \"l\", lwd = 2, col = \"firebrick3\",\n main = \"Systolic Blood Pressure Before and After Treatment\",\n  xlab = \"Systolic Blood Pressure (mmHg)\",\n  ylab = \"Frequency\", yaxt = \"n\",\n  xlim = c(100, 175), ylim = c(0, 0.05)\n)\n\nlines(x, y2, col = \"dodgerblue4\")\npolygon(c(117, x, 175), c(0, y2, 0),\n  col = \"dodgerblue4\",\n  border = \"white\"\n)\n\npolygon(c(100, x, 175), c(0, y1, 0),\n  col = \"firebrick3\",\n  border = \"white\"\n)\n\naxis(2,\n  at = seq(from = 0, to = 0.05, length.out = 8),\n  labels = seq(from = 0, to = 175, by = 25), las = 1\n)\n\ntext(x = 100, y = 0.0445, \"Pre-Treatment BP\", col = \"dodgerblue4\", cex = 0.9, pos = 4)\ntext(x = 100, y = 0.0395, \"Post-Treatment BP\", col = \"firebrick3\", cex = 0.9, pos = 4)\npoints(100, 0.0445, pch = 15, col = \"dodgerblue4\")\npoints(100, 0.0395, pch = 15, col = \"firebrick3\")\nabline(v = c(145, 128), lwd = 2, lty = 2, col = 'gray')\ndays <- abs(rnorm(1000, 80, 125))\nplot(density(days, from = 0),\n  main = \"Density plot\",\n  xlab = \"Number of days since trial started\"\n)\nplot(density(days, from = 0, to = 180, adjust = 0.2),\n  main = \"Density plot - Up to 180 days (86% of data)\",\n  xlab = \"Number of days since trial started\"\n)\nlibrary(survival)\nsurv.days <- Surv(days)\nsurv.fit <- survfit(surv.days ~ 1)\nplot(surv.fit,\n  main = \"Kaplan-Meier estimate with 95% confidence bounds (86% of data)\",\n  xlab = \"Days since trial started\",\n  xlim = c(0, 180),\n  ylab = \"Survival function\"\n)\ngrid(20, 10, lwd = 2)"},{"path":"chap-graphics-foundations.html","id":"plot-ecdf","chapter":"第 10 章 图形基础","heading":"10.2.4 经验图","text":"\n图 10.46: 累积经验分布图\n","code":"\nwith(data = faithful, {\n  long <- eruptions[eruptions > 3]\n  plot(ecdf(long), do.points = FALSE, verticals = TRUE, main = \"\")\n  x <- seq(3, 5.4, 0.01)\n  lines(x, pnorm(x, mean = mean(long), sd = sqrt(var(long))), lty = 3)\n})"},{"path":"chap-graphics-foundations.html","id":"plot-qqnorm","chapter":"第 10 章 图形基础","heading":"10.2.5 QQ 图","text":"","code":"\nwith(data = faithful, {\n  long <- eruptions[eruptions > 3]\n  par(pty = \"s\") # arrange for a square figure region\n  qqnorm(long, main = \"\")\n  qqline(long)\n})"},{"path":"chap-graphics-foundations.html","id":"plot-ts","chapter":"第 10 章 图形基础","heading":"10.2.6 时序图","text":"时序图最适合用来描述股价走势\n图 10.47: 1991–1998年间主要欧洲股票市场日闭市价格指数图\n德国 DAX (Ibis), Switzerland SMI, 法国 CAC 和 英国 FTSE\n","code":"\nmatplot(time(EuStockMarkets), EuStockMarkets,\n  main = \"\",\n  xlab = \"Date\", ylab = \"closing prices\",\n  pch = 17, type = \"l\", col = 1:4\n)\nlegend(\"topleft\", colnames(EuStockMarkets), pch = 17, lty = 1, col = 1:4)"},{"path":"chap-graphics-foundations.html","id":"plot-pie","chapter":"第 10 章 图形基础","heading":"10.2.7 饼图","text":"clockwise 参数","code":"\npie.sales <- c(0.12, 0.3, 0.26, 0.16, 0.04, 0.12)\nnames(pie.sales) <- c(\n  \"Blueberry\", \"Cherry\",\n  \"Apple\", \"Boston Cream\", \"Other\", \"Vanilla Cream\"\n)\npie(pie.sales, clockwise = TRUE, main = \"\")\nsegments(0, 0, 0, 1, col = \"red\", lwd = 2)\ntext(0, 1, \"init.angle = 90\", col = \"red\")"},{"path":"chap-graphics-foundations.html","id":"plot-stem-leaf","chapter":"第 10 章 图形基础","heading":"10.2.8 茎叶图","text":"","code":"\nstem(longley$Unemployed)## \n##   The decimal point is 2 digit(s) to the right of the |\n## \n##   1 | 99\n##   2 | 134899\n##   3 | 46789\n##   4 | 078"},{"path":"chap-graphics-foundations.html","id":"plot-scatter","chapter":"第 10 章 图形基础","heading":"10.2.9 散点图","text":"在一维空间上，绘制散点图，其实是在看散点的疏密程度随坐标轴的变化\n图 10.48: 一维散点图\n气泡图是二维散点图的一种变体，气泡的大小可以用来描述第三个变量，下面以数据集 topo 为例展示气泡图topo 是空间地形数据集，包含有52行3列，数据点是310平方英尺范围内的海拔高度数据，x 坐标每单位50英尺，y 坐标单位同 x 坐标，海拔高度 z 单位是英尺\n图 10.49: 地形图之海拔高度\n散点图也适合分类数据的展示，在图中用不同颜色或符号标记数据点所属类别，即在普通散点图的基础上添加一分类变量的描述\n图 10.50: 分类散点图\niris 数据\n图 10.51: 分类散点图\n分组散点图和平滑有时为了实现特定的目的，需要高亮其中某些点，按类别或者因子变量分组绘制散点图，这里继续采用 stripchart 函数绘制二维散点图10.52，由左图可知，函数 stripchart 提供的参数 pch 不接受向量，实际只是取了前三个值 16 16 17 对应于 Species 的三类，关键是高亮的分界点是有区分意义的\n图 10.52: 高亮图中部分散点\n如果存在大量散点densCols 函数根据点的局部密度生成颜色，密度估计采用核平滑法，由 KernSmooth 包的 bkde2D 函数实现。参数 colramp 传递一个函数，colorRampPalette 根据给定的几种颜色生成函数，参数 bandwidth 实际上是传给 bkde2D 函数\n图 10.53: 根据点的密度生成颜色\n气泡图也是散点图的一种\n图 10.54: 气泡图\n气泡图除了par(new=TRUE)设置外，有些函数本身就具有 add 选项","code":"\nstripchart(longley$Unemployed,\n  method = \"jitter\",\n  jitter = 0.1, pch = 16, col = \"lightblue\"\n)\nstripchart(longley$Unemployed,\n  method = \"overplot\",\n  pch = 16, col = \"lightblue\"\n)\n# 加载数据集\ndata(topo, package = \"MASS\")\n# 查看数据集\nstr(topo)## 'data.frame':    52 obs. of  3 variables:\n##  $ x: num  0.3 1.4 2.4 3.6 5.7 1.6 2.9 3.4 3.4 4.8 ...\n##  $ y: num  6.1 6.2 6.1 6.2 6.2 5.2 5.1 5.3 5.7 5.6 ...\n##  $ z: int  870 793 755 690 800 800 730 728 710 780 ...\nplot(y ~ x,\n  cex = (960 - z) / (960 - 690) * 3, data = topo,\n  xlab = \"X Coordinates\", ylab = \"Y coordinates\"\n)\nplot(mpg ~ hp,\n  data = subset(mtcars, am == 1), pch = 16, col = \"blue\",\n  xlim = c(50, 350), ylim = c(10, 35)\n)\npoints(mpg ~ hp,\n  col = \"red\", pch = 16,\n  data = subset(mtcars, am == 0)\n)\nlegend(300, 35,\n  c(\"1\", \"0\"),\n  title = \"am\",\n  col = c(\"blue\", \"red\"),\n  pch = c(16, 16)\n)\nplot(Sepal.Length ~ Sepal.Width, data = iris, col = Species, pch = 16)\nlegend(\"topright\",\n  legend = unique(iris$Species), box.col = \"gray\",\n  pch = 16, col = unique(iris$Species)\n)\nbox(col = \"gray\")\nlibrary(carData)\nlibrary(car)\nscatterplot(Sepal.Length ~ Sepal.Width,\n  col = c(\"black\", \"red\", \"blue\"), pch = c(16, 16, 16),\n  smooth = TRUE, boxplots = \"xy\", groups = iris$Species,\n  xlab = \"Sepal.Width\", ylab = \"Sepal.Length\", data = iris\n)\ndata(\"iris\")\npch <- rep(16, length(iris$Petal.Length))\npch[which(iris$Petal.Length < 1.4)] <- 17\nstripchart(Petal.Length ~ Species,\n  data = iris,\n  vertical = TRUE, method = \"jitter\",\n  pch = pch\n)\n# 对比一下\nstripchart(Petal.Length ~ Species,\n  data = iris, subset = Petal.Length > 1.4,\n  vertical = TRUE, method = \"jitter\", ylim = c(1, 7),\n  pch = 16\n)\nstripchart(Petal.Length ~ Species,\n  data = iris, subset = Petal.Length < 1.4,\n  vertical = TRUE, method = \"jitter\", add = TRUE,\n  pch = 17, col = \"red\"\n)\ndensCols(x,\n  y = NULL, nbin = 128, bandwidth,\n  colramp = colorRampPalette(blues9[-(1:3)])\n)\nplot(faithful,\n  col = densCols(faithful),\n  pch = 20, panel.first = grid()\n)\nplot(Volume ~ Height,\n  data = trees, pch = 16, cex = Girth / 8,\n  col = rev(terrain.colors(nrow(trees), alpha = .5))\n)\nbox(col = \"gray\")\n# 空白画布\nplot(c(1, 5, 10), c(1, 5, 10), panel.first = grid(10, 10),\n     type = \"n\", axes = FALSE, ann = FALSE)\n# 添加坐标轴\naxis(1, at = seq(10), labels = TRUE)\naxis(2, at = seq(10), labels = TRUE)\npar(new = TRUE) # 在当前图形上添加图形\n# axes 坐标轴上的刻度 \"xaxt\" or \"yaxt\"  ann 坐标轴和标题的标签\nset.seed(1234)\nplot(rnorm(100, 5, 1), rnorm(100, 5, 1),\n  cex = runif(100, 0, 2),\n  col = hcl.colors(4)[rep(seq(4), 100)],\n  bg = paste0(\"gray\", replicate(100, sample(seq(100), 1, replace = TRUE))),\n  axes = FALSE, ann = FALSE, pch = 21, lwd = 2\n)\nlegend(\"top\",\n  legend = paste0(\"class\", seq(4)), col = hcl.colors(4),\n  pt.lwd = 2, pch = 21, box.col = \"gray\", horiz = TRUE\n)\nset.seed(1234)\nplot(dist ~ speed, data = cars, pch = 17, col = \"red\", cex = 1)\nwith(cars, symbols(dist ~ speed,\n  circles = runif(length(speed), 0, 1),\n  pch = 16, inches = .5, add = TRUE\n))\nz <- lm(dist ~ speed, data = cars)\nabline(z, col = \"blue\")\ncurve(tan, from = 0, to = 8 * pi, n = 100, add = TRUE)\nlines(stats::lowess(cars))\npoints(10, 100, pch = 16, cex = 3, col = \"green\")\ntext(10, 80, \"text here\", cex = 3)"},{"path":"chap-graphics-foundations.html","id":"base-jitter","chapter":"第 10 章 图形基础","heading":"10.2.10 抖动图","text":"抖动散点图\n图 10.55: 抖动散点图\n","code":"\nmat <- matrix(1:length(colors()), ncol = 9, byrow = TRUE)\ndf <- data.frame(\n  col = colors(),\n  x = as.integer(cut(1:length(colors()), 9)),\n  y = rep(1:73, 9), stringsAsFactors = FALSE\n)\npar(mar = c(4, 4, 1, 0.1))\nplot(y ~ jitter(x),\n  data = df, col = df$col,\n  pch = 16, main = \"Visualizing colors() split in 9 groups\",\n  xlab = \"Group\",\n  ylab = \"Element of the group (min = 1, max = 73)\",\n  sub = \"x = 3, y = 1 means that it's the 2 * 73 + 1 = 147th color\"\n)"},{"path":"chap-graphics-foundations.html","id":"plot-box","chapter":"第 10 章 图形基础","heading":"10.2.11 箱线图","text":"boxplotdbl: Double Box Plot Two-Axes Correlation. Correlation chart two set (x y) data. Using Quartiles boxplot style. Visualize effect factor.复合箱线图\n图 10.56: 安德森的鸢尾花数据\n箱线图的花样也很多\n图 10.57: 箱线图\nNotched Boxplots真实的情况是这样的","code":"\nwith(data = iris, {\n  op <- par(mfrow = c(2, 2), mar = c(4, 4, 2, .5))\n  plot(Sepal.Length ~ Species)\n  plot(Sepal.Width ~ Species)\n  plot(Petal.Length ~ Species)\n  plot(Petal.Width ~ Species)\n  par(op)\n  mtext(\"Edgar Anderson's Iris Data\", side = 3, line = 4)\n})\ndata(InsectSprays)\npar(mar = c(4, 4, .5, .5))\nboxplot(\n  data = InsectSprays, count ~ spray,\n  col = \"gray\", xlab = \"Spray\", ylab = \"Count\"\n)\n\nboxplot(\n  data = InsectSprays, count ~ spray,\n  col = \"gray\", horizontal = TRUE,\n  las = 1, xlab = \"Count\", ylab = \"Spray\"\n)\nset.seed(1234)\nn <- 8\ng <- gl(n, 100, n * 100) # n水平个数 100是重复次数\nx <- rnorm(n * 100) + sqrt(as.numeric(g))\nboxplot(split(x, g), col = gray.colors(n), notch = TRUE)\ntitle(\n  main = \"Notched Boxplots\", xlab = \"Group\",\n  font.main = 4, font.lab = 1\n)\ncumcm2011A <- readRDS(file = \"cumcm2011A.RDS\")\npar(mfrow = c(2, 4), mar = c(4, 3, 1, 1))\nwith(cumcm2011A, boxplot(As, xlab = \"As\"))\nabline(h = c(1.8, 3.6, 5.4), col = c(\"green\", \"blue\", \"red\"), lty = 2)\n\nwith(cumcm2011A, boxplot(Cd, xlab = \"Cd\"))\nabline(h = c(70, 130, 190), col = c(\"green\", \"blue\", \"red\"), lty = 2)\n\nwith(cumcm2011A, boxplot(Cr, xlab = \"Cr\"))\nabline(h = c(13, 31, 49), col = c(\"green\", \"blue\", \"red\"), lty = 2)\n\nwith(cumcm2011A, boxplot(Cu, xlab = \"Cu\"))\nabline(h = c(6.0, 13.2, 20.4), col = c(\"green\", \"blue\", \"red\"), lty = 2)\n\nwith(cumcm2011A, boxplot(Hg, xlab = \"Hg\"))\nabline(h = c(19, 35, 51), col = c(\"green\", \"blue\", \"red\"), lty = 2)\n\nwith(cumcm2011A, boxplot(Ni, xlab = \"Ni\"))\nabline(h = c(4.7, 12.3, 19.9), col = c(\"green\", \"blue\", \"red\"), lty = 2)\n\nwith(cumcm2011A, boxplot(Pb, xlab = \"Pb\"))\nabline(h = c(19, 31, 43), col = c(\"green\", \"blue\", \"red\"), lty = 2)\n\nwith(cumcm2011A, boxplot(Zn, xlab = \"Zn\"))\nabline(h = c(41, 69, 97), col = c(\"green\", \"blue\", \"red\"), lty = 2)\nboxplot(As ~ area,\n  data = cumcm2011A,\n  col = hcl.colors(5)\n)\nabline(\n  h = c(1.8, 3.6, 5.4), col = c(\"green\", \"blue\", \"red\"),\n  lty = 2, lwd = 2\n)"},{"path":"chap-graphics-foundations.html","id":"error-bars","chapter":"第 10 章 图形基础","heading":"10.2.12 残差图","text":"iris 四个测量指标\n图 10.58: 带标准差的均值散点图\n","code":"\nvec_mean <- colMeans(iris[, -5])\nvec_sd <- apply(iris[, -5], 2, sd)\nplot(seq(4), vec_mean,\n  ylim = range(c(vec_mean - vec_sd, vec_mean + vec_sd)),\n  xlab = \"Species\", ylab = \"Mean +/- SD\", lwd = 1, pch = 19,\n  axes = FALSE\n)\naxis(1, at = seq(4), labels = colnames(iris)[-5])\naxis(2, at = seq(7), labels = seq(7))\narrows(seq(4), vec_mean - vec_sd, seq(4), vec_mean + vec_sd,\n  length = 0.05, angle = 90, code = 3\n)\nbox()"},{"path":"chap-graphics-foundations.html","id":"plot-violin","chapter":"第 10 章 图形基础","heading":"10.2.13 提琴图","text":"Tom Kelly 维护的 vioplot 包 https://github.com/TomKellyGenetics/vioplot","code":""},{"path":"chap-graphics-foundations.html","id":"plot-contour","chapter":"第 10 章 图形基础","heading":"10.2.14 轮廓图","text":"topo 是地形数据等高线图","code":""},{"path":"chap-graphics-foundations.html","id":"plot-line","chapter":"第 10 章 图形基础","heading":"10.2.15 折线图","text":"函数曲线，样条曲线，核密度曲线，平行坐标图折线图点线图 plot(type=\"b\") 函数曲线图 curve matplot X 样条曲线 xspline时序图太阳黑子活动数据sunspot.month Monthly Sunspot Data, 1749 “Present”\nsunspot.year Yearly Sunspot Data, 1700-1988\nsunspots Monthly Sunspot Numbers, 1749-1983\n图 10.59: 折线图\n","code":"\nplot(AirPassengers)\nbox(col = \"gray\")"},{"path":"chap-graphics-foundations.html","id":"function","chapter":"第 10 章 图形基础","heading":"10.2.16 函数图","text":"\n图 10.60: 贝塞尔函数\n还有 eta 函数和 gammaz 函数","code":"\nx0 <- 2^(-20:10)\nnus <- c(0:5, 10, 20)\nx <- seq(0, 4, length.out = 501)\n\nplot(x0, x0^-8,\n  frame.plot = TRUE, # 添加绘图框\n  log = \"xy\", # x 和 y 轴都取对数尺度\n  axes = FALSE, # 去掉坐标轴\n  xlab = \"$u$\", ylab = \"$\\\\mathcal{K}_{\\\\kappa}(u)$\", # 设置坐标轴标签\n  type = \"n\", # 清除绘图区域的内容\n  ann = TRUE, # 添加标题 x和y轴标签\n  panel.first = grid() # 添加背景参考线\n)\n\naxis(1,\n  at = 10^seq(from = -8, to = 2, by = 2),\n  labels = paste0(\"$\\\\mathsf{10^{\", seq(from = -8, to = 2, by = 2), \"}}$\")\n)\naxis(2,\n  at = 10^seq(from = -8, to = 56, by = 16),\n  labels = paste0(\"$\\\\mathsf{10^{\", seq(from = -8, to = 56, by = 16), \"}}$\"), las = 1\n)\n\nfor (i in seq(length(nus))) {\n  lines(x0, besselK(x0, nu = nus[i]), col = hcl.colors(9)[i], lwd = 2)\n}\nlegend(\"topright\",\n  legend = paste0(\"$\\\\kappa=\", rev(nus), \"$\"),\n  col = hcl.colors(9, rev = T), lwd = 2, cex = 1\n)"},{"path":"chap-graphics-foundations.html","id":"plot-mosaic","chapter":"第 10 章 图形基础","heading":"10.2.17 马赛克图","text":"马赛克图 mosaicplot\n图 10.61: 马赛克图\n","code":"\nplot(HairEyeColor, col = \"lightblue\", border = \"white\", main = \"\")"},{"path":"chap-graphics-foundations.html","id":"plot-dotchart","chapter":"第 10 章 图形基础","heading":"10.2.18 点图","text":"dotchart 克利夫兰点图条件图 coplot","code":""},{"path":"chap-graphics-foundations.html","id":"plot-matrix","chapter":"第 10 章 图形基础","heading":"10.2.19 矩阵图","text":"在对角线上添加平滑曲线、密度曲线\n图 10.62: 变量关系\n\n图 10.63: 矩阵图\n","code":"\npairs(longley,\n  gap = 0,\n  diag.panel = function(x, ...) {\n    par(new = TRUE)\n    hist(x,\n      col = \"light blue\",\n      probability = TRUE,\n      axes = FALSE,\n      main = \"\"\n    )\n    lines(density(x),\n      col = \"red\",\n      lwd = 3\n    )\n    rug(x)\n  }\n)\n# 自带 layout\nplot(iris[, -5], col = iris$Species)"},{"path":"chap-graphics-foundations.html","id":"plot-radar","chapter":"第 10 章 图形基础","heading":"10.2.20 雷达图","text":"星图 stars 多元数据","code":""},{"path":"chap-graphics-foundations.html","id":"plot-rose","chapter":"第 10 章 图形基础","heading":"10.2.21 玫瑰图","text":"注意与 image 函数区别\n图 10.64: image 图形\n","code":"\nx <- 10 * (1:nrow(volcano))\ny <- 10 * (1:ncol(volcano))\nimage(x, y, volcano, col = terrain.colors(100), axes = FALSE)\ncontour(x, y, volcano,\n  levels = seq(90, 200, by = 5),\n  add = TRUE, col = \"peru\"\n)\naxis(1, at = seq(100, 800, by = 100))\naxis(2, at = seq(100, 600, by = 100))\nbox()\ntitle(main = \"Maunga Whau Volcano\", font.main = 4)"},{"path":"chap-graphics-foundations.html","id":"plot-persp","chapter":"第 10 章 图形基础","heading":"10.2.22 透视图","text":"\n图 10.65: 统计学的世界\n","code":"\npar(mar = c(.5, 2.1, .5, .5))\nx1 <- seq(-10, 10, length = 51)\nx2 <- x1 \nf <- function(x1, x2, mu1 = 0, mu2 = 0, s11 = 10, s12 = 15, s22 = 10, rho = 0.5) {\n  term1 <- 1 / (2 * pi * sqrt(s11 * s22 * (1 - rho^2)))\n  term2 <- -1 / (2 * (1 - rho^2))\n  term3 <- (x1 - mu1)^2 / s11\n  term4 <- (x2 - mu2)^2 / s22\n  term5 <- -2 * rho * ((x1 - mu1) * (x2 - mu2)) / (sqrt(s11) * sqrt(s22))\n  term1 * exp(term2 * (term3 + term4 - term5))\n} \nz <- outer(x1, x2, f) \nlibrary(shape)\npersp(x1, x2, z,\n  xlab = \"\", ylab = \"\", zlab = \"\",\n  col = drapecol(z, col = terrain.colors(20)),\n  border = NA, shade = 0.1, r = 50, d = 0.1, expand = 0.5,\n  theta = 120, phi = 15, ltheta = 90, lphi = 180,\n  ticktype = \"detailed\", nticks = 5\n)"},{"path":"chap-graphics-foundations.html","id":"lattice-graphics","chapter":"第 10 章 图形基础","heading":"10.3 栅格统计图形","text":"imagine pen Trellis, Lattice pen.— Paul Murrell 33把网站搬出来，汉化 http://latticeextra.r-forge.r-project.org/","code":""},{"path":"chap-graphics-foundations.html","id":"lattice-boxplot","chapter":"第 10 章 图形基础","heading":"10.3.1 箱线图","text":"","code":"\nlibrary(lattice)\n# plot(data = InsectSprays, count ~ spray)\nbwplot(count ~ spray, data = InsectSprays)"},{"path":"chap-graphics-foundations.html","id":"lattice-line","chapter":"第 10 章 图形基础","heading":"10.3.2 折线图","text":"latticeExtra 包提供了强大的图层函数 layer()多元时间序列如何解释时序图Plot many time series parallellattice 图形的参数设置","code":"\nlibrary(RColorBrewer)\nlibrary(latticeExtra)\nxyplot(EuStockMarkets) +\n  layer(panel.scaleArrow(\n    x = 0.99, append = \" units\", col = \"grey\", srt = 90, cex = 0.8\n  ))\nhorizonplot(EuStockMarkets,\n  colorkey = TRUE,\n  origin = 4000, horizonscale = 1000\n) +\n  layer(panel.scaleArrow(\n    x = 0.99, digits = 1, col = \"grey\",\n    srt = 90, cex = 0.7\n  )) +\n  layer(\n    lim <- current.panel.limits(),\n    panel.text(lim$x[1], lim$y[1], round(lim$y[1], 1),\n      font = 2,\n      cex = 0.7, adj = c(-0.5, -0.5), col = \"#9FC8DC\"\n    )\n  )\n# # https://stackoverflow.com/questions/25109196/r-lattice-package-add-legend-to-a-figure\nlibrary(lattice)\nlibrary(nlme)\n\nplot(Orange,\n  outer = ~1,\n  key = list(\n    space = \"right\", title = \"Tree\", cex.title = 1,\n    lines = list(lty = 1, col = gray.colors(5)),\n    # points = list(pch = 1, col = gray.colors(5)),\n    text = list(c(\"3\", \"1\", \"5\", \"2\", \"4\"))\n  ),\n  par.settings = list(\n    # plot.line = list(col = gray.colors(5), border = \"transparent\"),\n    # plot.symbol = list(col = gray.colors(5), border = \"transparent\"),\n    strip.background = list(col = \"white\"),\n    strip.border = list(col = \"black\")\n  )\n)\nlibrary(MASS)\nlibrary(lattice)\n## Plot the claims frequency against age group by engine size and district\n\nbarchart(Claims / Holders ~ Age | Group,\n  groups = District,\n  data = Insurance, origin = 0, auto.key = TRUE\n)\nbarchart(Claims / Holders ~ Age | Group,\n  groups = District, data = Insurance,\n  main = \"Claims frequency\",\n  auto.key = list(\n    space = \"top\", columns = 4,\n    title = \"District\", cex.title = 1\n  )\n)\nshow.settings()\nmyColours <- brewer.pal(6, \"Blues\")\nmy.settings <- list(\n  superpose.polygon = list(col = myColours[2:5], border = \"transparent\"),\n  strip.background = list(col = myColours[6]),\n  strip.border = list(col = \"black\")\n)\n\n# 获取参数设置\ntrellis.par.get()\n\n# 全局参数设置\ntrellis.par.set(my.settings)\nlibrary(MASS)\nlibrary(lattice)\n\nbarchart(Claims / Holders * 100 ~ Age | Group,\n  groups = District, data = Insurance,\n  origin = 0, main = \"Motor insurance claims frequency\",\n  xlab = \"Age\", ylab = \"Claims frequency %\",\n  scales = list(alternating = 1),\n  auto.key = list(\n    space = \"top\", columns = 4, \n    points = FALSE, rectangles = TRUE,\n    title = \"District\", cex.title = 1\n  ),\n  par.settings = list(\n    superpose.polygon = list(col = gray.colors(4), border = \"transparent\"),\n    strip.background = list(col = \"gray80\"),\n    strip.border = list(col = \"black\")\n  ),\n  par.strip.text = list(col = \"gray40\", font = 2),\n  panel = function(x, y, ...) {\n    panel.grid(h = -1, v = 0)\n    panel.barchart(x, y, ...)\n  }\n)"},{"path":"chap-graphics-foundations.html","id":"lattice-smooth","chapter":"第 10 章 图形基础","heading":"10.3.3 平滑图","text":"Trellis Displays Tukey’s Hanging Rootograms","code":"\nset.seed(1)\nxy <- data.frame(\n  x = runif(100),\n  y = rt(100, df = 5)\n)\n\nxyplot(y ~ x, xy, panel = function(...) {\n  panel.xyplot(...)\n  panel.smoother(..., span = 0.9)\n})\nlibrary(splines)\nxyplot(y ~ x, xy) +\n  layer(panel.smoother(y ~ ns(x, 5), method = \"lm\"))\nlibrary(nlme)\nlibrary(mgcv)\nxyplot(y ~ x, xy) +\n  layer(panel.smoother(y ~ s(x), method = \"gam\"))\nx <- rpois(1000, lambda = 50)\nrootogram(~x, dfun = function(x) dpois(x, lambda = 50))"},{"path":"chap-graphics-foundations.html","id":"lattice-dotplot","chapter":"第 10 章 图形基础","heading":"10.3.4 点图","text":"","code":"\n# 添加背景网格线作为参考线\nsegplot(reorder(factor(county), rate.male) ~ LCL95.male + UCL95.male,\n  data = subset(USCancerRates, state == \"Washington\"),\n  draw.bands = FALSE, centers = rate.male\n)"},{"path":"chap-graphics-foundations.html","id":"lattice-step","chapter":"第 10 章 图形基础","heading":"10.3.5 阶梯图","text":"经验累积分布图","code":"\necdfplot(~height | voice.part, data = singer)"},{"path":"chap-graphics-foundations.html","id":"lattice-facet","chapter":"第 10 章 图形基础","heading":"10.3.6 分面图","text":"","code":"\n## a variant of Figure 5.6 from Sarkar (2008)\n## http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=05;figure=05_06\n\ndepth.ord <- rev(order(quakes$depth))\nquakes$Magnitude <- equal.count(quakes$mag, 4)\nquakes.ordered <- quakes[depth.ord, ]\n\nlevelplot(depth ~ long + lat | Magnitude,\n  data = quakes.ordered,\n  panel = panel.levelplot.points, type = c(\"p\", \"g\"),\n  aspect = \"iso\", prepanel = prepanel.default.xyplot\n)"},{"path":"chap-graphics-foundations.html","id":"lattice-contour","chapter":"第 10 章 图形基础","heading":"10.3.7 等高线图","text":"","code":"\nset.seed(1)\nxyz <- data.frame(x = rnorm(100), y = rnorm(100))\nxyz$z <- with(xyz, x * y + rnorm(100, sd = 1))\n\n## GAM smoother with smoothness by cross validation\nlibrary(mgcv)\nlevelplot(z ~ x * y, xyz,\n  panel = panel.2dsmoother,\n  form = z ~ s(x, y), method = \"gam\"\n)"},{"path":"chap-graphics-foundations.html","id":"lattice-persp","chapter":"第 10 章 图形基础","heading":"10.3.8 透视图","text":"\n图 10.66: (ref:volcano-topo)\n","code":"\nlibrary(shape)\npersp(volcano, \n  theta = 30, phi = 20, \n  r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180,\n  shade = 0.1, ticktype = \"detailed\", nticks = 5, box = TRUE,\n  col = drapecol(volcano, col = terrain.colors(100)),\n  xlab = \"X\", ylab = \"Y\", zlab = \"Z\", border = \"transparent\",\n  main = \"Topographic Information \\n on Auckland's Maunga Whau Volcano\"\n)"},{"path":"chap-graphics-foundations.html","id":"lattice-cluster","chapter":"第 10 章 图形基础","heading":"10.3.9 聚类图","text":"","code":"\nxyplot(Sepal.Length ~ Petal.Length,\n  groups = Species,\n  data = iris, scales = \"free\",\n  par.settings = list(\n    superpose.symbol = list(pch = c(15:17)),\n    superpose.line = list(lwd = 2, lty = 1:3)\n  ),\n  panel = function(x, y, ...) {\n    panel.xyplot(x, y, ...)\n    panel.ellipse(x, y, ...)\n  },\n  auto.key = list(x = .1, y = .8, corner = c(0, 0))\n)\n# lattice 书 6.3.1 节 参数曲面\n\nkx <- function(u, v) cos(u) * (r + cos(u / 2))\nky <- function(u, v) {\n  sin(u) * (r + cos(u / 2) * sin(t * v) -\n    sin(u / 2) * sin(2 * t * v)) * sin(t * v) -\n    sin(u / 2) * sin(2 * t * v)\n}\n\n\nkz <- function(u, v) sin(u / 2) * sin(t * v) + cos(u / 2) * sin(t * v)\nn <- 50\nu <- seq(0.3, 1.25, length = n) * 2 * pi\nv <- seq(0, 1, length = n) * 2 * pi\num <- matrix(u, length(u), length(u))\nvm <- matrix(v, length(v), length(v), byrow = TRUE)\nr <- 2\nt <- 1\n\nwireframe(kz(um, vm) ~ kx(um, vm) + ky(um, vm),\n  shade = TRUE, xlab = expression(x[1]),\n  ylab = expression(x[2]),\n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  screen = list(z = 170, x = -60),\n  alpha = 0.75, panel.aspect = 0.6, aspect = c(1, 0.4),\n  scales = list(arrows = FALSE, col = \"black\"),\n  lattice.options = list(\n    layout.widths = list(\n      left.padding = list(x = -.6, units = \"inches\"),\n      right.padding = list(x = -1.0, units = \"inches\")\n    ),\n    layout.heights = list(\n      bottom.padding = list(x = -.8, units = \"inches\"),\n      top.padding = list(x = -1.0, units = \"inches\")\n    )\n  ),\n  par.settings = list(\n    axis.line = list(col = \"transparent\")\n  )\n)"},{"path":"chap-graphics-foundations.html","id":"graphics-sessioninfo","chapter":"第 10 章 图形基础","heading":"10.4 运行环境","text":"","code":"\nxfun::session_info()## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-pc-linux-gnu (64-bit)\n## Running under: Ubuntu 20.04.4 LTS\n## \n## Locale:\n##   LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n##   LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n##   LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n##   LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n##   LC_ADDRESS=C               LC_TELEPHONE=C            \n##   LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n## \n## Package version:\n##   base64enc_0.1.3     bookdown_0.26       brio_1.1.3         \n##   bslib_0.3.1         cachem_1.0.6        cli_3.3.0          \n##   compiler_4.2.0      curl_4.3.2          desc_1.4.1         \n##   digest_0.6.29       downlit_0.4.0       evaluate_0.15      \n##   fansi_1.0.3         fastmap_1.1.0       fs_1.5.2           \n##   glue_1.6.2          graphics_4.2.0      grDevices_4.2.0    \n##   grid_4.2.0          highr_0.9           htmltools_0.5.2    \n##   jpeg_0.1-9          jquerylib_0.1.4     jsonlite_1.8.0     \n##   KernSmooth_2.23-20  knitr_1.39          lattice_0.20-45    \n##   latticeExtra_0.6-29 magrittr_2.0.3      mapproj_1.2.8      \n##   maps_3.4.0          MASS_7.3-57         Matrix_1.4-1       \n##   memoise_2.0.1       methods_4.2.0       mgcv_1.8-40        \n##   nlme_3.1-157        png_0.1-7           R6_2.5.1           \n##   rappdirs_0.3.3      RColorBrewer_1.1-3  rlang_1.0.2        \n##   rmarkdown_2.14      rprojroot_2.0.3     sass_0.4.1         \n##   shape_1.4.6         splines_4.2.0       stats_4.2.0        \n##   stringi_1.7.6       stringr_1.4.0       survival_3.3-1     \n##   sysfonts_0.8.8      tinytex_0.39        tools_4.2.0        \n##   utils_4.2.0         vctrs_0.4.1         xfun_0.31          \n##   xml2_1.3.3          yaml_2.3.5"},{"path":"chap-data-visualization.html","id":"chap-data-visualization","chapter":"第 11 章 数据可视化","heading":"第 11 章 数据可视化","text":"David Robinson 给出为何使用 ggplot2 34 当然也有 Jeff Leek 指出在某些重要场合不适合 ggplot2 35 并且给出强有力的 证据，其实不管怎么样，适合自己的才是好的。也不枉费 Garrick Aden-Buie 花费 160 页幻灯片逐步分解介绍 优雅的ggplot2，Malcolm Barrett 也介绍了 ggplot2 基础用法，还有 Selva Prabhakaran 精心总结给出了 50 个 ggplot2 数据可视化的 例子 以及 Victor Perrier 为小白用 ggplot2 操碎了心地开发 RStudio 插件 esquisse 包，Claus O. Wilke 教你一步步创建出版级的图形 https://github.com/clauswilke/practical_ggplot2。ggplot2 是十分方便的统计作图工具，相比 Base R，为了一张出版级的图形，不需要去调整每个参数，实现快速出图。集成了很多其它统计计算的 R 包，支持丰富的统计分析和计算功能，如回归、平滑等，实现了作图和模型的无缝连接。比如图11.1，使用 loess 局部多项式平滑得到数据的趋势，不仅仅是散点图，代码量也非常少。\n图 11.1: 简洁美观\n故事源于一幅图片，我不记得第一次见到这幅图是什么时候了，只因多次在多个场合中见过，所以留下了深刻的印象，后来才知道它出自于一篇博文 — Using R packages education scale Data Science Airbnb，作者 Ricardo Bion 还在其 Github 上传了相关代码36。除此之外还有几篇重要的参考资料：Pablo Barberá 的 Data Visualization R ggplot2Matt Leonawicz 的新作 mapmate, 可以去其主页欣赏系列作品37tidytuesday 可视化挑战官方项目 还有 tidytuesdayggstatsplot 可视化统计检验、模型的结果ggpubr 制作出版级统计图形Thomas Lin Pedersen Drawing Anything ggplot2Designing ggplots: making clear figures communicateggh4x 提供 ggplot2 的额外定制功能ggdist Visualizations distributions uncertaintygghighlightggnetworkggPMX ‘ggplot2’ Based Tool Facilitate Diagnostic Plots NLME Modelsggpp ggpp: Grammar Extensions ‘ggplot2’如 Berton Gunter 所说，数据可视化只是一种手段，根据数据实际情况作展示才是重要的，并不是要追求酷炫。3-D bar plots abomination. Just Excel can doesn’t mean . (Dismount pulpit).— Berton Gunter 38grid 是 lattice 和 ggplot2 的基础，gganimate 是 ggplot2 一个扩展，它将静态图形视为帧，调用第三方工具合成 GIF 动图或 MP4 视频等，要想深入了解 ggplot2，可以去看 Hadley Wickham, Danielle Navarro, Thomas Lin Pedersen 合著的《ggplot2: elegant graphics data analysis》第三版 https://ggplot2-book.org/。","code":"\nlibrary(ggplot2)           # ggplot2 图形\nlibrary(patchwork)         # 图形布局\nlibrary(magrittr)          # 管道操作\nlibrary(ggrepel)           # 文本注释\nlibrary(extrafont)         # 加载外部字体 TTF\nlibrary(hrbrthemes)        # 主题\nlibrary(maps)              # 地图数据\nlibrary(mapdata)           # 地图数据\nlibrary(xkcd)              # 漫画字体\nlibrary(RgoogleMaps)       # 静态地图\nlibrary(data.table)        # 数据操作\nlibrary(KernSmooth)        # 核平滑\nlibrary(ggnormalviolin)    # 提琴图\nlibrary(ggbeeswarm)        # 蜂群图\nlibrary(gert)              # Git 数据操作\nlibrary(ggridges)          # 岭线图\nlibrary(ggpubr)            # 组合图\nlibrary(treemap)           # 树状图\nlibrary(treemapify)        # 树状图\nlibrary(ggalluvial)        # 桑基图\nlibrary(ggquiver)          # 向量场图\nlibrary(ggmosaic)          # 马赛克图\nlibrary(ggbump)            # 凹凸图\nlibrary(ggstream)          # 水流图\nlibrary(timelineS)         # 时间线\nlibrary(ggdendro)          # 聚类图\nlibrary(ggfortify)         # 统计分析结果可视化：主成分图\nlibrary(gganimate)         # 动态图\nggplot(mpg, aes(displ, hwy)) +\n  geom_point(aes(color = class)) +\n  geom_smooth(se = TRUE, method = \"loess\") +\n  labs(\n    title = \"Fuel efficiency generally decreases with engine size\",\n    subtitle = \"Two seaters (sports cars) are an exception because of their light weight\",\n    caption = \"Data from fueleconomy.gov\"\n  )"},{"path":"chap-data-visualization.html","id":"sec-elements","chapter":"第 11 章 数据可视化","heading":"11.1 元素","text":"以数据集 airquality 为例介绍 GGplot2 图层、主题、配色、坐标、尺度、注释和组合等","code":""},{"path":"chap-data-visualization.html","id":"ggplot2-layer","chapter":"第 11 章 数据可视化","heading":"11.1.1 图层","text":"生成一个散点图","code":"\nls(\"package:ggplot2\", pattern = \"^geom_\")##  [1] \"geom_abline\"            \"geom_area\"              \"geom_bar\"              \n##  [4] \"geom_bin_2d\"            \"geom_bin2d\"             \"geom_blank\"            \n##  [7] \"geom_boxplot\"           \"geom_col\"               \"geom_contour\"          \n## [10] \"geom_contour_filled\"    \"geom_count\"             \"geom_crossbar\"         \n## [13] \"geom_curve\"             \"geom_density\"           \"geom_density_2d\"       \n## [16] \"geom_density_2d_filled\" \"geom_density2d\"         \"geom_density2d_filled\" \n## [19] \"geom_dotplot\"           \"geom_errorbar\"          \"geom_errorbarh\"        \n## [22] \"geom_freqpoly\"          \"geom_function\"          \"geom_hex\"              \n## [25] \"geom_histogram\"         \"geom_hline\"             \"geom_jitter\"           \n## [28] \"geom_label\"             \"geom_line\"              \"geom_linerange\"        \n## [31] \"geom_map\"               \"geom_path\"              \"geom_point\"            \n## [34] \"geom_pointrange\"        \"geom_polygon\"           \"geom_qq\"               \n## [37] \"geom_qq_line\"           \"geom_quantile\"          \"geom_raster\"           \n## [40] \"geom_rect\"              \"geom_ribbon\"            \"geom_rug\"              \n## [43] \"geom_segment\"           \"geom_sf\"                \"geom_sf_label\"         \n## [46] \"geom_sf_text\"           \"geom_smooth\"            \"geom_spoke\"            \n## [49] \"geom_step\"              \"geom_text\"              \"geom_tile\"             \n## [52] \"geom_violin\"            \"geom_vline\"\nggplot(airquality, aes(x = Temp, y = Ozone)) + geom_point()## Warning: Removed 37 rows containing missing values (geom_point)."},{"path":"chap-data-visualization.html","id":"subsec-axis-label","chapter":"第 11 章 数据可视化","heading":"11.1.2 标签","text":"图形的标签分为横纵轴标签、刻度标签、主标题、副标题等\n图 11.2: 自1945年第一季度至1974年第四季度美国总统的支持\n","code":"\ndata.frame(\n  dates = seq.Date(\n    from = as.Date(\"1945-01-01\"),\n    to = as.Date(\"1974-12-31\"), \n    by = \"quarter\"\n  ),\n  presidents = as.vector(presidents)\n) |> \n  ggplot(aes(x = dates, y = presidents)) +\n  geom_line(color = \"slategray\", na.rm = TRUE) +\n  geom_point(size = 1.5, color = \"darkslategray\", na.rm = TRUE) +\n  scale_x_date(date_breaks = \"4 year\", date_labels = \"%Y\") +\n  labs(\n    title = \"1945年至1974年美国总统每季度支持率\",\n    x = \"年份\", y = \"支持率 (%)\",\n    caption = \"数据源: R 包 datasets\"\n  ) +\n  theme_minimal(base_size = 10.54, base_family = \"Noto Serif CJK SC\")"},{"path":"chap-data-visualization.html","id":"subsec-annotation","chapter":"第 11 章 数据可视化","heading":"11.1.3 注释","text":"图中注释的作用在于高亮指出关键点，提请读者注意。文本注释可由 ggrepel 包提供的标签图层 geom_label_repel() 添加，标签数据可独立于之前的数据层，标签所在的位置可以通过参数 direction 和 nudge_y 精调，图 11.3 模拟了一组数据。\n图 11.3: 文本注释\nggrepel 包的图层 geom_text_repel() 支持所有数据点的注释，并且自动调整文本的位置，防止重叠，增加辨识度，如图 11.4。当然，数据点如果过于密集也不适合全部注释，高亮其中的关键点即可。\n图 11.4: 少量点的情况下可以全部注释，且可以解决注释重叠的问题\nClaus Wilke 开发的 ggtext 包支持更加丰富的注释样式，详见网站 https://wilkelab.org/ggtext/geomtextpath 曲线上的文字随曲线弯曲变化ggsvg 曲线上散点以图片、彩色图标表示","code":"\nset.seed(2020)\nlibrary(ggrepel)\ndat <- data.frame(\n  x = seq(100),\n  y = cumsum(rnorm(100))\n)\nanno_data <- dat |> \n  subset(x %% 25 == 10)  |> \n  transform(text = \"text\")\n\nggplot(data = dat, aes(x, y)) +\n  geom_line() +\n  geom_label_repel(aes(label = text),\n    data = anno_data,\n    direction = \"y\",\n    nudge_y = c(-5, 5, 5, 5)\n  ) +\n  theme_minimal()\nmtcars |> \n  transform(cyl = as.factor(cyl)) |> \n  ggplot(aes(wt, mpg, label = rownames(mtcars), color = cyl)) +\n  geom_point() +\n  geom_text_repel(max.overlaps = 12) +\n  theme_minimal()\nls(\"package:ggplot2\", pattern = \"^annotation_\")## [1] \"annotation_custom\"   \"annotation_logticks\" \"annotation_map\"     \n## [4] \"annotation_raster\"\nggplot(airquality, aes(x = Temp, y = Ozone)) + \n  geom_point(na.rm = TRUE)\nggplot(airquality, aes(x = Temp, y = Ozone)) + \n  geom_point(na.rm = TRUE) +\n  labs(title = substitute(paste(d *\n    bolditalic(x)[italic(t)] == alpha * (theta - bolditalic(x)[italic(t)]) *\n    d * italic(t) + lambda * d * italic(B)[italic(t)]), list(lambda = 4)))"},{"path":"chap-data-visualization.html","id":"ggplot2-scale","chapter":"第 11 章 数据可视化","heading":"11.1.4 刻度","text":"","code":"\nls(\"package:ggplot2\", pattern = \"^scale_(x|y)_\")##  [1] \"scale_x_binned\"     \"scale_x_continuous\" \"scale_x_date\"      \n##  [4] \"scale_x_datetime\"   \"scale_x_discrete\"   \"scale_x_log10\"     \n##  [7] \"scale_x_reverse\"    \"scale_x_sqrt\"       \"scale_x_time\"      \n## [10] \"scale_y_binned\"     \"scale_y_continuous\" \"scale_y_date\"      \n## [13] \"scale_y_datetime\"   \"scale_y_discrete\"   \"scale_y_log10\"     \n## [16] \"scale_y_reverse\"    \"scale_y_sqrt\"       \"scale_y_time\"\nrange(airquality$Temp, na.rm = TRUE)## [1] 56 97\nrange(airquality$Ozone, na.rm = TRUE)## [1]   1 168\nggplot(airquality, aes(x = Temp, y = Ozone)) + \n  geom_point(na.rm = TRUE) +\n  scale_x_continuous(breaks = seq(50, 100, 5)) +\n  scale_y_continuous(breaks = seq(0, 200, 20))"},{"path":"chap-data-visualization.html","id":"ggplot2-legend","chapter":"第 11 章 数据可视化","heading":"11.1.5 图例","text":"二维的图例 biscale 和 multiscales 和 ggnewscale","code":""},{"path":"chap-data-visualization.html","id":"ggplot2-coord","chapter":"第 11 章 数据可视化","heading":"11.1.6 坐标系","text":"极坐标，直角坐标","code":"\nls(\"package:ggplot2\", pattern = \"^coord_\")##  [1] \"coord_cartesian\" \"coord_equal\"     \"coord_fixed\"     \"coord_flip\"     \n##  [5] \"coord_map\"       \"coord_munch\"     \"coord_polar\"     \"coord_quickmap\" \n##  [9] \"coord_sf\"        \"coord_trans\""},{"path":"chap-data-visualization.html","id":"ggplot2-axes","chapter":"第 11 章 数据可视化","heading":"11.1.7 坐标轴","text":"坐标轴标签位置、大小、字体","code":""},{"path":"chap-data-visualization.html","id":"ggplot2-color","chapter":"第 11 章 数据可视化","heading":"11.1.8 配色","text":"","code":"\nls(\"package:ggplot2\", pattern = \"^scale_(color|fill)_\")##  [1] \"scale_color_binned\"     \"scale_color_brewer\"     \"scale_color_continuous\"\n##  [4] \"scale_color_date\"       \"scale_color_datetime\"   \"scale_color_discrete\"  \n##  [7] \"scale_color_distiller\"  \"scale_color_fermenter\"  \"scale_color_gradient\"  \n## [10] \"scale_color_gradient2\"  \"scale_color_gradientn\"  \"scale_color_grey\"      \n## [13] \"scale_color_hue\"        \"scale_color_identity\"   \"scale_color_manual\"    \n## [16] \"scale_color_ordinal\"    \"scale_color_steps\"      \"scale_color_steps2\"    \n## [19] \"scale_color_stepsn\"     \"scale_color_viridis_b\"  \"scale_color_viridis_c\" \n## [22] \"scale_color_viridis_d\"  \"scale_fill_binned\"      \"scale_fill_brewer\"     \n## [25] \"scale_fill_continuous\"  \"scale_fill_date\"        \"scale_fill_datetime\"   \n## [28] \"scale_fill_discrete\"    \"scale_fill_distiller\"   \"scale_fill_fermenter\"  \n## [31] \"scale_fill_gradient\"    \"scale_fill_gradient2\"   \"scale_fill_gradientn\"  \n## [34] \"scale_fill_grey\"        \"scale_fill_hue\"         \"scale_fill_identity\"   \n## [37] \"scale_fill_manual\"      \"scale_fill_ordinal\"     \"scale_fill_steps\"      \n## [40] \"scale_fill_steps2\"      \"scale_fill_stepsn\"      \"scale_fill_viridis_b\"  \n## [43] \"scale_fill_viridis_c\"   \"scale_fill_viridis_d\"\nggplot(airquality, aes(x = Temp, y = Ozone, color = as.factor(Month))) +\n  geom_point(na.rm = TRUE)\nggplot(airquality, aes(x = Temp, y = Ozone, color = as.ordered(Month))) +\n  geom_point(na.rm = TRUE)"},{"path":"chap-data-visualization.html","id":"subsec-theme","chapter":"第 11 章 数据可视化","heading":"11.1.9 主题","text":"ggcharts 和 bbplot\nprettyB 美化 Base R 图形\nggprism这里只展示 theme_bw() theme_void() theme_minimal() 和 theme_void() 等四个常见主题，更多主题参考 ggsci、ggthemes 、ggtech、hrbrthemes、clcharts 和 ggthemr 包\n图 11.5: ggplot2 内置的主题\n除主题之外，还有一类提供一整套统一的风格样式来绘制各种统计图形，如 ggpubr 和 bbplot","code":"\nls(\"package:ggplot2\", pattern = \"^theme_\")##  [1] \"theme_bw\"       \"theme_classic\"  \"theme_dark\"     \"theme_get\"     \n##  [5] \"theme_gray\"     \"theme_grey\"     \"theme_light\"    \"theme_linedraw\"\n##  [9] \"theme_minimal\"  \"theme_replace\"  \"theme_set\"      \"theme_test\"    \n## [13] \"theme_update\"   \"theme_void\"\nggplot(airquality, aes(x = Temp, y = Ozone), na.rm = TRUE) +\n  geom_point() +\n  theme_bw()## Warning: Removed 37 rows containing missing values (geom_point).\nggplot(airquality, aes(x = Temp, y = Ozone), na.rm = TRUE) +\n  geom_point() +\n  theme_void()## Warning: Removed 37 rows containing missing values (geom_point).\nggplot(airquality, aes(x = Temp, y = Ozone), na.rm = TRUE) +\n  geom_point() +\n  theme_minimal()## Warning: Removed 37 rows containing missing values (geom_point).\nggplot(airquality, aes(x = Temp, y = Ozone), na.rm = TRUE) +\n  geom_point() +\n  theme_classic()## Warning: Removed 37 rows containing missing values (geom_point)."},{"path":"chap-data-visualization.html","id":"ggplot2-grid","chapter":"第 11 章 数据可视化","heading":"11.1.10 布局","text":"cowplot 是以作者 Claus O. Wilke 命名的，用来组合 ggplot 对象画图，类似的组合图形的功能包还有 baptiste auguié 开发的 gridExtra 和 egg， Thomas Lin Pedersen 开发的 patchworkDean Attali 开发的 ggExtra 可以在图的边界添加密度估计曲线，直方图等","code":"\nggplot(airquality) + \n  geom_point(aes(x = Temp, y = Ozone), na.rm = TRUE) + \n  facet_wrap(~ as.ordered(Month))\nggplot(airquality) + \n  geom_point(aes(x = Temp, y = Ozone), na.rm = TRUE) + \n  facet_wrap(~ as.ordered(Month), nrow = 1)"},{"path":"chap-data-visualization.html","id":"sec-fonts","chapter":"第 11 章 数据可视化","heading":"11.2 字体","text":"firatheme 包提供基于 fira sans 字体的 ggplot2 主题，类似的字体主题包还有 trekfont 、 fontHind， fontquiver 包与 fontBitstreamVera（Bitstream Vera 字体）、 fontLiberation（Liberation 字体）包和 fontDejaVu （DejaVu 字体）包一道提供了一些可允许使用的字体文件，这样，我们可以不依赖系统制作可重复的图形。Thomas Lin Pedersen 开发的 systemfonts 可直接使用系统自带的字体。","code":""},{"path":"chap-data-visualization.html","id":"subsec-system-fonts","chapter":"第 11 章 数据可视化","heading":"11.2.1 系统字体","text":"以 CentOS 系统为例，软件仓库中包含 Noto ， DejaVu 、liberation 等字体。可以安装自己喜欢的字体类型，比如：liberation 系列的四款字体可以用来替换 Windows 系统上对应的四款字体，对应关系见表 11.1表 11.1:  Windows 系统上四款字体的替代品Lionel Henry 将 Liberation 系列字体打包到 R 包 fontLiberation，非常便携，不需要操心跨平台的字体安装了。那如何使用呢？此外，我们还可以从网上获取各种个样的字体，特别地，Boryslav Larin 收录的 awesome-fonts 列表是一个不错的开始，比如图标字体 Font-Awesome，再安装宏包 fontawesome 后，即可在 LaTeX 文档中使用，下面这个示例推荐用 XeLaTeX 引擎编译。而在 R 绘制的图形中，通过指定 par()、 plot()、 title() 等函数的 family 参数值，比如 family = \"Liberation Sans\" 来调用系统无衬线 Liberation 字体，效果见图 11.6。\n图 11.6: 调用系统字体绘图\n为了符合出版的要求，需要在 11.6 中嵌入字体，设置代码块选项 fig.process=embed_fonts，这样生成 PDF 格式图形的时候，会调用此函数处理 PDF 图形。在 ggplot2 绘图中的调用方式是类似的，便不再赘述了。值得注意的是，extrafont 和 showtext 有些不一样，前者只能处理系统字体，后者还能获取网络字体和使用 OTF 字体，下面从 Google 开源的字体库获取 Noto 系列的四款字体，如图 11.7。在本书中，不要全局加载 showtext 包或调用 showtext::showtext_auto()，会和 extrafont 冲突，使得绘图时默认就只能使用 showtext 提供的字体。extrafont 包提供的函数 font_import() 仅支持系统安装的 TrueType/Type1 字体\n图 11.7: 在 ggplot2 绘图系统中设置中英文字体\n另外值得一提的是 hrbrthemes 包，除了定制了很多 ggplot2 主题，它还打包了很多的字体主题。比如默认主题 theme_ipsum() 使用 Arial Narrow 字体，如果没有该字体就自动寻找系统中的替代品，如图 11.8 实际使用的是 Nimbus Sans Narrow 字体，因为在 GitHub Action 中，我实际使用的测试环境是 Ubuntu 20.04，该系统自带 Nimbus Sans Narrow 字体，Arial Narrow 毕竟是 Windows 上的闭源字体。\n图 11.8: 调用 hrbrthemes 包设置字体主题\n如果系统没有安装 Arial Narrow 字体，可以导入 hrbrthemes 包自带的一些字体，比如 hrbrthemes::import_roboto_condensed()，然后调用字体主题 theme_ipsum_rc() 。如果不想使用这个包自带的字体，可以用系统中安装的字体去修改主题 theme_ipsum() 和 theme_ipsum_rc() 中的字体设置。如图 11.9 使用了 theme_ipsum() 中的 Arial Narrow 字体。\n图 11.9: 默认字体 Arial Narrow\nhrbrthemes 包提供了一个全局字体加载选项 hrbrthemes.loadfonts ，如果设置为 TRUE，即 options(hrbrthemes.loadfonts = TRUE) 会先调用函数 extrafont::loadfonts() 预加载系统字体，就不用一次次手动加载字体了。后续在第 11.2.3 节还会提及 extrafont 包的其它功能。","code":"sudo dnf install -y \\\n  google-noto-mono-fonts \\\n  google-noto-sans-fonts \\\n  google-noto-serif-fonts \\\n  dejavu-sans-mono-fonts \\\n  dejavu-sans-fonts \\\n  dejavu-serif-fonts\n# 或者\nsudo dnf install -y dejavu-fonts liberation-fonts\n# install.packages(\"fontLiberation\")\nsystem.file(package = \"fontLiberation\", \"fonts\", \"liberation-fonts\")## [1] \"\"sudo dnf install -y fontawesome-fonts\\documentclass[border=10pt]{standalone}\n\\usepackage{fontawesome}\n\\begin{document}\nHello, \\faGithub\n\\end{document}\nlibrary(extrafont)\nplot(data = pressure, pressure ~ temperature, \n     xlab = \"Temperature (deg C)\", ylab = \"Pressure (mm of Hg)\",\n     col.lab = \"red\", col.axis = \"blue\",\n     font.lab = 3, font.axis = 2, family = \"Liberation Sans\")\ntitle(main = \"Vapor Pressure of Mercury as a Function of Temperature\", \n      family = \"Liberation Serif\", font.main = 3)\ntitle(sub = \"Data Source: Weast, R. C\", \n      family = \"Liberation Mono\", font.sub = 1)\n# embed fonts to pdf\nembed_fonts <- function(fig_path) {\n  if(knitr::is_latex_output()){\n    embedFonts(\n      file = fig_path, outfile = fig_path,\n      fontpaths = \"~/Library/Fonts\"\n    )\n  }\n  return(fig_path)\n}\nsysfonts::font_add_google(name = \"Noto Sans\", family = \"Noto Sans\")\nsysfonts::font_add_google(name = \"Noto Serif\", family = \"Noto Serif\")\nsysfonts::font_add_google(name = \"Noto Serif SC\", family = \"Noto Serif SC\")\nsysfonts::font_add_google(name = \"Noto Sans SC\", family = \"Noto Sans SC\")\np1 <- ggplot(pressure, aes(x = temperature, y = pressure)) +\n  geom_point() +\n  ggtitle(label = \"默认字体设置\")\n\np2 <- p1 + theme(\n  axis.title = element_text(family = \"Noto Sans\"),\n  axis.text = element_text(family = \"Noto Serif\")\n) +\n  theme(\n    title = element_text(family = \"Noto Serif SC\")\n  ) +\n  ggtitle(label = \"英文字体设置\")\n\np3 <- p1 + labs(x = \"温度\", y = \"压力\") +\n  theme(\n    axis.title = element_text(family = \"Noto Serif SC\"),\n    axis.text = element_text(family = \"Noto Serif\")\n  ) +\n  ggtitle(label = \"中文字体设置\")\n\np4 <- p1 + labs(\n  x = \"温度\", y = \"压力\", title = \"散点图\",\n  subtitle = \"Vapor Pressure of Mercury as a Function of Temperature\",\n  caption = paste(\"Data on the relation \n                  between temperature in degrees Celsius and\",\n    \"vapor pressure of mercury in millimeters (of mercury).\",\n    sep = \"\\n\"\n  )\n) +\n  theme(\n    axis.title = element_text(family = \"Noto Serif SC\"),\n    axis.text.x = element_text(family = \"Noto Serif\"),\n    axis.text.y = element_text(family = \"Noto Sans\"),\n    title = element_text(family = \"Noto Serif SC\"),\n    plot.subtitle = element_text(family = \"Noto Sans\", size = rel(0.7)),\n    plot.caption = element_text(family = \"Noto Sans\", size = rel(0.6))\n  ) +\n  ggtitle(label = \"任意字体设置\")\n\n(p1 + p2) / (p3 + p4)\n# brew install font-roboto\n# 导入字体\n# hrbrthemes::import_roboto_condensed()\nsysfonts::font_add_google(name = \"Roboto Condensed\", family = \"Roboto Condensed\")\nlibrary(hrbrthemes)\nggplot(mtcars, aes(mpg, wt)) +\n  geom_point() +\n  labs(\n    x = \"Fuel efficiency (mpg)\", y = \"Weight (tons)\",\n    title = \"Seminal ggplot2 scatterplot example\",\n    subtitle = \"A plot that is only useful for demonstration purposes\",\n    caption = \"Brought to you by the letter 'g'\"\n  ) +\n  theme_ipsum(base_family = \"Roboto Condensed\")\nggplot(mtcars, aes(mpg, wt)) +\n  geom_point() +\n  labs(\n    x = \"Fuel efficiency (mpg)\", y = \"Weight (tons)\",\n    title = \"Seminal ggplot2 scatterplot example\",\n    subtitle = \"A plot that is only useful for demonstration purposes\",\n    caption = \"Brought to you by the letter 'g'\"\n  ) +\n  theme_ipsum(base_family = \"Noto Sans\")"},{"path":"chap-data-visualization.html","id":"subsec-showtext","chapter":"第 11 章 数据可视化","heading":"11.2.2 思源字体","text":"邱怡轩开发的 showtext 包支持丰富的外部字体，支持 Base R 和 ggplot2 图形，图 11.10 嵌入了 5 号思源宋体，图例和坐标轴文本使用 serif 字体，更多详细的使用文档见 [15]。\n图 11.10: showtext 包处理图里的中文\n","code":"\n# 安装 showtext 包\ninstall.packages('showtext')\n# 思源宋体\nshowtextdb::font_install(showtextdb::source_han_serif())\n# 思源黑体\nshowtextdb::font_install(showtextdb::source_han_sans())\n# ggplot(iris, aes(Sepal.Length, Sepal.Width)) +\n#   geom_point(aes(colour = Species)) +\n#   scale_colour_brewer(palette = \"Set1\") +\n#   labs(\n#     title = \"鸢尾花数据的散点图\",\n#     x = \"萼片长度\", y = \"萼片宽度\", colour = \"鸢尾花类别\",\n#     caption = \"鸢尾花数据集最早见于 Edgar Anderson (1935) \"\n#   ) +\n#   theme(\n#     title = element_text(family = \"source-han-sans-cn\"),\n#     axis.title = element_text(family = \"source-han-serif-cn\"),\n#     legend.title = element_text(family = \"source-han-serif-cn\")\n#   )\nggplot(iris, aes(Sepal.Length, Sepal.Width)) +\n  geom_point(aes(colour = Species)) +\n  scale_colour_brewer(palette = \"Set1\") +\n  labs(\n    title = \"鸢尾花数据的散点图\",\n    x = \"萼片长度\", y = \"萼片宽度\", colour = \"鸢尾花类别\",\n    caption = \"鸢尾花数据集最早见于 Edgar Anderson (1935) \"\n  ) +\n  theme(\n    title = element_text(family = \"Noto Sans SC\"),\n    axis.title = element_text(family = \"Noto Serif SC\"),\n    legend.title = element_text(family = \"Noto Serif SC\")\n  )"},{"path":"chap-data-visualization.html","id":"subsec-fontcm","chapter":"第 11 章 数据可视化","heading":"11.2.3 数学字体","text":"Winston Chang 将 Paul Murrell 的 Computer Modern 字体文件打包成 fontcm 包 [16]，fontcm 包可以在 Base R 图形中嵌入数学字体 39，图形中嵌入重音字符 40。 下面先下载、安装、加载字体，查看可被 pdf() 图形设备使用的字体列表fontcm 包提供数学字体，grDevices::embedFonts() 函数调用 Ghostscript 软件将数学字体嵌入 ggplot2 图形中，达到正确显示数学公式的目的，此方法适用于 pdf 设备保存的图形，对 cairo_pdf() 保存的 PDF 格式图形无效。为实现图 ?? 的最终效果，需要启用一个有超级牛力的 fig.process 选项，主要是传递一个函数给它，对用 R 语言生成的图形再操作。代码块选项中设置 fig.process=embed_math_fonts 可在绘图后，立即插入字体，此操作仅限于以 pdf 格式保存的图形设备，也适用于 Base R 绘制的图形，见图 ??。","code":"\nlibrary(extrafont)\nif (!\"fontcm\" %in% .packages(T)) {\n  install.packages(\"fontcm\")\n}\n# 可用的字体\nfonts()\nlibrary(fontcm)\nlibrary(ggplot2)\nlibrary(extrafont)\nlibrary(patchwork)\np <- ggplot(\n  data = data.frame(x = c(1, 5), y = c(1, 5)),\n  aes(x = x, y = y)\n) +\n  geom_point() +\n  labs(\n    x = \"Made with CM fonts\", y = \"Made with CM fonts\",\n    title = \"Made with CM fonts\"\n  )\n# 公式\neq <- \"italic(sum(frac(1, n*'!'), n==0, infinity) ==\n       lim(bgroup('(', 1 + frac(1, n), ')')^n, n %->% infinity))\"\n# 默认字体\np1 <- p + annotate(\"text\",\n  x = 3, y = 3,\n  parse = TRUE, label = eq # , family = \"CM Roman\"\n)\n# 使用 CM Roman 字体\np2 <- p + annotate(\"text\",\n  x = 3, y = 3,\n  parse = TRUE, label = eq, family = \"CM Roman\"\n) +\n  theme(\n    text = element_text(size = 10, family = \"CM Roman\"),\n    axis.title.x = element_text(face = \"italic\"),\n    axis.title.y = element_text(face = \"bold\")\n  )\np1 + p2\n# embed math fonts to pdf\nembed_math_fonts <- function(fig_path) {\n  if(knitr::is_latex_output()){\n    embedFonts(\n      file = fig_path, outfile = fig_path,\n      fontpaths = system.file(\"fonts\", package = \"fontcm\")\n    )\n  }\n  return(fig_path)\n}\npar(mar = c(4.1, 4.1, 1.5, 0.5), family = \"CM Roman\")\nx <- seq(-4, 4, len = 101)\ny <- cbind(sin(x), cos(x))\nmatplot(x, y,\n  type = \"l\", xaxt = \"n\",\n  main = expression(paste(\n    plain(sin) * phi, \"  and  \",\n    plain(cos) * phi\n  )),\n  ylab = expression(\"sin\" * phi, \"cos\" * phi),\n  xlab = expression(paste(\"Phase Angle \", phi)),\n  col.main = \"blue\"\n)\naxis(1,\n  at = c(-pi, -pi / 2, 0, pi / 2, pi),\n  labels = expression(-pi, -pi / 2, 0, pi / 2, pi)\n)"},{"path":"chap-data-visualization.html","id":"subsec-tikz-device","chapter":"第 11 章 数据可视化","heading":"11.2.4 TikZ 设备","text":"与 11.2.3 小节不同，Ralf Stubner 维护的 tikzDevice 包提供了另一种嵌入数学字体的方式，其提供的 tikzDevice::tikz() 绘图设备将图形对象转化为 TikZ 代码，调用 LaTeX 引擎编译成 PDF 文档。安装后，先测试一下 LaTeX 编译环境是否正常。确认没有问题后，下面图 11.11 的坐标轴标签，标题，图例等位置都支持数学公式，使用 tikzDevice 打造出版级的效果图。更多功能的介绍见 https://www.daqana.org/tikzDevice/。\n图 11.11: 线性回归模型\n推荐的全局 LaTeX 环境配置如下：设置默认的 LaTeX 编译引擎为 XeLaTeX，相比于 PDFLaTeX，它对中文的兼容性更好，支持多平台下的中文环境，中文字体这里采用了 Adobe 的字体，默认加载了 mathrsfs 宏包支持 \\mathcal、\\mathscr 等命令，此外， LaTeX 发行版采用谢益辉自定义的 TinyTeX。绘制独立的 PDF 图形的过程如下：","code":"\ntikzDevice::tikzTest()## \n## Active compiler:\n##  /home/runner/.TinyTeX/bin/x86_64-linux/xelatex\n##  XeTeX 3.141592653-2.6-0.999994 (TeX Live 2022)\n##  kpathsea version 6.3.4## [1] 7.90259\nx <- rnorm(10)\ny <- x + rnorm(5, sd = 0.25)\nmodel <- lm(y ~ x)\nrsq <- summary(model)$r.squared\nrsq <- signif(rsq, 4)\nplot(x, y,\n  main = \"Hello \\\\LaTeX!\", xlab = \"$x$\", ylab = \"$y$\",\n  sub = \"$\\\\mathcal{N}(x;\\\\mu,\\\\Sigma)$\"\n)\nabline(model, col = \"red\")\nmtext(paste0(\"Linear model: $R^{2}=\", rsq, \"$\"), line = 0.5)\nlegend(\"bottomright\",\n  legend = paste0(\n    \"$y = \",\n    round(coef(model)[2], 3),\n    \"x +\",\n    round(coef(model)[1], 3),\n    \"$\"\n  ),\n  bty = \"n\"\n)\noptions(\n  tinytex.engine = \"xelatex\",\n  tikzDefaultEngine = \"xetex\",\n  tikzDocumentDeclaration = \"\\\\documentclass[tikz]{standalone}\\n\",\n  tikzXelatexPackages = c(\n    \"\\\\usepackage[fontset=adobe]{ctex}\",\n    \"\\\\usepackage[default,semibold]{sourcesanspro}\",\n    \"\\\\usepackage{amsfonts,mathrsfs,amssymb}\\n\"\n  )\n)\nlibrary(tikzDevice)\ntf <- file.path(getwd(), \"tikz-regression.tex\")\ntikz(tf, width = 6, height = 5.5, pointsize = 30, standAlone = TRUE)\n# 绘图代码\ndev.off()\n# 编译成 PDF 图形\ntinytex::latexmk(file = \"tikz-regression.tex\")"},{"path":"chap-data-visualization.html","id":"subsec-xkcd-comic","chapter":"第 11 章 数据可视化","heading":"11.2.5 漫画字体","text":"下载 XKCD 字体，并刷新系统字体缓存将 XKCD 字体导入到 R 环境，以便后续被 ggplot2 图形设备调用。下图是一个使用 xkcd 字体的简单例子，更多高级特性请看 xkcd 包文档 [17]","code":"mkdir -p ~/.fonts\ncurl -fLo ~/.fonts/xkcd.ttf http://simonsoftware.se/other/xkcd.ttf\nfc-cache -fsvR -e 'library(extrafont);font_import(pattern=\"[X/x]kcd.ttf\", prompt = FALSE)'\nlibrary(xkcd)\nggplot(aes(mpg, wt), data = mtcars) +\n  geom_point() +\n  theme_xkcd()"},{"path":"chap-data-visualization.html","id":"subsec-emoji-fonts","chapter":"第 11 章 数据可视化","heading":"11.2.6 表情字体","text":"余光创开发的 emojifont 包和 Hadley 开发的 emo 包，下面使用 Noto Emoji 字体，支持的表情图见 https://www.google.com/get/noto/help/emoji/food-drink/，下面给出一个示例。先从 GitHub 安装\nemo 包，目前它还未正式发布到 CRAN 上。除了安装 emo 包，系统需要先安装好 emoji 字体，图形才会正确地渲染出来，想调用更多 emoji 图标请参考 Emoji 速查手册，给出 emoji 对应的名字。\n图 11.12: 表情字体\nNoto Color Emoji 字体在 MacOS 上有问题，为了跨平台的便携性，提供 emojifont 包的例子，要引入更多的依赖。","code":"\nremotes::install_github(\"hadley/emo\")# CentOS\nsudo dnf install -y google-noto-emoji-color-fonts \\\n  google-noto-emoji-fonts\n# MacOS\nbrew cask install font-noto-color-emoji font-noto-emoji\ndata.frame(\n  category = c(\"pineapple\", \"apple\", \"watermelon\", \"mango\", \"pear\"),\n  value = c(5, 4, 3, 6, 2)\n) |> \n  transform(category = sapply(category, emo::ji)) |> \n  ggplot(aes(x = category, y = value)) +\n  scale_y_continuous(limits = c(2, 7)) +\n  geom_text(aes(label = category), size = 12, vjust = -0.5) +\n  theme_minimal()\nlibrary(ggplot2)\nlibrary(emojifont)\n\nnames <- c(\"smile\", \"school\", \"office\", \"blush\", \"smirk\", \"heart_eyes\")\nn <- length(names):1\ne <- sapply(names, emojifont::emoji)\ndat <- data.frame(emoji_name = names, n = n, emoji = e, stringsAsFactors = F)\n\nggplot(data = dat, aes(emoji_name, n)) +\n  geom_bar(stat = \"identity\") +\n  scale_x_discrete(breaks = dat$emoji_name, labels = dat$emoji) +\n  theme(axis.text.y = element_text(size = 20, family = \"EmojiOne\")) +\n  coord_flip()"},{"path":"chap-data-visualization.html","id":"sec-colors","chapter":"第 11 章 数据可视化","heading":"11.3 配色","text":"配色真的是一门学问，有的人功力非常深厚，仅用黑白灰就可以创造出一个世界，如中国的水墨画，科波拉执导的《教父》，沃卓斯基姐妹执导的《黑客帝国》等。黑西装、白衬衫和黑领带是《黑客帝国》的经典元素，《教父》开场的黑西装、黑领结和白衬衫，尤其胸前的红玫瑰更是点睛之笔。导演将黑白灰和光影混合形成了层次丰富立体的画面，打造了一场视觉盛宴，无论是呈现在纸上还是银幕上都可以给人留下深刻的印象。正所谓食色性也，花花世界，岂能都是法印眼中的白骨！再说《红楼梦》里，芍药丛中，桃花树下，滴翠亭边，栊翠庵里，处处都是湘云、黛玉、宝钗、妙玉留下的四季诗歌。为什么需要这么多颜色模式呢？主要取决于颜色输出的通道，比如印刷机，照相机，自然界，网页，人眼等，显示器因屏幕和分辨率的不同呈现的色彩数量是不一样的。读者大概都听说过 RGB、CMYK、AdobeRGB、sRGB、P3 广色域等名词，我想这主要归功于各大电子设备厂商的宣传。普清、高清、超高清、全高清、2K、4K、5K、视网膜屏，而 HSV、HCL 估计听说的人就少很多了。本节的目的是简单阐述背后的色彩原理，颜色模式及其之间的转化，在应对天花乱坠的销售时少交一些智商税，同时，告诉读者如何在 R 环境中使用色彩。早些时候我在统计之都论坛上发帖 – R语言绘图用调色板大全 https://d.cosx.org/d/419378，如果读者希望拿来即用，不妨去看看。\n图 11.13: R 3.6.0 以前的调色板\n\n图 11.14: R 3.6.0 以后的调色板\nhcl.colors() 函数是在 R 3.6.0 引入的，之前的 R 软件版本中没有，同时内置了 110 个调色板，详见 hcl.pals()。","code":"\nfilled.contour(volcano, nlevels = 10, color.palette = terrain.colors)\nfilled.contour(volcano, nlevels = 10, color.palette = heat.colors)\nfilled.contour(volcano, nlevels = 10, color.palette = topo.colors)\nfilled.contour(volcano, nlevels = 10, color.palette = cm.colors)\nfilled.contour(volcano,\n  nlevels = 10,\n  color.palette = function(n, ...) hcl.colors(n, \"Grays\", rev = TRUE, ...)\n)\nfilled.contour(volcano,\n  nlevels = 10,\n  color.palette = function(n, ...) hcl.colors(n, \"YlOrRd\", rev = TRUE, ...)\n)\nfilled.contour(volcano,\n  nlevels = 10,\n  color.palette = function(n, ...) hcl.colors(n, \"purples\", rev = TRUE, ...)\n)\nfilled.contour(volcano,\n  nlevels = 10,\n  color.palette = function(n, ...) hcl.colors(n, \"viridis\", rev = FALSE, ...)\n)"},{"path":"chap-data-visualization.html","id":"subsec-color-palettes","chapter":"第 11 章 数据可视化","heading":"11.3.1 调色板","text":"R 预置的灰色有224种，挑出其中的调色板\n图 11.15: 灰度调色板\ngray 与 grey 是一样的，类似 color 和 colour 的关系，可能是美式和英式英语的差别，且看gray100 代表白色，gray0 代表黑色，提取灰色调色板，去掉首尾部分是必要的\n图 11.16: 提取 10 种灰色做调色板\n首先选择一组合适的颜色，比如从桃色到梨色，选择6种颜色，以此为基础，可以借助 grDevices::colorRampPalette() 函数扩充至想要的数目，用 graphics::rect() 函数预览这组颜色配制的调色板\n图 11.17: 桃色至梨色的渐变\ncolorRampPalette() 自制调色板\n图 11.18: colorRampPalette 自制调色板\n\n图 11.19: RColorBrewer 调色板\n\n图 11.20: grDevices 调色板\n\n图 11.21: grDevices 调色板\n\n图 11.22: colorspace 调色板\n除之前提到的 grDevices 包， colorspace (https://hclwizard.org/) 包 [18]–[20]，RColorBrewer 包 [21] https://colorbrewer2.org/，viridis 包、colourvalues、wesanderson、dichromat 包、pals 包，palr 包，colorRamps 包、ColorPalette 包、colortools 包就不一一详细介绍了。colormap 包基于 node.js 的 colormap 模块提供 44 个预定义的调色板\npaletteer 包收集了很多 R 包提供的调色板，同时也引入了很多依赖。根据电影 Harry Potter 制作的调色板 harrypotter，根据网站 CARTO 设计的 rcartocolor 包，colorblindr 模拟色盲环境下的配色方案。yarrr 包主要是为书籍 《YaRrr! Pirate’s Guide R》 https://github.com/ndphillips/ThePiratesGuideToR 提供配套资源，兼顾收集了一组调色板。RColorBrewer 调色板数量必须至少 3 个，这是上游 colorbrewer 的 问题，具体体现在调用\nRColorBrewer::brewer.pal(n = 2, name = \"Set2\") 时会有警告。 plotly 调用\n图 11.23: 源起\n与图 11.85 对比，图11.24 的层次更加丰富，识别性更高\n图 11.24: Spectral 调色板\n再举例子，图 11.25 是正负例对比，其中好在哪里呢？这张图要表达美国黄石国家公园的老忠实泉间歇喷发的时间规律，那么好的标准就是层次分明，以突出不同颜色之间的时间差异。这个差异，还要看起来不那么费眼睛，一目了然最好。\n图 11.25: 美国黄石国家公园的老忠实泉\nRColorBrewer 包 提供了有序 (Sequential) 、定性 (Qualitative) 和发散 (Diverging) 三类调色板，一般来讲，分别适用于连续或有序分类变量、无序分类变量、两类分层对比变量的绘图。再加上强大的 ggplot2 包内置的对颜色处理的函数，如 scale_alpha_* 、 scale_colour_* 和 scale_fill_* 等，详见：colourlovers 包借助 XML, jsonlite 和 httr 包可以在线获取网站 COLOURlovers 的调色板使用调色板调色板的描述信息获取调色板中的颜色向量","code":"\ngrep(\"^gr(a|e)y\", grep(\"gr(a|e)y\", colors(), value = TRUE), \n     value = TRUE, invert = TRUE)##  [1] \"darkgray\"       \"darkgrey\"       \"darkslategray\"  \"darkslategray1\"\n##  [5] \"darkslategray2\" \"darkslategray3\" \"darkslategray4\" \"darkslategrey\" \n##  [9] \"dimgray\"        \"dimgrey\"        \"lightgray\"      \"lightgrey\"     \n## [13] \"lightslategray\" \"lightslategrey\" \"slategray\"      \"slategray1\"    \n## [17] \"slategray2\"     \"slategray3\"     \"slategray4\"     \"slategrey\"\ngray_colors <- paste0(rep(c(\"slategray\", \"darkslategray\"), each = 4), seq(4))\nbarplot(1:8, col = gray_colors, border = NA)\nall.equal(\n  col2rgb(paste0(\"gray\", seq(100))),\n  col2rgb(paste0(\"grey\", seq(100)))\n)## [1] TRUE\nbarplot(1:8,\n  col = gray.colors(8, start = .3, end = .9),\n  main = \"gray.colors function\", border = NA\n)\n# Colors from https://github.com/johannesbjork/LaCroixColoR\ncolors_vec <- c(\"#FF3200\", \"#E9A17C\", \"#E9E4A6\", \n                \"#1BB6AF\", \"#0076BB\", \"#172869\")\n# 代码来自 ?colorspace::rainbow_hcl\npal <- function(n = 20, colors = colors, border = \"light gray\", ...) {\n  colorname <- (grDevices::colorRampPalette(colors))(n)\n  plot(0, 0,\n    type = \"n\", xlim = c(0, 1), ylim = c(0, 1),\n    axes = FALSE, ...\n  )\n  rect(0:(n - 1) / n, 0, 1:n / n, 1, col = colorname, border = border)\n}\npar(mar = rep(0, 4))\npal(n = 20, colors = colors_vec, xlab = \"Colors from Peach to Pear\", ylab = \"\")\ncreate_palette <- function(n = 1000, colors = c(\"blue\", \"orangeRed\")) {\n  color_palette <- colorRampPalette(colors)(n)\n  barplot(rep(1, times = n), col = color_palette, \n          border = color_palette, axes = FALSE)\n}\npar(mfrow = c(3, 1), mar = c(0.1, 0.1, 0.5, 0.1), xaxs = \"i\", yaxs = \"i\")\ncreate_palette(n = 1000, colors = c(\"blue\", \"orangeRed\"))\ncreate_palette(n = 1000, colors = c(\"darkgreen\", \"yellow\", \"orangered\"))\ncreate_palette(n = 1000, colors = c(\"blue\", \"white\", \"orangered\"))\npar(mar = c(0, 4, 0, 0))\nRColorBrewer::display.brewer.all()\n# 代码来自 ?palettes\ndemo.pal <- function(n, border = if (n < 32) \"light gray\" else NA,\n           main = paste(\"color palettes: alpha = 1,  n=\", n),\n           ch.col = c(\n             \"rainbow(n, start=.7, end=.1)\", \"heat.colors(n)\",\n             \"terrain.colors(n)\", \"topo.colors(n)\",\n             \"cm.colors(n)\", \"gray.colors(n, start = 0.3, end = 0.9)\"\n           )) {\n    nt <- length(ch.col)\n    i <- 1:n\n    j <- n / nt\n    d <- j / 6\n    dy <- 2 * d\n    plot(i, i + d, type = \"n\", axes = FALSE, ylab = \"\", xlab = \"\", main = main)\n    for (k in 1:nt) {\n      rect(i - .5, (k - 1) * j + dy, i + .4, k * j,\n        col = eval(parse(text = ch.col[k])), border = border\n      )\n      text(2 * j, k * j + dy / 4, ch.col[k])\n    }\n  }\nn <- if (.Device == \"postscript\") 64 else 16\n# Since for screen, larger n may give color allocation problem\npar(mar = c(0, 0, 2, 0))\ndemo.pal(n)\npar(mfrow = c(33, 1), mar = c(0, 0, .8, 0))\nfor (i in seq(32)) {\n  pal(\n    n = length((1 + 20 * (i - 1)):(20 * i)),\n    colors()[(1 + 20 * (i - 1)):(20 * i)],\n    main = paste(1 + 20 * (i - 1), \"to\", 20 * i)\n  )\n}\npal(n = 17, colors()[641:657], main = \"641 to 657\")\nlibrary(colorspace)\n## a few useful diverging HCL palettes\npar(mar = c(0,0,2,0), mfrow = c(16, 2))\n\npal(n = 16, diverge_hcl(16), main = \"diverging HCL palettes\")\npal(n = 16, diverge_hcl(16, h = c(246, 40), c = 96, l = c(65, 90)))\npal(n = 16, diverge_hcl(16, h = c(130, 43), c = 100, l = c(70, 90)))\npal(n = 16, diverge_hcl(16, h = c(180, 70), c = 70, l = c(90, 95)))\n\npal(n = 16, diverge_hcl(16, h = c(180, 330), c = 59, l = c(75, 95)))\npal(n = 16, diverge_hcl(16, h = c(128, 330), c = 98, l = c(65, 90)))\npal(n = 16, diverge_hcl(16, h = c(255, 330), l = c(40, 90)))\npal(n = 16, diverge_hcl(16, c = 100, l = c(50, 90), power = 1))\n\n## sequential palettes\npal(n = 16, sequential_hcl(16), main= \"sequential palettes\")\npal(n = 16, heat_hcl(16, h = c(0, -100), \n                     l = c(75, 40), c = c(40, 80), power = 1))\npal(n = 16, terrain_hcl(16, c = c(65, 0), l = c(45, 95), power = c(1/3, 1.5)))\npal(n = 16, heat_hcl(16, c = c(80, 30), l = c(30, 90), power = c(1/5, 1.5)))\n\n## compare base and colorspace palettes\n## (in color and desaturated)\n## diverging red-blue colors\npal(n = 16, diverge_hsv(16), main = \"diverging red-blue colors\")\npal(n = 16, diverge_hcl(16, c = 100, l = c(50, 90)))\npal(n = 16, desaturate(diverge_hsv(16)))\npal(n = 16, desaturate(diverge_hcl(16, c = 100, l = c(50, 90))))\n\n## diverging cyan-magenta colors\npal(n = 16, cm.colors(16), main = \"diverging cyan-magenta colors\")\npal(n = 16, diverge_hcl(16, h = c(180, 330), c = 59, l = c(75, 95)))\npal(n = 16, desaturate(cm.colors(16)))\npal(n = 16, desaturate(diverge_hcl(16, h = c(180, 330), c = 59, l = c(75, 95))))\n\n## heat colors\npal(n = 16, heat.colors(16), main = \"heat colors\")\npal(n = 16, heat_hcl(16))\npal(n = 16, desaturate(heat.colors(16)))\npal(n = 16, desaturate(heat_hcl(16)))\n\n## terrain colors\npal(n = 16, terrain.colors(16), main = \"terrain colors\")\npal(n = 16, terrain_hcl(16))\npal(n = 16, desaturate(terrain.colors(16)))\npal(n = 16, desaturate(terrain_hcl(16)))\n\npal(n = 16, rainbow_hcl(16, start = 30, end = 300), main = \"dynamic\")\npal(n = 16, rainbow_hcl(16, start = 60, end = 240), main = \"harmonic\")\npal(n = 16, rainbow_hcl(16, start = 270, end = 150), main = \"cold\")\npal(n = 16, rainbow_hcl(16, start = 90, end = -30), main = \"warm\")[1] \"#66C2A5\" \"#FC8D62\" \"#8DA0CB\"\nWarning message:\nIn RColorBrewer::brewer.pal(n = 2, name = \"Set2\") :\n  minimal value for n is 3, returning requested palette with 3 different levels\npar(mar = c(1, 2, 1, 0), mfrow = c(3, 2))\nset.seed(1234)\nx <- sample(seq(8), 8, replace = FALSE)\nbarplot(x, col = palette(), border = \"white\")\nbarplot(x, col = heat.colors(8), border = \"white\")\nbarplot(x, col = gray.colors(8), border = \"white\")\nbarplot(x, col = \"lightblue\", border = \"white\")\nbarplot(x, col = colorspace::sequential_hcl(8), border = \"white\")\nbarplot(x, col = colorspace::diverge_hcl(8,\n  h = c(130, 43),\n  c = 100, l = c(70, 90)\n), border = \"white\")\nexpand.grid(months = month.abb, years = 1949:1960) |> \n  transform(num = as.vector(AirPassengers)) |> \n  ggplot(aes(x = years, y = months, fill = num)) +\n  scale_fill_distiller(palette = \"Spectral\") +\n  geom_tile(color = \"white\", size = 0.4) +\n  scale_x_continuous(\n    expand = c(0.01, 0.01),\n    breaks = seq(1949, 1960, by = 1),\n    labels = 1949:1960\n  ) +\n  theme_minimal(\n    base_size = 10.54,\n    base_family = \"Noto Serif SC\"\n  ) +\n  labs(x = \"年\", y = \"月\", fill = \"人数\")\nerupt <- ggplot(faithfuld, aes(waiting, eruptions, fill = density)) +\n  geom_raster() +\n  scale_x_continuous(NULL, expand = c(0, 0)) +\n  scale_y_continuous(NULL, expand = c(0, 0)) +\n  theme(legend.position = \"none\")\np1 <- erupt + scale_fill_gradientn(colours = gray.colors(7))\np2 <- erupt + scale_fill_distiller(palette = \"Spectral\")\np3 <- erupt + scale_fill_gradientn(colours = terrain.colors(7))\np4 <- erupt + scale_fill_continuous(type = 'viridis')\n(p1 + p2) / (p3 + p4)\nls(\"package:ggplot2\", pattern = \"scale_col(ou|o)r_\")##  [1] \"scale_color_binned\"      \"scale_color_brewer\"     \n##  [3] \"scale_color_continuous\"  \"scale_color_date\"       \n##  [5] \"scale_color_datetime\"    \"scale_color_discrete\"   \n##  [7] \"scale_color_distiller\"   \"scale_color_fermenter\"  \n##  [9] \"scale_color_gradient\"    \"scale_color_gradient2\"  \n## [11] \"scale_color_gradientn\"   \"scale_color_grey\"       \n## [13] \"scale_color_hue\"         \"scale_color_identity\"   \n## [15] \"scale_color_manual\"      \"scale_color_ordinal\"    \n## [17] \"scale_color_steps\"       \"scale_color_steps2\"     \n## [19] \"scale_color_stepsn\"      \"scale_color_viridis_b\"  \n## [21] \"scale_color_viridis_c\"   \"scale_color_viridis_d\"  \n## [23] \"scale_colour_binned\"     \"scale_colour_brewer\"    \n## [25] \"scale_colour_continuous\" \"scale_colour_date\"      \n## [27] \"scale_colour_datetime\"   \"scale_colour_discrete\"  \n## [29] \"scale_colour_distiller\"  \"scale_colour_fermenter\" \n## [31] \"scale_colour_gradient\"   \"scale_colour_gradient2\" \n## [33] \"scale_colour_gradientn\"  \"scale_colour_grey\"      \n## [35] \"scale_colour_hue\"        \"scale_colour_identity\"  \n## [37] \"scale_colour_manual\"     \"scale_colour_ordinal\"   \n## [39] \"scale_colour_steps\"      \"scale_colour_steps2\"    \n## [41] \"scale_colour_stepsn\"     \"scale_colour_viridis_b\" \n## [43] \"scale_colour_viridis_c\"  \"scale_colour_viridis_d\"\nls(\"package:ggplot2\", pattern = \"scale_fill_\")##  [1] \"scale_fill_binned\"     \"scale_fill_brewer\"     \"scale_fill_continuous\"\n##  [4] \"scale_fill_date\"       \"scale_fill_datetime\"   \"scale_fill_discrete\"  \n##  [7] \"scale_fill_distiller\"  \"scale_fill_fermenter\"  \"scale_fill_gradient\"  \n## [10] \"scale_fill_gradient2\"  \"scale_fill_gradientn\"  \"scale_fill_grey\"      \n## [13] \"scale_fill_hue\"        \"scale_fill_identity\"   \"scale_fill_manual\"    \n## [16] \"scale_fill_ordinal\"    \"scale_fill_steps\"      \"scale_fill_steps2\"    \n## [19] \"scale_fill_stepsn\"     \"scale_fill_viridis_b\"  \"scale_fill_viridis_c\" \n## [22] \"scale_fill_viridis_d\"\nlibrary(colourlovers)\npalette1 <- clpalette('113451')\npalette2 <- clpalette('92095')\npalette3 <- clpalette('629637')\npalette4 <- clpalette('694737')\nlayout(matrix(1:4, nrow = 2))\npar(mar = c(2, 2, 2, 2))\n\nbarplot(VADeaths, col = swatch(palette1)[[1]], border = NA)\nbarplot(VADeaths, col = swatch(palette2)[[1]], border = NA)\nbarplot(VADeaths, col = swatch(palette3)[[1]], border = NA)\nbarplot(VADeaths, col = swatch(palette4)[[1]], border = NA)\npalette1\nswatch(palette1)[[1]]"},{"path":"chap-data-visualization.html","id":"subsec-color-schames","chapter":"第 11 章 数据可视化","heading":"11.3.2 颜色模式","text":"不同的颜色模式，从 RGB 到 HCL 的基本操作 https://stat545.com/block018_colors.html\n图 11.26: HCL调色\nR 内置了 502 种不同颜色的名称，下面随机地选取 20 种颜色R 包 grDevices 提供 hcl 调色板41 调制两个色板\n图 11.27: 桃色至梨色的渐变\n\n图 11.28: Hue-Saturation-Value (HSV) 颜色模型\n举例子，直方图配色与不配色\n图 11.29: 直方图\n\n图 11.30: 直方图\n","code":"\n# https://github.com/hadley/ggplot2-book\nhcl <- expand.grid(x = seq(-1, 1, length = 100), y = seq(-1, 1, length = 100)) |>\n  subset(subset = x^2 + y^2 < 1) |>\n  transform(\n    r = sqrt(x^2 + y^2)\n  ) |>\n  transform(\n    h = 180 / pi * atan2(y, x),\n    c = 100 * r,\n    l = 65\n  ) |>\n  transform(\n    colour = hcl(h, c, l)\n  )\n\n# sin(h) = y / (c / 100)\n# y = sin(h) * c / 100\n\ncols <- scales::hue_pal()(5)\nselected <- colorspace::RGB(t(col2rgb(cols)) / 255) %>%\n  as(\"polarLUV\") %>%\n  colorspace::coords() %>%\n  as.data.frame() %>%\n  transform(\n    x = cos(H / 180 * pi) * C / 100,\n    y = sin(H / 180 * pi) * C / 100,\n    colour = cols\n  )\n\nggplot(hcl, aes(x, y)) +\n  geom_raster(aes(fill = colour)) +\n  scale_fill_identity() +\n  scale_colour_identity() +\n  coord_equal() +\n  scale_x_continuous(\"\", breaks = NULL) +\n  scale_y_continuous(\"\", breaks = NULL) +\n  geom_point(data = selected, size = 10, color = \"white\") +\n  geom_point(data = selected, size = 5, aes(colour = colour))\nsample(colors(TRUE), 20)##  [1] \"royalblue4\"      \"plum1\"           \"papayawhip\"      \"darkslategray\"  \n##  [5] \"darkturquoise\"   \"gray79\"          \"darkred\"         \"maroon4\"        \n##  [9] \"darkolivegreen4\" \"springgreen2\"    \"orchid4\"         \"lemonchiffon2\"  \n## [13] \"paleturquoise4\"  \"gray49\"          \"cyan\"            \"antiquewhite1\"  \n## [17] \"yellow2\"         \"gray13\"          \"cadetblue2\"      \"gray77\"\n# Colors from https://github.com/johannesbjork/LaCroixColoR\ncolor_pal <- c(\"#FF3200\", \"#E9A17C\", \"#E9E4A6\", \"#1BB6AF\", \"#0076BB\", \"#172869\")\nn <- 16\nmore_colors <- (grDevices::colorRampPalette(color_pal))(n)\nscales::show_col(colours = more_colors)\n# colors in colortools from http://www.gastonsanchez.com/\nfish_pal <- c(\n  \"#69D2E7\", \"#6993E7\", \"#7E69E7\", \"#BD69E7\",\n  \"#E769D2\", \"#E76993\", \"#E77E69\", \"#E7BD69\",\n  \"#D2E769\", \"#93E769\", \"#69E77E\", \"#69E7BD\"\n)\nmore_colors <- (grDevices::colorRampPalette(fish_pal))(n)\nscales::show_col(colours = more_colors)\nrgb(red = 86, green = 180, blue = 233, maxColorValue = 255) # \"#56B4E9\"## [1] \"#56B4E9\"\nrgb(red = 0, green = 158, blue = 115, maxColorValue = 255) # \"#009E73\"## [1] \"#009E73\"\nrgb(red = 240, green = 228, blue = 66, maxColorValue = 255) # \"#F0E442\"## [1] \"#F0E442\"\nrgb(red = 0, green = 114, blue = 178, maxColorValue = 255) # \"#0072B2\"## [1] \"#0072B2\"\n# library(pander)\n# evalsOptions('graph.unify', TRUE)\n# panderOptions('graph.colors') 获取调色板\n# https://www.fontke.com/tool/rgbschemes/ 在线配色\ncols <- c(\n  \"#56B4E9\", \"#009E73\", \"#F0E442\", \"#0072B2\",\n  \"#D55E00\", \"#CC79A7\", \"#999999\", \"#E69F00\"\n)\nhist(mtcars$hp, col = \"#56B4E9\", border = \"white\", grid = grid())\nggplot(mtcars) +\n  geom_histogram(aes(x = hp, fill = as.factor(..count..)),\n    color = \"white\", bins = 6\n  ) +\n  scale_fill_manual(values = rep(\"#56B4E9\", 10)) +\n  ggtitle(\"Histogram with ggplot2\") +\n  theme_minimal() +\n  theme(legend.position = \"none\") "},{"path":"chap-data-visualization.html","id":"rgb","chapter":"第 11 章 数据可视化","heading":"11.3.2.1 RGB","text":"红(red)、绿(green)、蓝(blue)是三原色函数参数说明：red, blue, green, alpha 取值范围\\([0,M]\\)，\\(M\\) 是 maxColorValuenames 字符向量，给这组颜色值取名maxColorValue 红，绿，蓝三色范围的最大值The colour specification refers standard sRGB colorspace (IEC standard 61966).rgb 产生一种颜色，如 rgb(255, 0, 0, maxColorValue = 255) 的颜色是 \"#FF0000\" ，这是一串16进制数，每两个一组，那么一组有 \\(16^2 = 256\\) 种组合，整个一串有 \\(256^3 = 16777216\\) 种组合，这就是RGB表达的所有颜色。","code":"\nrgb(red, green, blue, alpha, names = NULL, maxColorValue = 1)"},{"path":"chap-data-visualization.html","id":"hsl","chapter":"第 11 章 数据可视化","heading":"11.3.2.2 HSL","text":"色相饱和度亮度 hue–saturation–luminance (HSL)","code":""},{"path":"chap-data-visualization.html","id":"hsv","chapter":"第 11 章 数据可视化","heading":"11.3.2.3 HSV","text":"Create vector colors vectors specifying hue, saturation value. 色相饱和度值This function creates vector colors corresponding given values HSV space. rgb rgb2hsv RGB HSV conversion;hsv函数通过设置色调、饱和度和亮度获得颜色，三个值都是0-1的相对量RGB HSV HSL 都是不连续的颜色空间，缺点","code":"\nhsv(h = 1, s = 1, v = 1, alpha)"},{"path":"chap-data-visualization.html","id":"hcl","chapter":"第 11 章 数据可视化","heading":"11.3.2.4 HCL","text":"基于感知的颜色空间替代RGB颜色空间通过指定色相(hue)，色度(chroma)和亮度(luminance/lightness)，创建一组（种）颜色函数参数说明：h 颜色的色调，取值范围为[0,360]，0、120、240分别对应红色、绿色、蓝色h 颜色的色调，取值范围为[0,360]，0、120、240分别对应红色、绿色、蓝色c 颜色的色度，其上界取决于色调和亮度c 颜色的色度，其上界取决于色调和亮度l 颜色的亮度，取值范围[0,100]，给定色调和色度，只有一部分子集可用l 颜色的亮度，取值范围[0,100]，给定色调和色度，只有一部分子集可用alpha 透明度，取值范围[0,1]，0 和1分别表示透明和不透明alpha 透明度，取值范围[0,1]，0 和1分别表示透明和不透明This function corresponds polar coordinates CIE-LUV color space选色为什么这么难色相与阴影相比是无关紧要的，色相对于标记和分类很有用，但表示（精细的）空间数据或形状的效果较差。颜色是改善图形的好工具，但糟糕的配色方案 (color schemes) 可能会导致比灰度调色板更差的效果。[18]黑、白、灰，看似有三种颜色，其实只有一种颜色，黑和白只是灰色的两极，那么如何设置灰色梯度，使得人眼比较好区分它们呢？这样获得的调色板适用于什么样的绘图环境呢？","code":"\nhcl(h = 0, c = 35, l = 85, alpha, fixup = TRUE)"},{"path":"chap-data-visualization.html","id":"cmyk","chapter":"第 11 章 数据可视化","heading":"11.3.2.5 CMYK","text":"印刷三原色：青 (cyan)、品红 (magenta)、黄 (yellow)颜色模式转化col2rgb() 、rgb2hsv() 和 rgb() 函数 hex2RGB() 函数 colorspace col2hcl() 函数 scales col2HSV() colortools col2hex()","code":"\ncol2rgb(\"lightblue\") # color to  RGB##       [,1]\n## red    173\n## green  216\n## blue   230\nscales::col2hcl(\"lightblue\") # color to HCL## [1] \"#ADD8E6\"\n# palr::col2hex(\"lightblue\") # color to HEX\n# colortools::col2HSV(\"lightblue\") # color to HSV\n\nrgb(173, 216, 230, maxColorValue = 255) # RGB to HEX## [1] \"#ADD8E6\"\ncolorspace::hex2RGB(\"#ADD8E6\") # HEX to RGB##              R         G         B\n## [1,] 0.6784314 0.8470588 0.9019608\nrgb(.678, .847, .902, maxColorValue = 1) # RGB to HEX## [1] \"#ADD8E6\"\nrgb2hsv(173, 216, 230, maxColorValue = 255) # RGB to HSV##        [,1]\n## h 0.5409357\n## s 0.2478261\n## v 0.9019608"},{"path":"chap-data-visualization.html","id":"subsec-latex-colors","chapter":"第 11 章 数据可视化","heading":"11.3.3 LaTeX 配色","text":"LaTeX 宏包 xcolor 中定义颜色的常用方式有两种，其一，\\textcolor{green!40!yellow} 表示 40% 的绿色和 60% 的黄色混合色彩，其二，\\textcolor[HTML]{34A853} HEX 表示的色彩直接在 LaTeX 文档中使用的方式，类似地 \\textcolor[RGB]{52,168,83} 也表示 Google 图标中的绿色。对应于 R 中的调用方式为：","code":"\\documentclass[tikz,border=10pt]{standalone}\n\\begin{document}\n\\begin{tikzpicture}\n\\draw (0,0) rectangle (2,1) node [midway] {\\textcolor[RGB]{52,168,83}{Hello} \\textcolor[HTML]{34A853}{\\TeX}};\n\\end{tikzpicture}\n\\end{document}\nrgb(52, 168, 83, maxColorValue = 255)## [1] \"#34A853\""},{"path":"chap-data-visualization.html","id":"subsec-ggplot2-colors","chapter":"第 11 章 数据可视化","heading":"11.3.4 ggplot2 配色","text":"\n图 11.31: 几种不同的箱线图\n","code":"\nboxplot(weight ~ group,\n  data = PlantGrowth, col = \"lightgray\",\n  notch = FALSE, varwidth = TRUE\n)\n# 类似 boxplot\nggplot(data = PlantGrowth, aes(x = group, y = weight)) +\n  geom_boxplot(notch = FALSE, varwidth = TRUE, fill = \"lightgray\")\n\n# 默认调色板\nggplot(data = PlantGrowth, aes(x = group, y = weight, fill = group)) +\n  geom_boxplot(notch = FALSE, varwidth = TRUE)\n\n# Google 调色板\nggplot(data = PlantGrowth, aes(x = group, y = weight, fill = group)) +\n  geom_boxplot(notch = FALSE, varwidth = TRUE) +\n  scale_fill_manual(values = c(\"#4285f4\", \"#34A853\", \"#FBBC05\", \"#EA4335\"))"},{"path":"chap-data-visualization.html","id":"sec-gallery","chapter":"第 11 章 数据可视化","heading":"11.4 图库","text":"","code":""},{"path":"chap-data-visualization.html","id":"sec-ggplot2-pie","chapter":"第 11 章 数据可视化","heading":"11.4.1 饼图","text":"我对饼图是又爱又恨，爱的是它表示百分比的时候，往往让读者联想到蛋糕，份额这类根深蒂固的情景，从而让数字通俗易懂、深入人心，是一种很好的表达方式，恨的也是这一点，我用柱状图表达不香吗？人眼对角度的区分度远不如柱状图呢，特别是当两个类所占的份额比较接近的时候，所以很多时候，除了用饼图表达份额，还会在旁边标上百分比，从数据可视化的角度来说，如图 11.32 所示，这是信息冗余！\n图 11.32: 饼图\nplot_ly(type = \"pie\", ... ) 和添加图层 add_pie() 的效果是一样的\n图 11.33: 饼图\n设置参数 hole 可以绘制环形饼图，比如 hole = 0.6","code":"\nBOD %>% transform(., ratio = demand / sum(demand)) %>% \n  ggplot(., aes(x = \"\", y = demand, fill = reorder(Time, demand))) +\n  geom_bar(stat = \"identity\", show.legend = FALSE, color = \"white\") +\n  coord_polar(theta = \"y\") +\n  geom_text(aes(x = 1.6, label = paste0(round(ratio, digits = 4) * 100, \"%\")),\n    position = position_stack(vjust = 0.5), color = \"black\"\n  ) +\n  geom_text(aes(x = 1.2, label = Time),\n    position = position_stack(vjust = 0.5), color = \"black\"\n  ) +\n  theme_void(base_size = 14)\ndat = aggregate(carat ~ cut, data = diamonds, FUN = length)\nplotly::plot_ly() %>%\n  plotly::add_pie(\n    data = dat, labels = ~cut, values = ~carat,\n    name = \"简单饼图1\", domain = list(row = 0, column = 0)\n  ) %>%\n  plotly::add_pie(\n    data = dat, labels = ~cut, values = ~carat, hole = 0.6,\n    textposition = \"inside\", textinfo = \"label+percent\",\n    name = \"简单饼图2\", domain = list(row = 0, column = 1)\n  ) %>%\n  plotly::layout(\n    title = \"多图布局\", showlegend = F,\n    grid = list(rows = 1, columns = 2),\n    xaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE),\n    yaxis = list(showgrid = FALSE, zeroline = FALSE, showticklabels = FALSE)\n  ) %>% \n  plotly::config(displayModeBar = FALSE)"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-map","chapter":"第 11 章 数据可视化","heading":"11.4.2 地图","text":"USArrests 数据集描述了1973年美国50个州每10万居民中因袭击、抢劫和强奸而逮捕的人，以及城市人口占比。这里的地图是指按照行政区划为边界的示意图，比如图 11.34\n图 11.34: 1975年美国各州犯罪事件\n先来看看中国及其周边，见图11.35，这个地图的缺陷就是中国南海及九段线没有标记，台湾和中国大陆不是一种颜色标记，这里的地图数据来自 R 包 maps 和 mapdata，像这样的地图就不宜在国内正式刊物上出现。\n图 11.35: 中国及其周边\n绘制真正的地图需要考虑投影坐标系，观察角度、分辨率、政策法规等一系列因素，它是一种复杂的图形，如图 11.36 所示。\n图 11.36: 画地图的正确姿势\nGoogle 地图\n图 11.37: Google 地图示例\n","code":"\nlibrary(maps)\ncrimes <- data.frame(state = tolower(rownames(USArrests)), USArrests)\n# 等价于 crimes %>% tidyr::pivot_longer(Murder:Rape)\nvars <- lapply(names(crimes)[-1], function(j) {\n  data.frame(state = crimes$state, variable = j, value = crimes[[j]])\n})\ncrimes_long <- do.call(\"rbind\", vars)\nstates_map <- map_data(\"state\")\nggplot(crimes, aes(map_id = state)) +\n  geom_map(aes(fill = Murder), map = states_map) +\n  expand_limits(x = states_map$long, y = states_map$lat) +\n  scale_fill_binned(type = \"viridis\") +\n  coord_map() +\n  theme_minimal()\nlibrary(maps)\nlibrary(mapdata)\neast_asia <- map_data(\"worldHires\",\n  region = c(\n    \"Japan\", \"Taiwan\", \"China\",\n    \"North Korea\", \"South Korea\"\n  )\n)\nggplot(east_asia, aes(x = long, y = lat, group = group, fill = region)) +\n  geom_polygon(colour = \"black\") +\n  scale_fill_brewer(palette = \"Set2\") +\n  coord_map() +\n  theme_minimal()\nworldmap <- map_data(\"world\")\n\n# 默认 mercator 投影下的默认视角 c(90, 0, mean(range(x)))\nggplot(worldmap, aes(long, lat, group = group)) +\n  geom_polygon(aes(fill = region), show.legend = FALSE) +\n  coord_map(\n    xlim = c(-120, 40), ylim = c(30, 90)\n  )\n\n# 换观察角度\nggplot(worldmap, aes(long, lat, group = group)) +\n  geom_polygon(aes(fill = region), show.legend = FALSE) +\n  coord_map(\n    xlim = c(-120, 40), ylim = c(30, 90),\n    orientation = c(90, 0, 0)\n  )\n\n# 换投影坐标系\nggplot(worldmap, aes(long, lat, group = group)) +\n  geom_polygon(aes(fill = region), show.legend = FALSE) +\n  coord_map(\"ortho\",\n    xlim = c(-120, 40), ylim = c(30, 90)\n  )\n\n# 二者皆换\nggplot(worldmap, aes(long, lat, group = group)) +\n  geom_polygon(aes(fill = region), show.legend = FALSE) +\n  coord_map(\"ortho\",\n    xlim = c(-120, 40), ylim = c(30, 90),\n    orientation = c(90, 0, 0)\n  )\nlibrary(RgoogleMaps)\n# 一组坐标的中心位置\nlat <- c(40.702147, 40.718217, 40.711614)\nlon <- c(-74.012318, -74.015794, -73.998284)\ncenter <- c(mean(lat), mean(lon))\nzoom <- min(MaxZoom(range(lat), range(lon)))\n# 矩形对角线的两个顶点\nbb <- qbbox(lat, lon)\n# 获取地图数据\nmyMap <- GetMap(center, size = c(640, 640), zoom = zoom, type = \"osm\")\n# 在地图上添加红、蓝、绿三个点\nPlotOnStaticMap(myMap,\n  lat = lat, lon = lon, pch = 20, cex = 10,\n  col = c(\"red\", \"blue\", \"green\")\n)"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-heatmap","chapter":"第 11 章 数据可视化","heading":"11.4.3 热图","text":"Zuguang Gu 开发的 ComplexHeatmap 包实现复杂数据的可视化，用以发现关联数据集之间的模式。特别地，比如基因数据、生存数据等，更多应用见开发者的书籍 ComplexHeatmap 完全手册 。 R 包发布在 Bioconductor 上 https://www.bioconductor.org/packages/ComplexHeatmap。使用之前我要确保已经安装 BiocManager 包，这个包负责管理 Bioconductor 上所有的包，需要先安装它，然后安装 ComplexHeatmap 包 [22]。","code":"\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\nBiocManager::install(\"ComplexHeatmap\")"},{"path":"chap-data-visualization.html","id":"ggplot2-scatter","chapter":"第 11 章 数据可视化","heading":"11.4.4 散点图","text":"下面以 diamonds 数据集为例展示 ggplot2 的绘图过程，首先加载 diamonds 数据集，查看数据集的内容数值型变量 carat 作为 x 轴\n图 11.38: 绘图过程\n图 11.38 的基础上添加数据图层\n图 11.39: 添加数据图层\n给散点图11.39上色\n图 11.40: 散点图配色\n\n图 11.41: 格式化坐标轴刻度标签\n让另一变量 cut 作为颜色分类指标\n图 11.42: 分类散点图\n当然还有一种类似的表示就是分组，默认情况下，ggplot2将所有观测点视为一组，以分类变量 cut 来分组\n图 11.43: 分组\n在图11.43 上没有体现出来分组的意思，下面以 cut 分组线性回归为例\n图 11.44: 分组线性回归\n\n图 11.45: 分组线性回归\n我们当然可以选择更加合适的拟合方式，如局部多项式平滑 loess 但是该方法不太适用观测值比较多的情况，因为它会占用比较多的内存，建议使用广义可加模型作平滑拟合\n图 10.36: 局部多项式平滑\n\n图 11.46: 数据分组应用广义可加平滑\nggfortify 包支持更多的统计分析结果的可视化。为了更好地区分开组别，我们在图11.46的基础上分面或者配色\n图 11.47: 分组分面\n\n图 11.48: 分组配色\n在分类散点图的另一种表示方法就是分面图，以 cut 变量作为分面的依据\n图 11.49: 分面散点图\n给图 11.49 上色\n图 11.50: 给分面散点图上色\n在图11.50的基础上，给不同的类上不同的颜色\n图 11.51: 给不同的类上不同的颜色\n去掉图例，此时图例属于冗余信息了\n图 11.52: 去掉图例\n四块土地，所施肥料不同，肥力大小顺序 4 < 2 < 3 < 1 小麦产量随肥力的变化\n图 10.37: 多个图例\n\n图 11.53: 分类散点图\n图层、分组、分面和散点图介绍完了，接下来就是其它统计图形，如箱线图，小提琴图和条形图\n图 10.39: 1948年至1960年航班乘客人数变化\n","code":"\ndata(diamonds)\nstr(diamonds)## tibble [53,940 × 10] (S3: tbl_df/tbl/data.frame)\n##  $ carat  : num [1:53940] 0.23 0.21 0.23 0.29 0.31 0.24 0.24 0.26 0.22 0.23 ...\n##  $ cut    : Ord.factor w/ 5 levels \"Fair\"<\"Good\"<..: 5 4 2 4 2 3 3 3 1 3 ...\n##  $ color  : Ord.factor w/ 7 levels \"D\"<\"E\"<\"F\"<\"G\"<..: 2 2 2 6 7 7 6 5 2 5 ...\n##  $ clarity: Ord.factor w/ 8 levels \"I1\"<\"SI2\"<\"SI1\"<..: 2 3 5 4 2 6 7 3 4 5 ...\n##  $ depth  : num [1:53940] 61.5 59.8 56.9 62.4 63.3 62.8 62.3 61.9 65.1 59.4 ...\n##  $ table  : num [1:53940] 55 61 65 58 58 57 57 55 61 61 ...\n##  $ price  : int [1:53940] 326 326 327 334 335 336 336 337 337 338 ...\n##  $ x      : num [1:53940] 3.95 3.89 4.05 4.2 4.34 3.94 3.95 4.07 3.87 4 ...\n##  $ y      : num [1:53940] 3.98 3.84 4.07 4.23 4.35 3.96 3.98 4.11 3.78 4.05 ...\n##  $ z      : num [1:53940] 2.43 2.31 2.31 2.63 2.75 2.48 2.47 2.53 2.49 2.39 ...\nggplot(diamonds, aes(x = carat))\nggplot(diamonds, aes(x = carat, y = price))\nggplot(diamonds, aes(x = carat, color = cut))\nggplot(diamonds, aes(x = carat), color = \"steelblue\")\nsub_diamonds <- diamonds[sample(1:nrow(diamonds), 1000), ]\nggplot(sub_diamonds, aes(x = carat, y = price)) +\n  geom_point()\nggplot(sub_diamonds, aes(x = carat, y = price)) +\n  geom_point(color = \"steelblue\")\nggplot(sub_diamonds, aes(x = carat, y = price)) +\n  geom_point(color = \"steelblue\") +\n  scale_y_continuous(\n    labels = scales::unit_format(unit = \"k\", scale = 1e-3),\n    breaks = seq(0, 20000, 4000)\n  )\nggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) +\n  geom_point()\nggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) +\n  geom_point()\nggplot(sub_diamonds, aes(x = carat, y = price)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\nggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\nggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) +\n  geom_point() +\n  geom_smooth(method = \"loess\")\nggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) +\n  geom_point() +\n  geom_smooth(method = \"gam\", formula = y ~ s(x, bs = \"cs\"))\nggplot(sub_diamonds, aes(x = carat, y = price, group = cut)) +\n  geom_point() +\n  geom_smooth(method = \"gam\", formula = y ~ s(x, bs = \"cs\")) +\n  facet_grid(~cut)\nggplot(sub_diamonds, aes(x = carat, y = price, group = cut, color = cut)) +\n  geom_point() +\n  geom_smooth(method = \"gam\", formula = y ~ s(x, bs = \"cs\"))\nggplot(sub_diamonds, aes(x = carat, y = price)) +\n  geom_point() +\n  facet_grid(~cut)\nggplot(sub_diamonds, aes(x = carat, y = price)) +\n  geom_point(color = \"steelblue\") +\n  facet_grid(~cut)\nggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) +\n  geom_point() +\n  facet_grid(~cut)\nggplot(sub_diamonds, aes(x = carat, y = price, color = cut)) +\n  geom_point(show.legend = FALSE) +\n  facet_grid(~cut)\ndata(Wheat2, package = \"nlme\") # Wheat Yield Trials\nlibrary(colorspace)\nggplot(Wheat2, aes(longitude, latitude)) +\n  geom_point(aes(size = yield, colour = Block)) +\n  scale_color_discrete_sequential(palette = \"Viridis\") +\n  scale_x_continuous(breaks = seq(0, 30, 5)) +\n  scale_y_continuous(breaks = seq(0, 50, 10))\nggplot(mtcars, aes(x = hp, y = mpg, color = factor(am))) +\n  geom_point()\ndat <- as.data.frame(cbind(rep(1948 + seq(12), each = 12), rep(seq(12), 12), AirPassengers))\ncolnames(dat) <- c(\"year\", \"month\", \"passengers\")\n\nggplot(data = dat, aes(x = as.factor(year), y = as.factor(month))) +\n  stat_sum(aes(size = passengers), colour = \"lightblue\") +\n  scale_size(range = c(1, 10), breaks = seq(100, 650, 50)) +\n  labs(x = \"Year\", y = \"Month\", colour = \"Passengers\") +\n  theme_minimal()"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-barplot","chapter":"第 11 章 数据可视化","heading":"11.4.5 条形图","text":"条形图特别适合分类变量的展示，我们这里展示钻石切割质量 cut 不同等级的数量，当然我们可以直接展示各类的数目，在图层 geom_bar 中指定 stat=\"identity\"\n图 11.54: 频数条形图\n还有另外三种表示方法我们还可以在图 11.54 的基础上再添加一个分类变量钻石的纯净度 clarity，形成堆积条形图\n图 11.55: 堆积条形图\n再添加一个分类变量钻石颜色 color 比较好的做法是分面\n图 11.56: 分面堆积条形图\n实际上，绘制图11.56包含了对分类变量的分组计数过程，如下还有一种堆积的方法是按比例，而不是按数量，如图11.57\n图 11.57: 比例堆积条形图\n接下来就是复合条形图\n图 11.58: 复合条形图\n再添加一个分类变量，就是需要分面大法了，图 11.58 展示了三个分类变量，其实我们还可以再添加一个分类变量用作分面的列依据\n图 11.59: 分面复合条形图\n图 11.59 展示的数据如下\n图 11.60: 条形图的四种常见形态\n以数据集 diamonds 为例，按照纯净度 clarity 和切工 cut 分组统计钻石的数量，再按切工分组统计不同纯净度的钻石数量占比，如表 11.2 所示表 11.2: 数值和比例组合呈现分别以堆积条形图和百分比堆积条形图展示，添加注释到条形图上，见 11.61\n图 11.61: 添加注释到条形图\n借助 plotly 制作相应的动态百分比堆积条形图\n图 11.62: 百分比堆积条形图\n\n图 11.62: 百分比堆积条形图\n\n图 11.62: 百分比堆积条形图\n\n图 11.62: 百分比堆积条形图\n","code":"\n# 需要映射数据框的两个变量，相当于自己先计算了每类的数量\nwith(diamonds, table(cut))## cut\n##      Fair      Good Very Good   Premium     Ideal \n##      1610      4906     12082     13791     21551\ncut_df <- as.data.frame(table(diamonds$cut))\nggplot(cut_df, aes(x = Var1, y = Freq)) + geom_bar(stat = \"identity\")\nggplot(diamonds, aes(x = cut)) + geom_bar()\nggplot(diamonds, aes(x = cut)) + geom_bar(stat = \"count\")\nggplot(diamonds, aes(x = cut, y = ..count..)) + geom_bar()\nggplot(diamonds, aes(x = cut, y = stat(count))) + geom_bar()\nggplot(diamonds, aes(x = cut, fill = clarity)) + geom_bar()\nggplot(diamonds, aes(x = color, fill = clarity)) +\n  geom_bar() +\n  facet_grid(~cut)\nwith(diamonds, table(cut, color))##            color\n## cut            D    E    F    G    H    I    J\n##   Fair       163  224  312  314  303  175  119\n##   Good       662  933  909  871  702  522  307\n##   Very Good 1513 2400 2164 2299 1824 1204  678\n##   Premium   1603 2337 2331 2924 2360 1428  808\n##   Ideal     2834 3903 3826 4884 3115 2093  896\nggplot(diamonds, aes(x = color, fill = clarity)) +\n  geom_bar(position = \"fill\") +\n  facet_grid(~cut)\nggplot(diamonds, aes(x = color, fill = clarity)) +\n  geom_bar(position = \"dodge\")\nggplot(diamonds, aes(x = color, fill = clarity)) +\n  geom_bar(position = \"dodge\") +\n  facet_grid(rows = vars(cut))\nwith(diamonds, table(color, clarity, cut))## , , cut = Fair\n## \n##      clarity\n## color   I1  SI2  SI1  VS2  VS1 VVS2 VVS1   IF\n##     D    4   56   58   25    5    9    3    3\n##     E    9   78   65   42   14   13    3    0\n##     F   35   89   83   53   33   10    5    4\n##     G   53   80   69   45   45   17    3    2\n##     H   52   91   75   41   32   11    1    0\n##     I   34   45   30   32   25    8    1    0\n##     J   23   27   28   23   16    1    1    0\n## \n## , , cut = Good\n## \n##      clarity\n## color   I1  SI2  SI1  VS2  VS1 VVS2 VVS1   IF\n##     D    8  223  237  104   43   25   13    9\n##     E   23  202  355  160   89   52   43    9\n##     F   19  201  273  184  132   50   35   15\n##     G   19  163  207  192  152   75   41   22\n##     H   14  158  235  138   77   45   31    4\n##     I    9   81  165  110  103   26   22    6\n##     J    4   53   88   90   52   13    1    6\n## \n## , , cut = Very Good\n## \n##      clarity\n## color   I1  SI2  SI1  VS2  VS1 VVS2 VVS1   IF\n##     D    5  314  494  309  175  141   52   23\n##     E   22  445  626  503  293  298  170   43\n##     F   13  343  559  466  293  249  174   67\n##     G   16  327  474  479  432  302  190   79\n##     H   12  343  547  376  257  145  115   29\n##     I    8  200  358  274  205   71   69   19\n##     J    8  128  182  184  120   29   19    8\n## \n## , , cut = Premium\n## \n##      clarity\n## color   I1  SI2  SI1  VS2  VS1 VVS2 VVS1   IF\n##     D   12  421  556  339  131   94   40   10\n##     E   30  519  614  629  292  121  105   27\n##     F   34  523  608  619  290  146   80   31\n##     G   46  492  566  721  566  275  171   87\n##     H   46  521  655  532  336  118  112   40\n##     I   24  312  367  315  221   82   84   23\n##     J   13  161  209  202  153   34   24   12\n## \n## , , cut = Ideal\n## \n##      clarity\n## color   I1  SI2  SI1  VS2  VS1 VVS2 VVS1   IF\n##     D   13  356  738  920  351  284  144   28\n##     E   18  469  766 1136  593  507  335   79\n##     F   42  453  608  879  616  520  440  268\n##     G   16  486  660  910  953  774  594  491\n##     H   38  450  763  556  467  289  326  226\n##     I   17  274  504  438  408  178  179   95\n##     J    2  110  243  232  201   54   29   25\n# 漫谈条形图 https://cosx.org/2017/10/discussion-about-bar-graph\nset.seed(2020)\ndat <- data.frame(\n  age = rep(1:30, 2),\n  gender = rep(c(\"man\", \"woman\"), each = 30),\n  num = sample(x = 1:100, size = 60, replace = T)\n)\n# 重叠\np1 <- ggplot(data = dat, aes(x = age, y = num, fill = gender)) +\n  geom_col(position = \"identity\", alpha = 0.5)\n# 堆积\np2 <- ggplot(data = dat, aes(x = age, y = num, fill = gender)) +\n  geom_col(position = \"stack\")\n# 双柱\np3 <- ggplot(data = dat, aes(x = age, y = num, fill = gender)) +\n  geom_col(position = \"dodge\")\n# 百分比\np4 <- ggplot(data = dat, aes(x = age, y = num, fill = gender)) +\n  geom_col(position = \"fill\") +\n  scale_y_continuous(labels = scales::percent_format()) +\n  labs(y = \"%\")\n(p1 + p2) / (p3 + p4)\nlibrary(data.table)\ndiamonds <- as.data.table(diamonds)\ndat <- diamonds[, .(cnt = .N), by = .(cut, clarity)] %>% \n  .[, pct := cnt / sum(cnt), by = .(cut)] %>% \n  .[, pct_pp := paste0(cnt, \" (\", scales::percent(pct, accuracy = 0.01), \")\") ]\n# 分组计数 with(diamonds, table(clarity, cut))\ndcast(dat, formula = clarity ~ cut, value.var = \"pct_pp\") %>% \n  knitr::kable(align = \"crrrrr\", caption = \"数值和比例组合呈现\")\np1 = ggplot(data = dat, aes(x = cut, y = cnt, fill = clarity)) +\n  geom_col(position = \"dodge\") +\n  geom_text(aes(label = cnt), position = position_dodge(1), vjust = -0.5) +\n  geom_text(aes(label = scales::percent(pct, accuracy = 0.1)),\n    position = position_dodge(1), vjust = 1, hjust = 0.5\n  ) +\n  scale_fill_brewer(palette = \"Spectral\") +\n  labs(fill = \"clarity\", y = \"\", x = \"cut\") +\n  theme_minimal() + \n  theme(legend.position = \"top\")\n\np2 = ggplot(data = dat, aes(y = cut, x = cnt, fill = clarity)) +\n  geom_col(position = \"fill\") +\n  geom_text(aes(label = cnt), position = position_fill(1), vjust = -0.5) +\n  geom_text(aes(label = scales::percent(pct, accuracy = 0.1)),\n    position = position_fill(1), vjust = 1, hjust = 0.5\n  ) +\n  scale_fill_brewer(palette = \"Spectral\") +\n  scale_x_continuous(labels = scales::percent) +\n  labs(fill = \"clarity\", y = \"\", x = \"cut\") +\n  theme_minimal() + \n  theme(legend.position = \"top\")\n\np1 / p2\nggplot(data = diamonds, aes(x = cut, fill = clarity)) +\n  geom_bar(position = \"dodge2\") +\n  scale_fill_brewer(palette = \"Spectral\")\n# 百分比堆积条形图\nplotly::plot_ly(dat,\n  x = ~cut, color = ~clarity, y = ~pct,\n  colors = \"Spectral\", type = \"bar\",\n  text = ~ paste0(\n    cnt, \"颗 <br>\",\n    \"占比：\", scales::percent(pct, accuracy = 0.1), \"<br>\"\n  ),\n  hoverinfo = \"text\"\n) %>%\n  plotly::layout(\n    barmode = \"stack\",\n    yaxis = list(tickformat = \".0%\")\n  ) %>%\n  plotly::config(displayModeBar = FALSE)\n# `type = \"histogram\"` 以 cut 和 clarity 分组计数\nplotly::plot_ly(diamonds,\n  x = ~cut, color = ~clarity,\n  colors = \"Spectral\", type = \"histogram\"\n) %>%\n  plotly::config(displayModeBar = FALSE)\n# 堆积图\nplotly::plot_ly(diamonds,\n  x = ~cut, color = ~clarity,\n  colors = \"Spectral\", type = \"histogram\"\n) %>%\n  plotly::layout(\n    barmode = \"stack\", \n    yaxis = list(title = \"cnt\"),\n    legend = list(title = list(text = \"clarity\"))\n  ) %>%\n  plotly::config(displayModeBar = FALSE)"},{"path":"chap-data-visualization.html","id":"ggplot2-histogram","chapter":"第 11 章 数据可视化","heading":"11.4.6 直方图","text":"直方图用来查看连续变量的分布\n图 11.63: 钻石价格的分布\n堆积直方图\n图 10.44: 钻石价格随切割质量的分布\n基础 R 包与 Ggplot2 包绘制的直方图的对比，Base R 绘图速度快，代码更加稳定，Ggplot2 代码简洁，更美观\n图 11.64: 直方图\n","code":"\nggplot(diamonds, aes(price)) + geom_histogram(bins = 30)\nggplot(diamonds, aes(x = price, fill = cut)) + geom_histogram(bins = 30)\npar(mar = c(2.1, 2.1, 1.5, 0.5))\nplot(c(50, 350), c(0, 10),\n  type = \"n\", font.main = 1,\n  xlab = \"\", ylab = \"\", frame.plot = FALSE, axes = FALSE,\n  # xlab = \"hp\", ylab = \"Frequency\",\n  main = paste(\"Histogram with Base R\", paste(rep(\" \", 60), collapse = \"\"))\n)\naxis(\n  side = 1, at = seq(50, 350, 50), labels = seq(50, 350, 50),\n  tick = FALSE, las = 1, padj = 0, mgp = c(3, 0.1, 0)\n)\naxis(\n  side = 2, at = seq(0, 10, 2), labels = seq(0, 10, 2),\n  # col = \"white\", 坐标轴的颜色\n  # col.ticks 刻度线的颜色\n  tick = FALSE, # 取消刻度线\n  las = 1, # 水平方向\n  hadj = 1, # 右侧对齐\n  mgp = c(3, 0.1, 0) # 纵轴边距线设置为 0.1\n)\nabline(h = seq(0, 10, 2), v = seq(50, 350, 50), col = \"gray90\", lty = \"solid\")\nabline(h = seq(1, 9, 2), v = seq(75, 325, 50), col = \"gray95\", lty = \"solid\")\nhist(mtcars$hp,\n  col = \"#56B4E9\", border = \"white\",\n  freq = TRUE, add = TRUE\n  # labels = TRUE, axes = TRUE, ylim = c(0, 10.5),\n  # xlab = \"hp\",main = \"Histogram with Base R\"\n)\nmtext(\"hp\", 1, line = 1.0)\nmtext(\"Frequency\", 2, line = 1.0)\n\nggplot(mtcars) +\n  geom_histogram(aes(x = hp), fill = \"#56B4E9\", color = \"white\", breaks = seq(50, 350, 50)) +\n  scale_x_continuous(breaks = seq(50, 350, 50)) +\n  scale_y_continuous(breaks = seq(0, 12, 2)) +\n  labs(x = \"hp\", y = \"Frequency\", title = \"Histogram with Ggplot2\") +\n  theme_minimal(base_size = 12)"},{"path":"chap-data-visualization.html","id":"ggplot2-boxplot","chapter":"第 11 章 数据可视化","heading":"11.4.7 箱线图","text":"以 PlantGrowth 数据集为例展示箱线图，在两组不同实验条件下，植物生长的情况，纵坐标是干燥植物的量，横坐标表示不同的实验条件。这是非常典型的适合用箱线图来表达数据的场合，Y 轴对应数值型变量，X 轴对应分类变量，在 R 语言中，分类变量的类型是 factorPlantGrowth 数据量比较小，此时比较适合采用抖动散点图，抖动是为了避免点之间相互重叠，为了增加不同类别之间的识别性，我们可以用不同的点的形状或者不同的颜色来表示类别以钻石切割质量 cut 为分面依据，以钻石颜色类别 color 为 x 轴，钻石价格为 y 轴，绘制箱线图11.65\n图 11.65: 箱线图\n我们当然还可以添加钻石的纯净度 clarity 作为分面依据，那么箱线图可以为图 11.66\n图 11.66: 复合分面箱线图\n经过观察，我们发现水平分类过多，考虑用切割质量 cut 替换钻石颜色 color 绘图，但是由于分类过细，图信息展示不简练，反而不好，如图 11.67\n图 11.67: 箱线图配色\n","code":"\ndata(\"PlantGrowth\")\nstr(PlantGrowth)## 'data.frame':    30 obs. of  2 variables:\n##  $ weight: num  4.17 5.58 5.18 6.11 4.5 4.61 5.17 4.53 5.33 5.14 ...\n##  $ group : Factor w/ 3 levels \"ctrl\",\"trt1\",..: 1 1 1 1 1 1 1 1 1 1 ...\nggplot(data = PlantGrowth, aes(x = group, y = weight)) + geom_boxplot()\nggplot(data = PlantGrowth, aes(x = group, y = weight, shape = group)) + geom_jitter()\nggplot(data = PlantGrowth, aes(x = group, y = weight, color = group)) + geom_jitter()\nboxplot(weight ~ group,\n  data = PlantGrowth,\n  ylab = \"Dried weight of plants\", col = \"lightgray\",\n  notch = FALSE, varwidth = TRUE\n)\nggplot(diamonds, aes(x = color, y = price, color = cut)) +\n  geom_boxplot(show.legend = FALSE) +\n  facet_grid(~cut)\nggplot(diamonds, aes(x = color, y = price, color = cut)) +\n  geom_boxplot(show.legend = FALSE) +\n  facet_grid(clarity ~ cut)\nggplot(diamonds, aes(x = cut, y = price, color = cut)) +\n  geom_boxplot(show.legend = FALSE) +\n  facet_grid(clarity ~ color)\nggplot(diamonds, aes(x = cut, y = price, color = color)) +\n  geom_boxplot(show.legend = FALSE) +\n  facet_grid(clarity ~ color)"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-function","chapter":"第 11 章 数据可视化","heading":"11.4.8 函数图","text":"蝴蝶图的参数方程如下\\[\\begin{align}\nx &= \\sin t \\big(\\mathrm e^{\\cos t} - 2 \\cos 4t + \\sin^5(\\frac{t}{12})\\big) \\\\\ny &= \\cos t \\big(\\mathrm e^{\\cos t} - 2 \\cos 4t + \\sin^5(\\frac{t}{12})\\big), t \\[- \\pi, \\pi]\n\\end{align}\\]","code":""},{"path":"chap-data-visualization.html","id":"sec-ggplot2-density","chapter":"第 11 章 数据可视化","heading":"11.4.9 密度图","text":"\n图 11.68: 按汽缸数分组的城市里程\n添加透明度，解决遮挡\n图 11.69: 密度图\n\n图 11.70: 添加透明度的密度图\n堆积密度图\n图 11.71: 堆积密度图\n条件密度估计\n图 11.72: 条件密度估计图\n岭线图是密度图的一种变体，可以防止密度曲线重叠在一起二维的密度图又是一种延伸stat 函数，特别是 nlevel 参数，在密度曲线之间填充我们又可以得到热力图gemo_hex 也是二维密度图的一种变体，特别适合数据量比较大的情形heatmaps ggplot2 二维密度图\n图 11.73: 二维密度图\nMASS::kde2d() 实现二维核密度估计，ggplot2 包提供了两种等价的绘图方式stat_density_2d() 和 ..stat_density2d() 和 stat()\n图 11.74: 二维直方图/密度图/轮廓图\n延伸一下，热力图","code":"\nggplot(mpg, aes(cty)) +\n  geom_density(aes(fill = factor(cyl)), alpha = 0.8) +\n  labs(\n    title = \"Density plot\",\n    subtitle = \"City Mileage Grouped by Number of cylinders\",\n    caption = \"Source: mpg\",\n    x = \"City Mileage\",\n    fill = \"# Cylinders\"\n  )\nggplot(diamonds, aes(x = price, fill = cut)) + geom_density()\nggplot(diamonds, aes(x = price, fill = cut)) + geom_density(alpha = 0.5)\nggplot(diamonds, aes(x = price, fill = cut)) +\n  geom_density(position = \"stack\")\n# You can use position=\"fill\" to produce a conditional density estimate\nggplot(diamonds, aes(carat, stat(count), fill = cut)) +\n  geom_density(position = \"fill\")\nggplot(diamonds) +\n  ggridges::geom_density_ridges(aes(x = price, y = color, fill = color))\nggplot(diamonds, aes(x = carat, y = price)) +\n  geom_density_2d(aes(color = cut)) +\n  facet_grid(~cut)\nggplot(diamonds, aes(x = carat, y = price)) +\n  stat_density_2d(aes(fill = stat(nlevel)), geom = \"polygon\") +\n  facet_grid(. ~ cut)\nggplot(diamonds, aes(x = carat, y = price)) + geom_hex() +\n  scale_fill_viridis_c()\nggplot(faithful, aes(x = eruptions, y = waiting)) +\n  stat_density_2d(aes(fill = ..level..), geom = \"polygon\") +\n  xlim(1, 6) +\n  ylim(40, 100)\n\nggplot(faithful, aes(x = eruptions, y = waiting)) +\n  stat_density2d(aes(fill = stat(level)), geom = \"polygon\") +\n  scale_fill_viridis_c(option = \"viridis\") +\n  xlim(1, 6) +\n  ylim(40, 100)\nplotly::plot_ly(\n  data = faithful, x = ~eruptions,\n  y = ~waiting, type = \"histogram2dcontour\"\n) %>%\n  plotly::config(displayModeBar = FALSE)\n# plot_ly(faithful, x = ~waiting, y = ~eruptions) %>% \n#   add_histogram2d() %>% \n#   add_histogram2dcontour()\nlibrary(KernSmooth)\nden <- bkde2D(x = faithful, bandwidth = c(0.7, 7))\n# 热力图\np1 <- plotly::plot_ly(x = den$x1, y = den$x2, z = den$fhat) %>%\n  plotly::config(displayModeBar = FALSE) %>%\n  plotly::add_heatmap()\n\n# 等高线图\np2 <- plotly::plot_ly(x = den$x1, y = den$x2, z = den$fhat) %>%\n  plotly::config(displayModeBar = FALSE) %>%\n  plotly::add_contour()\n\nhtmltools::tagList(p1, p2)"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-violin","chapter":"第 11 章 数据可视化","heading":"11.4.10 提琴图","text":"2004 年 Daniel Adler 开发 vioplot 包实现提琴图的绘制，它可能是最早实现此功能的 R 包，随后10余年没有更新却一直坚挺在 CRAN 上，非常难得，好在 Thomas Kelly 已经接手维护。另一款绘制提琴图的 R 包是 Peter Kampstra 开发的 beanplot [23]，也存在很多年了，不过随着时间的变迁，比较现代的方式是 ggplot2 带来的 geom_violin() 扔掉了很多依赖，也是各种图形的汇集地，可以看作是最佳实践。提琴图比起箱线图优势在于呈现更多的分布信息，其次在于更加美观，但是就目前来说箱线图的受众比提琴图要多很多，毕竟前者是包含更多统计信息，如图11.75 所示。\n图 11.75: 几种不同的提琴图\nggnormalviolin 包在给定均值和标准差的情况下，绘制正态分布的概率密度曲线，如图 11.76 所示。\n图 11.76: 正态分布的概率密度曲线\n","code":"\nboxplot(count ~ spray, data = InsectSprays)\nvioplot::vioplot(count ~ spray, data = InsectSprays, col = \"lightgray\")\nggplot(InsectSprays, aes(x = spray, y = count)) +\n  geom_violin(fill = \"lightgray\") +\n  theme_minimal()\nbeanplot::beanplot(count ~ spray, data = InsectSprays, col = \"lightgray\")\nlibrary(ggnormalviolin)\nwith(\n  aggregate(\n    data = iris, Sepal.Length ~ Species,\n    FUN = function(x) c(dist_mean = mean(x), dist_sd = sd(x))\n  ),\n  cbind.data.frame(Sepal.Length, Species)\n) %>%\n  ggplot(aes(x = Species, mu = dist_mean, sigma = dist_sd, fill = Species)) +\n  geom_normalviolin() +\n  theme_minimal()"},{"path":"chap-data-visualization.html","id":"ggplot2-jitter","chapter":"第 11 章 数据可视化","heading":"11.4.11 抖动图","text":"抖动图适合数据量比较小的情况抖不抖，还是抖一下在数据量比较大的时候，可以用箱线图、密度图、提琴图\n图 11.77: 抖动图的反例\n上色和分面都不好使的抖动图，因为区分度变小\n图 10.49: 根据钻石颜色上色\n箱线图此时不宜分的过细\n图 11.78: 箱线图\n所以这样更好，先按纯净度分面，再对比不同的颜色，钻石价格的差异\n图 11.79: 钻石按纯净度分面\n最好只比较一个维度，不同颜色钻石的价格对比\n图 11.80: 不同颜色钻石的价格比较\n设置随机数种子，抖动图是可重复的。","code":"\nggplot(mpg, aes(x = class, y = hwy, color = class)) + geom_jitter()\nggplot(iris, aes(x = Species, y = Sepal.Length)) +\n  geom_point(aes(fill = Species), size = 5, shape = 21, colour = \"grey20\") +\n  # geom_boxplot(outlier.colour = NA, fill = NA, colour = \"grey20\") +\n  labs(title = \"Not Jittered\")\nggplot(iris, aes(x = Species, y = Sepal.Length)) +\n  geom_point(aes(fill = Species),\n    size = 5, shape = 21, colour = \"grey20\",\n    position = position_jitter(width = 0.2, height = 0.1)\n  ) +\n  # geom_boxplot(outlier.colour = NA, fill = NA, colour = \"grey20\") +\n  labs(title = \"Jittered\")\nggplot(sub_diamonds, aes(x = cut, y = price)) + geom_jitter()\nggplot(sub_diamonds, aes(x = color, y = price, color = color)) +\n  geom_jitter() +\n  facet_grid(clarity ~ cut)\nggplot(diamonds, aes(x = color, y = price, color = color)) +\n  geom_boxplot() +\n  facet_grid(cut ~ clarity)\nggplot(diamonds, aes(x = color, y = price, color = color)) +\n  geom_boxplot() +\n  facet_grid(~clarity)\nggplot(diamonds, aes(x = color, y = price, color = color)) +\n  geom_boxplot()\nggplot(iris, aes(x = Species, y = Sepal.Width, color = Species)) +\n  geom_boxplot(width = 0.65) +\n  geom_point(position = position_jitter(seed = 37, width = 0.25))"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-beeswarm","chapter":"第 11 章 数据可视化","heading":"11.4.12 蜂群图","text":"在样本点有限的情况下，用蜜蜂图代替普通的抖动图，可视化效果会好很多，如图 11.81 所示。Erik Clarke 开发的 ggbeeswarm 包可以将随机抖动的散点图朝着比较规律的方向聚合，又不丢失数据本身的准确性。\n图 11.81: 蜜蜂图可视化效果比抖动图好\n","code":"\nlibrary(ggbeeswarm)\np1 <- ggplot(iris, aes(Species, Sepal.Length)) +\n  geom_jitter() +\n  theme_minimal()\np2 <- ggplot(iris, aes(Species, Sepal.Length)) +\n  geom_quasirandom() +\n  theme_minimal()\np1 + p2"},{"path":"chap-data-visualization.html","id":"ggplot2-rose","chapter":"第 11 章 数据可视化","heading":"11.4.13 玫瑰图","text":"南丁格尔风玫瑰图42 可以作为堆积条形图，分组条形图\n图 11.82: 堆积条形图转风玫瑰图\n\n图 11.83: 堆积条形图转风玫瑰图\n\n图 11.84: 风玫瑰图\n","code":"\nggplot(diamonds, aes(x = color, fill = clarity)) +\n  geom_bar()\nggplot(diamonds, aes(x = color, fill = clarity)) +\n  geom_bar() +\n  coord_polar()\n# 风玫瑰图 http://blog.csdn.net/Bone_ACE/article/details/47624987\nset.seed(2018)\n# 随机生成100次风向，并汇集到16个区间内\ndirection <- cut_interval(runif(100, 0, 360), n = 16)\n# 随机生成100次风速，并划分成4种强度\nmag <- cut_interval(rgamma(100, 15), 4)\ndat <- data.frame(direction = direction, mag = mag)\n# 将风向映射到X轴，频数映射到Y轴，风速大小映射到填充色，生成条形图后再转为极坐标形式即可\np <- ggplot(dat, aes(x = direction, y = ..count.., fill = mag))\np + geom_bar(colour = \"white\") +\n  coord_polar() +\n  theme(axis.ticks = element_blank(), axis.text.y = element_blank()) +\n  labs(x = \"\", y = \"\", fill = \"Magnitude\")\np + geom_bar(position = \"fill\") +\n  coord_polar() +\n  theme(axis.ticks = element_blank(), axis.text.y = element_blank()) +\n  labs(x = \"\", y = \"\", fill = \"Magnitude\")"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-tile","chapter":"第 11 章 数据可视化","heading":"11.4.14 瓦片图","text":"\n图 11.85: 1949-1960年国际航线乘客数量的月度趋势\n","code":"\np1 <- expand.grid(months = month.abb, years = 1949:1960) %>%\n  transform(num = as.vector(AirPassengers)) %>%\n  ggplot(aes(x = years, y = months, fill = num)) +\n  scale_fill_continuous(type = \"viridis\") +\n  geom_tile(color = \"white\", size = 0.4) +\n  scale_x_continuous(\n    expand = c(0.01, 0.01),\n    breaks = seq(1949, 1960, by = 1), labels = 1949:1960\n  ) +\n  theme_minimal(base_size = 10.54, base_family = \"Noto Serif SC\") +\n  theme(legend.position = \"top\") +\n  labs(x = \"年\", y = \"月\", fill = \"人数\")\n\np2 <- expand.grid(months = month.abb, years = 1949:1960) %>%\n  transform(num = as.vector(AirPassengers)) %>%\n  ggplot(aes(x = years, y = months, color = num)) +\n  geom_point(pch = 15, size = 8) +\n  scale_color_distiller(palette = \"Spectral\") +\n  scale_x_continuous(\n    expand = c(0.01, 0.01),\n    breaks = seq(1949, 1960, by = 1), labels = 1949:1960\n  ) +\n  theme_minimal(base_size = 10.54, base_family = \"Noto Serif SC\") +\n  theme(legend.position = \"top\") +\n  labs(x = \"年\", y = \"月\", color = \"人数\")\np1 + p2"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-calendar","chapter":"第 11 章 数据可视化","heading":"11.4.15 日历图","text":"airquality 数据集记录了1973年5月至9月纽约的空气质量，包括气温（华氏度）、风速（米/小时）、紫外线强度、臭氧含量四个指标，图 11.86 展示了每日的气温变化。\n图 11.86: 1973年5月至9月纽约的气温变化\n图 11.86 横轴的刻度标签换成了月份，一个月为四周，一年 52～53 周，每周的第一天约定为星期一，1973年05月01日为星期二。代码中颇为技巧的在于 format() 函数从 Date 日期类型的数据提取第几周， 用 weekdays() 函数提取星期几，而 month.abb 则是一个内置常量，12个月份的英文缩写。在调用其它 R 包处理日期数据时要特别小心，要留意一周的的第一天是星期几，有的是星期一，有的是星期日，这往往和宗教信仰相关，星期日在西方也叫礼拜天。 上面 Base R 提供的日期函数认为一周的第一天是星期一，而调用 data.table 的话，默认一周是从星期日（礼拜天）开始的。本书的活跃情况\n图 11.87: 《R语言学习笔记》的活跃情况\n","code":"\nairquality %>%\n  transform(Date = seq.Date(\n    from = as.Date(\"1973-05-01\"),\n    to = as.Date(\"1973-09-30\"), by = \"day\"\n  )) %>%\n  transform(\n    Week = as.integer(format(Date, \"%W\")),\n    Year = as.integer(format(Date, \"%Y\")),\n    Weekdays = factor(weekdays(Date, abbreviate = T),\n      levels = c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\n    )\n  ) %>%\n  ggplot(aes(x = Week, y = Weekdays, fill = Temp)) +\n  scale_fill_distiller(name = \"Temp (F)\", palette = \"Spectral\") +\n  geom_tile(color = \"white\", size = 0.4) +\n  facet_wrap(\"Year\", ncol = 1) +\n  scale_x_continuous(\n    expand = c(0, 0),\n    breaks = seq(1, 52, length = 12),\n    labels = month.abb\n  )\n# https://d.cosx.org/d/421230\nweekdays(Sys.Date(), abbreviate = TRUE)## [1] \"Fri\"\ndata.table::wday(Sys.Date())## [1] 6\nlibrary(gert)\nlibrary(ggplot2)\ngit_config_set(\"user.name\", \"XiangyunHuang\")\ngit_config_set(\"user.email\", \"xiangyunfaith@outlook.com\")\n\ndat <- git_log(max = 1000)\n# format(time, \"%a\") 本地 MacOS 环境 \"六\" \"四\" \"五\" 表示星期\n# Sys.getlocale(\"LC_TIME\") # \"zh_CN.UTF-8\"\nlvls <- if(!is.na(Sys.getenv(\"CI\", NA))) {\n  c(\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\")\n} else {\n  c(\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\")\n}\n\ndat <- transform(dat,\n  date = format(time, \"%Y-%m-%d\"),\n  year = format(time, \"%Y\") ,\n  month = format(time, \"%m\"),\n  weekday = format(time, \"%a\"), # factor(format(time, \"%a\"), levels = lvls),\n  week = as.integer(format(time, \"%W\"))\n)\ndat1 <- aggregate(x = commit ~ year + month, data = dat, FUN = length)\n# 条形图\nggplot(data = dat1, aes(x = month, y = commit, fill = year)) +\n  geom_bar(stat = \"identity\", position = \"identity\")\n# 日历图\ndat2 <- aggregate(x = commit ~ year + week + weekday, data = dat, FUN = length)\n\ndat2 <- transform(dat2, colorBin = cut(commit, breaks = c(0, 5, 10, 15, 20, 25)))\n\nggplot(data = dat2, aes(x = week, y = weekday, fill = colorBin)) +\n  scale_fill_brewer(name = \"commit\", palette = \"Greens\") +\n  geom_tile(color = \"white\", size = 0.4) +\n  facet_wrap(\"year\", ncol = 1) +\n  scale_x_continuous(\n    expand = c(0, 0),\n    breaks = seq(1, 52, length = 12),\n    labels = month.abb\n  ) +\n  labs(x = \"\", y = \"\") +\n  theme_minimal(base_family = \"Noto Sans SC\")"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-ridgeline","chapter":"第 11 章 数据可视化","heading":"11.4.16 岭线图","text":"ggridges 包，于淼 对此图形的来龙去脉做了比较系统的阐述，详见统计之都主站文章叠嶂图的前世今生\n图 11.88: 2016年在内布拉斯加州林肯市的天气变化\n通过数据可视化的手段帮助肉眼检查两组数据的分布\n图 11.89: 比较数据的分布\nridgeline 提供 Base R 绘图方案\n图 11.90: 岭线图\n","code":"\nlibrary(ggridges)\nggplot(lincoln_weather, aes(x = `Mean Temperature [F]`, y = Month, fill = stat(x))) +\n  geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01, gradient_lwd = 1.) +\n  scale_x_continuous(expand = c(0, 0)) +\n  scale_y_discrete(expand = expansion(mult = c(0.01, 0.25))) +\n  scale_fill_viridis_c(name = \"Temp. [F]\", option = \"C\") +\n  labs(\n    title = 'Temperatures in Lincoln NE',\n    subtitle = 'Mean temperatures (Fahrenheit) by month for 2016'\n  ) +\n  theme_ridges(font_size = 13, grid = TRUE) + \n  theme(axis.title.y = element_blank())\np1 <- ggplot(sleep, aes(x = extra, y = group, fill = group)) +\n  geom_density_ridges() +\n  theme_ridges()\n\np2 <- ggplot(diamonds, aes(x = price, y = color, fill = color)) +\n  geom_density_ridges() +\n  theme_ridges()\n\np1 / p2"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-ellipse","chapter":"第 11 章 数据可视化","heading":"11.4.17 椭圆图","text":"type 指定多元分布的类型，type = \"t\" 和 type = \"norm\" 分别表示 t 分布和正态分布，geom = \"polygon\"，以 eruptions > 3 分为两组\n图 11.91: 几种不同的椭圆图\n","code":"\nggplot(faithful, aes(x = waiting, y = eruptions)) +\n  geom_point() +\n  stat_ellipse()\n\nggplot(faithful, aes(waiting, eruptions, color = eruptions > 3)) +\n  geom_point() +\n  stat_ellipse(type = \"norm\", linetype = 2) +\n  stat_ellipse(type = \"t\") +\n  theme(legend.position = \"none\")\n\nggplot(faithful, aes(waiting, eruptions, fill = eruptions > 3)) +\n  stat_ellipse(geom = \"polygon\") +\n  theme(legend.position = \"none\")"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-qq","chapter":"第 11 章 数据可视化","heading":"11.4.18 Q-Q 图","text":"quantile-quantile Q-Q 正态分布图的 ggplot2 实现 qqplotr","code":""},{"path":"chap-data-visualization.html","id":"sec-ggplot2-chull","chapter":"第 11 章 数据可视化","heading":"11.4.19 包络图","text":"ggpubr 包提供了 stat_chull() 图层\n图 11.92: 包络图\n其背后的原理如下","code":"\nlibrary(ggpubr)\nggscatter(mpg, x = \"displ\", y = \"hwy\", color = \"drv\")+\n stat_chull(aes(color = drv, fill = drv), alpha = 0.1, geom = \"polygon\")\nstat_chull## function (mapping = NULL, data = NULL, geom = \"path\", position = \"identity\", \n##     na.rm = FALSE, show.legend = NA, inherit.aes = TRUE, ...) \n## {\n##     layer(stat = StatChull, data = data, mapping = mapping, geom = geom, \n##         position = position, show.legend = show.legend, inherit.aes = inherit.aes, \n##         params = list(na.rm = na.rm, ...))\n## }\n## <bytecode: 0x555618eef720>\n## <environment: namespace:ggpubr>\nStatChull <- ggproto(\"StatChull\", Stat,\n  compute_group = function(data, scales) {\n    data[chull(data$x, data$y), , drop = FALSE]\n  },\n  required_aes = c(\"x\", \"y\")\n)\n\nstat_chull <- function(mapping = NULL, data = NULL, geom = \"polygon\",\n                       position = \"identity\", na.rm = FALSE, show.legend = NA,\n                       inherit.aes = TRUE, ...) {\n  layer(\n    stat = StatChull, data = data, mapping = mapping, geom = geom,\n    position = position, show.legend = show.legend, inherit.aes = inherit.aes,\n    params = list(na.rm = na.rm, ...)\n  )\n}\n\nggplot(mpg, aes(displ, hwy)) + \n  geom_point() + \n  stat_chull(fill = NA, colour = \"black\")\n\nggplot(mpg, aes(displ, hwy, colour = drv)) + \n  geom_point() + \n  stat_chull(fill = NA)"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-fit","chapter":"第 11 章 数据可视化","heading":"11.4.20 拟合图","text":"\n图 11.93: 自定义样条函数\n下面以真实数据集 trees 为例，介绍 geom_smooth() 支持的拟合方法，比如 \"lm\" 线性回归和 \"nls\" 非线性回归\n图 11.94: 平滑方法\n","code":"\nxx <- -9:9\nyy <- sqrt(abs(xx))\nplot(xx, yy,\n  col = \"red\",\n  xlab = expression(x),\n  ylab = expression(sqrt(abs(x)))\n)\nlines(spline(xx, yy, n = 101, method = \"fmm\", ties = mean), col = \"pink\")\n\nmyspline <- function(formula, data, ...) {\n  dat <- model.frame(formula, data)\n  res <- splinefun(dat[[2]], dat[[1]])\n  class(res) <- \"myspline\"\n  res\n}\n\npredict.myspline <- function(object, newdata, ...) {\n  object(newdata[[1]])\n}\n\ndata.frame(x = -9:9) %>%\n  transform(y = sqrt(abs(x))) %>%\n  ggplot(aes(x = x, y = y)) +\n  geom_point(color = \"red\", pch = 1, size = 2) +\n  stat_smooth(method = myspline, formula = y~x, se = F, color = \"pink\") +\n  labs(x = expression(x), y = expression(sqrt(abs(x)))) +\n  theme_minimal()\nggplot(trees, aes(x = log(Girth), y = log(Volume))) +\n  geom_point() +\n  geom_smooth(method = \"lm\", formula = y ~ x, se = FALSE)\n\nggplot(trees, aes(x = Girth, y = Volume)) +\n  geom_point() +\n  geom_smooth(\n    method = \"nls\", formula = y ~ a * x^2 + b, se = F,\n    method.args = list(start = list(a = 5, b = -36))\n  )"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-raster","chapter":"第 11 章 数据可视化","heading":"11.4.21 地形图","text":"区域之间以轮廓分割，轮廓之间以相同的颜色填充，Cleveland 把这个叫做 level plot， lattice 包中 levelplot() 函数正来源于此。Auckland’s Maunga Whau Volcano 是火山喷发后留下的碴堆，位于新西兰奥克兰伊甸山郊区。Ross Ihaka 收集了它的地形数据，命名为 volcano，打包在 R 软件环境中，见图 11.95\n图 11.95: image 图形\n","code":"\nfilled.contour(volcano,\n  color.palette = terrain.colors,\n  plot.title = title(\n    main = \"The Topography of Maunga Whau\",\n    xlab = \"Meters North\", ylab = \"Meters West\"\n  ),\n  plot.axes = {\n    axis(1, seq(100, 800, by = 100))\n    axis(2, seq(100, 600, by = 100))\n  },\n  key.title = title(main = \"Height\\n(meters)\"),\n  key.axes = axis(4, seq(90, 190, by = 10))\n)"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-treemap","chapter":"第 11 章 数据可视化","heading":"11.4.22 树状图","text":"数据集 GNI2014 来自 treemap 包，是一个 data.frame 类型的数据对象，记录了 2014 年每个国家的人口总数 population 和国民人均收入 GNI，数据样例见下方：数据呈现明显的层级结构，从大洲到国家记录人口数量和人均收入，矩阵树图以方块大小表示人口数量，以颜色深浅表示人均收入，见图11.96\n图 11.96: 矩阵树图\ntreemapify 包基于 ggplot2 制作树状图，类似地，该 R 包内置了数据集 G20，记录了世界主要经济体 G20 (https://en.wikipedia.org/wiki/G20) 的经济和人口信息，国家 GDP （单位：百万美元）gdp_mil_usd 和人类发展指数 hdi。相比于 GNI2014，它还包含了两列标签信息：经济发展阶段和所处的半球。图@(fig:treemap-ggplot2)以南北半球 hemisphere 分面，以色彩填充区域 region，以 gdp_mil_usd 表示区域大小\n图 11.97: 世界主要经济体G20的人口和经济信息\n","code":"\nlibrary(treemap)\ndata(GNI2014, package = \"treemap\")\nsubset(GNI2014, subset = grepl(x = country, pattern = 'China'))##    iso3              country continent population   GNI\n## 7   MAC     Macao SAR, China      Asia     559846 76270\n## 33  HKG Hong Kong SAR, China      Asia    7061200 40320\n## 87  CHN                China      Asia 1338612970  7400\ntreemap(GNI2014,\n  index = c(\"continent\", \"iso3\"),\n  vSize = \"population\", \n  vColor = \"GNI\",\n  type = \"value\",\n  format.legend = list(scientific = FALSE, big.mark = \" \")\n)\nlibrary(treemapify)\nggplot(G20, aes(\n  area = gdp_mil_usd, fill = region,\n  label = country, subgroup = region\n)) +\n  geom_treemap() +\n  geom_treemap_text(grow = T, reflow = T, colour = \"black\") +\n  facet_wrap(~hemisphere) +\n  scale_fill_brewer(palette = \"Set1\") +\n  theme(legend.position = \"bottom\") +\n  labs(\n    title = \"The G-20 major economies by hemisphere\",\n    caption = \"The area of each tile represents the country's GDP as a\n      proportion of all countries in that hemisphere\",\n    fill = \"Region\"\n  )"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-cohort","chapter":"第 11 章 数据可视化","heading":"11.4.23 留存图","text":"留存是 Cohort 分析 中的一种情况，还有转化等，首先\n定义你的问题，确定度量问题的指标，确定和问题相关的 Cohort （比如时间、空间和用户属性等关键的影响因素），然后数据处理、可视化获得 Cohort 分析结果，最后在实际决策和行动中检验分析结论。","code":"\ncohort <- data.frame(\n  cohort = rep(1:5, times = 5:1),\n  week = c(1:5, 1:4, 1:3, 1:2, 1),\n  value = c(\n    75, 73, 54, 23, 3,\n    98, 94, 70, 25,\n    52, 5, 3,\n    44, 15,\n    88\n  )\n)\n\nggplot(cohort, aes(x = week, y = cohort, fill = value)) +\n  geom_tile(color = \"white\") +\n  geom_text(aes(label = value), color = \"white\") +\n  scale_y_reverse() +\n  scale_fill_binned(type = \"viridis\")"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-waterfall","chapter":"第 11 章 数据可视化","heading":"11.4.24 瀑布图","text":"瀑布图 waterfall 与上月相比，谁增谁减，用瀑布图分别表示占比和绝对数值。瀑布图 waterfall\n图 11.98: 瀑布图\n","code":"\nbalance <- data.frame(\n  event = c(\n    \"Starting\\nCash\", \"Sales\", \"Refunds\",\n    \"Payouts\", \"Court\\nLosses\", \"Court\\nWins\", \"Contracts\", \"End\\nCash\"\n  ),\n  change = c(2000, 3400, -1100, -100, -6600, 3800, 1400, -2800)\n)\n\nbalance$balance <- cumsum(c(0, balance$change[-nrow(balance)])) # 累计值\nbalance$time <- 1:nrow(balance)\nbalance$flow <- factor(sign(balance$change)) # 变化为正还是为负\n\nggplot(balance) +\n  geom_hline(yintercept = 0, colour = \"white\", size = 2) +\n  geom_rect(aes(\n    xmin = time - 0.45, xmax = time + 0.45,\n    ymin = balance, ymax = balance + change, fill = flow\n  )) +\n  geom_text(aes(\n    x = time,\n    y = pmin(balance, balance + change) - 50,\n    label = scales::dollar(change)\n  ),\n  hjust = 0.5, vjust = 1, size = 3\n  ) +\n  scale_x_continuous(\n    name = \"\",\n    breaks = balance$time,\n    labels = balance$event\n  ) +\n  scale_y_continuous(\n    name = \"Balance\",\n    labels = scales::dollar\n  ) +\n  scale_fill_brewer(palette = \"Spectral\") +\n  theme_minimal()\nlibrary(ggplot2)\n# AtherEnergy/ggTimeSeries\n# 个人收入，国家地区收入\nlibrary(ggTimeSeries) # https://github.com/AtherEnergy/ggTimeSeries\ndat <- data.frame(year = 2000:2021, dpc = 10:31)\nggplot(data = dat, aes(x = year, y = dpc)) +\n  stat_waterfall()"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-sankey","chapter":"第 11 章 数据可视化","heading":"11.4.25 桑基图","text":"ggalluvial\n图 11.99: 桑基图\n","code":"\ntitanic_wide <- data.frame(Titanic)\nhead(titanic_wide)##   Class    Sex   Age Survived Freq\n## 1   1st   Male Child       No    0\n## 2   2nd   Male Child       No    0\n## 3   3rd   Male Child       No   35\n## 4  Crew   Male Child       No    0\n## 5   1st Female Child       No    0\n## 6   2nd Female Child       No    0\nlibrary(ggalluvial)\nggplot(data = titanic_wide,\n       aes(axis1 = Class, axis2 = Sex, axis3 = Age,\n           y = Freq)) +\n  scale_x_discrete(limits = c(\"Class\", \"Sex\", \"Age\"), expand = c(.2, .05)) +\n  xlab(\"Demographic\") +\n  geom_alluvium(aes(fill = Survived)) +\n  geom_stratum() +\n  geom_text(stat = \"stratum\", aes(label = after_stat(stratum))) +\n  theme_minimal() +\n  ggtitle(\"passengers on the maiden voyage of the Titanic\",\n          \"stratified by demographics and survival\")"},{"path":"chap-data-visualization.html","id":"ggplot2-wordcloud","chapter":"第 11 章 数据可视化","heading":"11.4.26 词云图","text":"词云 ggwordcloud","code":""},{"path":"chap-data-visualization.html","id":"ggplot2-gantt","chapter":"第 11 章 数据可视化","heading":"11.4.27 甘特图","text":"描述项目进展的甘特图\nganttrify","code":""},{"path":"chap-data-visualization.html","id":"sec-ggplot2-ggmosaic","chapter":"第 11 章 数据可视化","heading":"11.4.28 马赛克图","text":"\n图 11.100: UCBAdmissions 马赛克图\n","code":"\nlibrary(ggmosaic)\nggplot(data = as.data.frame(UCBAdmissions)) +\n  geom_mosaic(aes(weight = Freq, x = product(Gender, Admit), fill = Dept)) +\n  coord_flip() +\n  theme_minimal() +\n  labs(x = \"Admit\", y = \"Gender\")## Warning: `unite_()` was deprecated in tidyr 1.2.0.\n## Please use `unite()` instead.\n## This warning is displayed once every 8 hours.\n## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated."},{"path":"chap-data-visualization.html","id":"sec-ggplot2-bump","chapter":"第 11 章 数据可视化","heading":"11.4.29 凹凸图","text":"ggbump 排序随位置的变化\n图 11.101: 凹凸图\n","code":"\n# remotes::install_github(\"davidsjoberg/ggbump\")\nlibrary(ggbump)\n# 代码修改自 https://github.com/davidsjoberg/ggbump\ndf <- data.frame(\n  season = c(\n    \"Spring\", \"Pre-season\", \"Summer\", \"Season finale\", \"Autumn\", \"Winter\",\n    \"Spring\", \"Pre-season\", \"Summer\", \"Season finale\", \"Autumn\", \"Winter\",\n    \"Spring\", \"Pre-season\", \"Summer\", \"Season finale\", \"Autumn\", \"Winter\",\n    \"Spring\", \"Pre-season\", \"Summer\", \"Season finale\", \"Autumn\", \"Winter\"\n  ),\n  rank = c(\n    1, 3, 4, 2, 1, 4,\n    2, 4, 1, 3, 2, 3,\n    4, 1, 2, 4, 4, 1,\n    3, 2, 3, 1, 3, 2\n  ),\n  player = c(\n    rep(\"David\", 6),\n    rep(\"Anna\", 6),\n    rep(\"Franz\", 6),\n    rep(\"Ika\", 6)\n  )\n)\n\n# Create factors and order factor\ndf <- transform(df, season = factor(season, levels = unique(season)))\n\n# Add manual axis labels to plot\nggplot(df, aes(season, rank, color = player)) +\n  geom_bump(size = 2, smooth = 20, show.legend = F) +\n  geom_point(size = 5, aes(shape = player)) +\n  theme_minimal(base_size = 10, base_line_size = 0) +\n  theme(panel.grid.major = element_blank(),\n        axis.ticks = element_blank()) +\n  scale_color_manual(values = RColorBrewer::brewer.pal(name = \"Set2\", n = 4))"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-streamgraph","chapter":"第 11 章 数据可视化","heading":"11.4.30 水流图","text":"常用于时间序列数据展示的堆积区域图，ggstream 和 streamgraph\n图 11.102: 堆积区域图\n","code":"\nlibrary(ggstream)\n\nggplot(blockbusters, aes(year, box_office, fill = genre)) +\n  geom_stream() +\n  theme_minimal()"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-vistime","chapter":"第 11 章 数据可视化","heading":"11.4.31 时间线","text":"\n图 11.103: 数据科学的时间轴\n","code":"\n# 交互动态图 https://github.com/shosaco/vistime\n# 刘思喆 2018 数据科学的时间轴 https://bjt.name/2018/11/18/timeline.html\nx <- read.table(\n  textConnection(\"\nThe Future of Data Analysis,1962\nRelational Database,1970\nData science(Peter Naur),1974\nTwo-Way Communication,1975\nExploratory Data Analysis,1977\nBusiness Intelligence,1989\nThe First Database Report,1992\nThe World Wide Web Explodes,1995\nData Mining and Knowledge Discovery,1997\nS(ACM Software System Award),1998\nStatistical Modeling: The Two Cultures,2001\nHadoop,2006\nData scientist,2008\nNOSQL,2009\nDeep Learning,2015\n\"),\n  sep = \",\"\n)\nnames(x) <- c(\"Event\", \"EventDate\")\nx$EventDate <- as.Date(paste(x$EventDate, \"/01/01\", sep = \"\"))\n\nlibrary(timelineS)\ntimelineS(x,\n  labels = paste(x[[1]], format(x[[2]], \"%Y\")),\n  line.color = \"blue\", label.angle = 15\n)\nlibrary(timeline)\ndata(ww2, package = 'timeline')\ntimeline(ww2, ww2.events, event.spots=2, event.label='', event.above=FALSE)\n# 适合放在动态幻灯片\n# 美团风格的写轮眼\n# 时间线\nlibrary(vistime)\n# presidents and vice presidents\npres <- data.frame(\n  Position = rep(c(\"President\", \"Vice\"), each = 3),\n  Name = c(\"Washington\", rep(c(\"Adams\", \"Jefferson\"), 2), \"Burr\"),\n  start = c(\"1789-03-29\", \"1797-02-03\", \"1801-02-03\"),\n  end = c(\"1797-02-03\", \"1801-02-03\", \"1809-02-03\"),\n  color = c(\"#cbb69d\", \"#603913\", \"#c69c6e\")\n)\n\nhc_vistime(pres, col.event = \"Position\", col.group = \"Name\", \n           title = \"Presidents of the USA\")"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-ternary","chapter":"第 11 章 数据可视化","heading":"11.4.32 三元图","text":"Ternary 使用基础图形库，而 ggtern 使用 ggplot2 绘制","code":"\nlibrary(ggtern)\nlibrary(ggalt)\ndata(\"Fragments\")\nggtern(Fragments, aes(\n  x = Qm, y = Qp, z = Rf + M,\n  fill = GrainSize, shape = GrainSize\n)) +\n  geom_encircle(alpha = 0.5, size = 1) +\n  geom_point() +\n  labs(\n    title = \"Example Plot\",\n    subtitle = \"using geom_encircle\"\n  ) +\n  theme_bw() +\n  theme_legend_position(\"tr\")"},{"path":"chap-data-visualization.html","id":"sec-vector-fields","chapter":"第 11 章 数据可视化","heading":"11.4.33 向量场图","text":"","code":"\nlibrary(ggquiver)"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-eisenhower","chapter":"第 11 章 数据可视化","heading":"11.4.34 四象限图","text":"\n图 11.104: 四象限图\n","code":"\ndat <- data.frame(\n  perc = c(54, 18, 5, 15),\n  wall_policy = c(\"oppose\", \"favor\", \"oppose\", \"favor\"),\n  dreamer_policy = c(\"favor\", \"favor\", \"oppose\", \"oppose\"),\n  stringsAsFactors = FALSE\n) %>%\n  transform(\n    xmin = ifelse(wall_policy == \"oppose\", -sqrt(perc), 0),\n    xmax = ifelse(wall_policy == \"favor\", sqrt(perc), 0),\n    ymin = ifelse(dreamer_policy == \"oppose\", -sqrt(perc), 0),\n    ymax = ifelse(dreamer_policy == \"favor\", sqrt(perc), 0)\n  )\n\nggplot(data = dat) +\n  geom_rect(aes(\n    xmin = xmin, xmax = xmax,\n    ymin = ymin, ymax = ymax\n  ), fill = \"grey\") +\n  geom_text(aes(\n    x = xmin + 0.5 * sqrt(perc),\n    y = ymin + 0.5 * sqrt(perc),\n    label = perc\n  ),\n  color = \"white\", size = 10\n  ) +\n  coord_equal() +\n  geom_hline(yintercept = 0) +\n  geom_vline(xintercept = 0) +\n  theme_minimal() +\n  labs(x = \"\", y = \"\", title = \"\")"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-venn","chapter":"第 11 章 数据可视化","heading":"11.4.35 韦恩图","text":"ggVennDiagram","code":""},{"path":"chap-data-visualization.html","id":"sec-ggplot2-tornado","chapter":"第 11 章 数据可视化","heading":"11.4.36 龙卷风图","text":"\n图 11.105: 龙卷风图展示变量重要性\nTornado diagram 主要用于敏感性分析，比较不同变量的重要性程度。条形图 geom_bar() 图层的变体，模型权重可视化的手段，仅限于广义线性模型。","code":"\ndat <- data.frame(\n  variable = c(\"A\", \"B\", \"A\", \"B\"),\n  Level = c(\"Top-2\", \"Top-2\", \"Bottom-2\", \"Bottom-2\"),\n  value = c(.8, .7, -.2, -.3)\n)\nggplot(dat, aes(x = variable, y = value, fill = Level)) +\n  geom_bar(position = \"identity\", stat = \"identity\") +\n  scale_y_continuous(labels = abs) +\n  coord_flip() +\n  theme_minimal()"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-hclust","chapter":"第 11 章 数据可视化","heading":"11.4.37 聚类图","text":"ggdendro 的 dendro_data() 函数支持 tree 、hclust 、dendrogram 和 rpart 结果的整理，进而绘图","code":"\nlibrary(ggdendro)\nhc <- hclust(dist(USArrests), \"ave\")\nhcdata <- dendro_data(hc, type = \"rectangle\")\nggplot() +\n  geom_segment(data = segment(hcdata), \n               aes(x = x, y = y, xend = xend, yend = yend)\n  ) +\n  geom_text(data = label(hcdata), \n            aes(x = x, y = y, label = label, hjust = 0), \n            size = 3\n  ) +\n  coord_flip() +\n  scale_y_reverse(expand = c(0.2, 0)) +\n  theme_minimal()"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-prcomp","chapter":"第 11 章 数据可视化","heading":"11.4.38 主成分图","text":"借助 autoplotly 包 [24] 可将函数 stats::prcomp 生成的结果转化为交互图形ggfortify [25] 包将主成分分析图转化为静态图形\n图 11.106: 主成分分析\n","code":"\npca <- prcomp(iris[c(1, 2, 3, 4)])\nplot(pca)\nlibrary(autoplotly)\nautoplotly(pca,\n  data = iris, colour = \"Species\",\n  label = TRUE, label.size = 3, frame = TRUE\n)\nlibrary(ggfortify)\nautoplot(pca, data = iris, colour = 'Species')"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-composite","chapter":"第 11 章 数据可视化","heading":"11.4.39 组合图","text":"组合的意思是将不同种类的图形绘制在一个区域中，比如密度曲线和地毯图43组合。\nGGally、 ggupset、 ggcharts 和 ggpubr 高度定制了一些组合统计图形，以 ggpubr 为例，见图 11.107。\n图 11.107: 组合图形\n上面介绍的都是已经固化的组合方式，一般地，将多个图形组合到一个图中，可以有很多办法，比如 Claus Wilke 开发的 cowplot ，在他的书里 Fundamentals Data Visualization 大量使用，后起之秀 patchwork 则提供更加简洁的组合语法，非常受欢迎，更加底层的拼接方法可以去看 一页多图 和 R 内置的 grid 系统。","code":"\nlibrary(ggpubr)\nggdensity(sleep,\n  x = \"extra\", add = \"mean\", rug = TRUE, color = \"group\",\n  fill = \"group\", palette = c(\"#00AFBB\", \"#E7B800\")\n)"},{"path":"chap-data-visualization.html","id":"sec-ggplot2-animation","chapter":"第 11 章 数据可视化","heading":"11.4.40 动态图","text":"av 包基于 FFmpeg 将静态图片合成视频，而 gifski 包基于 gifski 将静态图片合成 GIF 动画，animation 包 [26] 将 Base R 绘制的图形转化为动画或视频，mapmate 制作地图相关的三维可视化图形，gganimate 包支持将 ggplot2 生成的图形，magick 可以将一系列静态图形合成动态图形，借助 gifski 包转化为动态图片或视频。推荐读者从 gganimate 案例合集 开始制作动态图形。 rgl 可以制作真三维动态图形，支持缩放、拖拽、旋转等操作， rayshader 还支持转化 ggplot2 对象为 3D 图形。数据集 Indometh 记录了药物在人体中的代谢情况，给 6 个人分别静脉注射了吲哚美辛，每隔一段时间抽血检查药物在血浆中的浓度，收集的数据见表 11.3表 11.3: 吲哚美辛在人体中的代谢情况如图 11.108 所示，药物在人体中浓度变化情况\n图 11.108: 药物在人体中的代谢情况\n书籍目标输出格式是 PDF，则在代码块选项设置里必须指定参数 fig.show='animate' 否则插入的只是图片而不是动画，\n目标格式是 HTML 网页， 就不必指定参数，默认会将图片合成 GIF 动态图，嵌入 PDF 里面的动画需要 Acrobat Reader 阅读器才能正确地显示。动态图形制作的原理，简单来说，就是将一帧帧静态图形以较快的速度播放，人眼形成视觉残留，以为是连续的画面，相比于 animation， gganimate 借助 tweenr 包添加了过渡效果，动态图形显得非常自然。下面以 cup 函数44为例\\[f(x;\\theta,\\phi) = \\theta x\\log(x)-\\frac{1}{\\phi}\\mathit{e}^{-\\phi^4(x-\\frac{1}{\\mathit{e}})^4}, \\quad \\theta \\(2,3), \\phi \\(30,50), x \\(0,1)\\] 函数图像随着 \\(\\theta\\) 和 \\(\\phi\\) 的变化情况见图 11.109。\n图 11.109: 添加过渡效果\n","code":"\nreshape(Indometh, v.names = \"conc\", idvar = \"Subject\", \n        timevar = \"time\", direction = \"wide\", sep = \"\") %>%\n  knitr::kable(.,\n    caption = \"吲哚美辛在人体中的代谢情况\",\n    row.names = FALSE, col.names = gsub(\"(conc)\", \"\", names(.)),\n    align = \"c\"\n  )\np <- ggplot(\n  data = Indometh,\n  aes(x = time, y = conc, color = Subject)\n) +\n  geom_point() +\n  geom_line() +\n  theme_minimal() +\n  labs(\n    x = \"time (hr)\",\n    y = \"plasma concentrations of indometacin (mcg/ml)\"\n  )\np\nlibrary(gganimate)\np + transition_reveal(time)\nlibrary(tweenr)\ncup_curve <- function(n = 100, theta = 3, phi = 30, cup = \"A\") {\n  data.frame(x = seq(0.00001, 1, length.out = n), cup = cup) %>%\n    transform(y = theta * x * log(x, base = 10) \n              - 1 / phi * exp(-(phi * x - phi / exp(1))^4))\n}\nmapply(\n  FUN = cup_curve, theta = c(E = 3, D = 2.8, C = 2.5, B = 2.2, A = 2),\n  phi = c(30, 33, 36, 40, 50), cup = c(\"E\", \"D\", \"C\", \"B\", \"A\"),\n  MoreArgs = list(n = 50), SIMPLIFY = FALSE, USE.NAMES = TRUE\n) %>%\n  tween_states(\n    data = .,\n    tweenlength = 2, statelength = 1,\n    ease = rep(\"cubic-in-out\", 4), nframes = 100\n  ) %>%\n  ggplot(data = ., aes(x, y, color = cup, frame = .frame)) +\n  geom_path() +\n  coord_flip() +\n  theme_void()"},{"path":"chap-interactive-web-graphics.html","id":"chap-interactive-web-graphics","chapter":"第 12 章 交互图形","heading":"第 12 章 交互图形","text":"plotly 是一个功能非常强大的绘制交互式图形的 R 包。它支持下载图片、添加水印、自定义背景图片、工具栏和注释45 等一系列细节的自定义控制。下面结合 JavaScript 库 plotly.js 一起介绍，帮助文档 ?config 没有太详细地介绍，所以我们看看 config() 函数中参数 ... 和 JavaScript 库 plot_config.js 中的功能函数是怎么对应的。图12.1 中图片下载按钮对应 toImageButtonOptions 参数， 看 toImageButtonOptions 源代码，可知，它接受任意数据类型，对应到 R 里面就是列表。 watermark 和 displaylogo 都是传递布尔值（TRUE/FALSE），具体根据 JavaScript 代码中的 valType （参数值类型）决定，其它参数类似。另一个函数 layout 和函数 config() 是类似的，怎么传递参数值是根据 JavaScript 代码来的。\n图 12.1: 自定义细节\n表 12.1:  交互图形的设置函数 config() 各个参数及其作用（部分）","code":"toImageButtonOptions: {\n    valType: 'any',\n    dflt: {},\n    description: [\n        'Statically override options for toImage modebar button',\n        'allowed keys are format, filename, width, height, scale',\n        'see ../components/modebar/buttons.js'\n    ].join(' ')\n},\ndisplaylogo: {\n    valType: 'boolean',\n    dflt: true,\n    description: [\n        'Determines whether or not the plotly logo is displayed',\n        'on the end of the mode bar.'\n    ].join(' ')\n},\nwatermark: {\n    valType: 'boolean',\n    dflt: false,\n    description: 'watermark the images with the company\\'s logo'\n},\nlibrary(plotly, warn.conflicts = FALSE)\nplot_ly(diamonds,\n  x = ~clarity, y = ~price,\n  color = ~clarity, colors = \"Set1\", type = \"box\"\n) %>%\n  config(\n    toImageButtonOptions = list(\n      format = \"svg\", width = 450, height = 300,\n      filename = paste(\"plot\", Sys.Date(), sep = \"_\")\n    ), \n    modeBarButtons = list(list(\"toImage\")),\n    watermark = FALSE,\n    displaylogo = FALSE, \n    locale = \"zh-CN\", \n    staticPlot = TRUE,\n    showLink = FALSE,\n    modeBarButtonsToRemove = c(\n      \"hoverClosestCartesian\", \"hoverCompareCartesian\", \n      \"zoom2d\", \"zoomIn2d\", \"zoomOut2d\", \n      \"autoScale2d\", \"resetScale2d\", \"pan2d\",\n      \"toggleSpikelines\"\n    )\n  ) %>%\n  layout(\n    template = \"plotly_dark\",\n    images = list(\n      source = \"https://images.plot.ly/language-icons/api-home/r-logo.png\",\n      xref = \"paper\",\n      yref = \"paper\",\n      x = 1.00,\n      y = 0.25,\n      sizex = 0.2,\n      sizey = 0.2,\n      opacity = 0.5\n    ),\n    annotations = list(\n      text = \"DRAFT\",               # 水印文本\n      textangle = -30,              # 逆时针旋转 30 度\n      font = list(\n        size = 40,                  # 字号\n        color = \"gray\",             # 颜色\n        family = \"Times New Roman\"  # 字族\n      ),\n      opacity = 0.2,                # 透明度\n      xref = \"paper\",\n      yref = \"paper\",\n      x = 0.5,\n      y = 0.5,\n      showarrow = FALSE             # 去掉箭头指示\n    )\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-scatter","chapter":"第 12 章 交互图形","heading":"12.1 散点图","text":"表 12.2:  散点图类型plotly.js 提供很多图层用于绘制各类图形 https://github.com/plotly/plotly.js/tree/master/src/traces\n图 12.2: 其它常见图形\n","code":"\n# 折线图\nplot_ly(Orange,\n  x = ~age, y = ~circumference, color = ~Tree,\n  type = \"scatter\", mode = \"markers\"\n)"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-barplot","chapter":"第 12 章 交互图形","heading":"12.2 条形图","text":"日常使用最多的图形无外乎散点图、柱形图（分组、堆积、百分比堆积等）","code":"\n# 简单条形图\nlibrary(data.table)\ndiamonds <- as.data.table(diamonds)\n\np11 <- diamonds[, .(cnt = .N), by = .(cut)] %>%\n  plot_ly(x = ~cut, y = ~cnt, type = \"bar\") %>%\n  add_text(\n    text = ~ scales::comma(cnt), y = ~cnt,\n    textposition = \"top middle\",\n    cliponaxis = FALSE, showlegend = FALSE\n  )\n# 分组条形图\np12 <- plot_ly(diamonds,\n  x = ~cut, color = ~clarity,\n  colors = \"Accent\", type = \"histogram\"\n) \n# 堆积条形图\np13 <- plot_ly(diamonds,\n  x = ~cut, color = ~clarity,\n  colors = \"Accent\", type = \"histogram\"\n) %>%\n  layout(barmode = \"stack\")\n# 百分比堆积条形图\n# p14 <- plot_ly(diamonds,\n#   x = ~cut, color = ~clarity,\n#   colors = \"Accent\", type = \"histogram\"\n# ) %>%\n#   layout(barmode = \"stack\", barnorm = \"percent\") %>%\n#   config(displayModeBar = F)\n\n# 推荐使用如下方式绘制堆积条形图\ndat = diamonds[, .(cnt = length(carat)), by = .(clarity, cut)] %>%\n  .[, pct := round(100 * cnt / sum(cnt), 2), by = .(cut)]\n\np14 <- plot_ly(\n  data = dat, x = ~cut, y = ~pct, color = ~clarity,\n  colors = \"Set3\", type = \"bar\"\n) %>%\n  layout(barmode = \"stack\")\n\nhtmltools::tagList(p11, p12, p13, p14)"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-lineplot","chapter":"第 12 章 交互图形","heading":"12.3 折线图","text":"其它常见的图形还要折线图、直方图、箱线图和提琴图\n图 12.3: 折线图\n","code":"\n# 折线图\nplot_ly(Orange,\n  x = ~age, y = ~circumference, color = ~Tree,\n  type = \"scatter\", mode = \"markers+lines\"\n)"},{"path":"chap-interactive-web-graphics.html","id":"sec-multiple-y-axes","chapter":"第 12 章 交互图形","heading":"12.4 双轴图","text":"双轴图模拟一组数据hoverinfo = \"text\" 表示 tooltips 使用指定的 text 映射，而 visible = \"legendonly\" 表示图层默认隐藏不展示，只在图例里显示，有时候很多条线，默认只是展示几条而已。举例如下\n图 12.4: 双轴图\n","code":"\nset.seed(2020)\ndat <- data.frame(\n  dt = seq(from = as.Date(\"2020-01-01\"), to = as.Date(\"2020-01-31\"), by = \"day\"),\n  search_qv = sample(100000:1000000, size = 31, replace = T)\n) %>%\n  transform(valid_click_qv = sapply(search_qv, rbinom, n = 1, prob = 0.5)) %>%\n  transform(qv_ctr = valid_click_qv / search_qv)\nplot_ly(data = dat) %>%\n  add_bars(\n    x = ~dt, y = ~search_qv, color = I(\"gray80\"), name = \"搜索 QV\",\n    text = ~ paste0(\n      \"日期：\", dt, \"<br>\",\n      \"点击 QV：\", format(valid_click_qv, big.mark = \",\"), \"<br>\",\n      \"搜索 QV：\", format(search_qv, big.mark = \",\"), \"<br>\",\n      \"QV_CTR：\", scales::percent(qv_ctr, accuracy = 0.01), \"<br>\"\n    ),\n    hoverinfo = \"text\"\n  ) %>%\n  add_bars(\n    x = ~dt, y = ~valid_click_qv, color = I(\"gray60\"), name = \"点击 QV\",\n    text = ~ paste0(\n      \"日期：\", dt, \"<br>\",\n      \"点击 QV：\", format(valid_click_qv, big.mark = \",\"), \"<br>\",\n      \"搜索 QV：\", format(search_qv, big.mark = \",\"), \"<br>\",\n      \"QV_CTR：\", scales::percent(qv_ctr, accuracy = 0.01), \"<br>\"\n    ), visible = \"legendonly\",\n    hoverinfo = \"text\"\n  ) %>%\n  add_lines(\n    x = ~dt, y = ~qv_ctr, name = \"QV_CTR\", yaxis = \"y2\", color = I(\"gray40\"),\n    text = ~ paste(\"QV_CTR：\", scales::percent(qv_ctr, accuracy = 0.01), \"<br>\"), \n    hoverinfo = \"text\",\n    line = list(shape = \"spline\", width = 3, dash = \"line\")\n  ) %>%\n  layout(\n    title = \"\",\n    yaxis2 = list(\n      tickfont = list(color = \"black\"),\n      overlaying = \"y\",\n      side = \"right\",\n      title = \"QV_CTR（%）\",\n      # ticksuffix = \"%\", # 设置坐标轴单位\n      tickformat = '.1%', # 设置坐标轴刻度\n      showgrid = F, automargin = TRUE\n    ),\n    xaxis = list(title = \"日期\", showgrid = F, showline = F),\n    yaxis = list(title = \" \", showgrid = F, showline = F),\n    margin = list(r = 20, autoexpand = T),\n    legend = list(\n      x = 0, y = 1, orientation = \"h\",\n      title = list(text = \" \")\n    )\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-histogram","chapter":"第 12 章 交互图形","heading":"12.5 直方图","text":"\n图 12.5: 分组直方图\n","code":"\nplot_ly(iris,\n  x = ~Sepal.Length, colors = \"Greys\",\n  color = ~Species, type = \"histogram\"\n)"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-boxplot","chapter":"第 12 章 交互图形","heading":"12.6 箱线图","text":"\n图 12.6: 箱线图\n","code":"\n# 箱线图\nplot_ly(diamonds,\n  x = ~clarity, y = ~price, colors = \"Greys\",\n  color = ~clarity, type = \"box\"\n)"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-violin","chapter":"第 12 章 交互图形","heading":"12.7 提琴图","text":"\n图 12.7: 提琴图\nplotly 包含图层 27 种，见表 12.3表 12.3: 图层","code":"\nplot_ly(sleep,\n  x = ~group, y = ~extra, split = ~group,\n  type = \"violin\",\n  box = list(visible = T),\n  meanline = list(visible = T)\n)"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-bubble","chapter":"第 12 章 交互图形","heading":"12.8 气泡图","text":"简单图形 scatter，分布图几类，其中 scatter、heatmap、scatterpolar 支持 WebGL 绘图引擎\n图 12.8: 气泡图\n","code":"\n# https://plotly.com/r/bubble-charts/\ndat <- diamonds[, .(\n  carat = mean(carat),\n  price = sum(price), \n  cnt = .N\n), by = .(cut)]\n\nplot_ly(\n  data = dat, colors = \"Greys\",\n  x = ~carat, y = ~price, color = ~cut, size = ~cnt,\n  type = \"scatter\", mode = \"markers\",\n  marker = list(\n    symbol = \"circle\", sizemode = \"diameter\",\n    line = list(width = 2, color = \"#FFFFFF\"), opacity = 0.4\n  ),\n  text = ~ paste(\n    sep = \" \", \"重量：\", round(carat, 2), \"克拉\",\n    \"<br>价格:\", round(price / 10^6, 2), \"百万\"\n  ),\n  hoverinfo = 'text'\n) %>%\n  add_annotations(\n    x = ~carat, y = ~price, text = ~cnt,\n    showarrow = F, font = list(family = \"sans\")\n  ) %>%\n  layout(\n    xaxis = list(hoverformat = \".2f\"),\n    yaxis = list(hoverformat = \".0f\")\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-spline","chapter":"第 12 章 交互图形","heading":"12.9 曲线图","text":"\n图 12.9: 平滑曲线图\n","code":"\nplot_ly(\n  x = c(1, 2.2, 3), y = c(5.3, 6, 7), \n  type = \"scatter\", color = I(\"gray40\"), \n  mode = \"markers+lines\", line = list(shape = \"spline\")\n) %>%\n  add_annotations(\n    x = 2, y = 6, size = I(100),\n    text = TeX(\"x_i \\\\sim N(\\\\mu, \\\\sigma)\")\n  ) %>% \n  layout(\n    xaxis = list(showgrid = F, title = TeX(\"\\\\mu\")),\n    yaxis = list(showgrid = F, title = TeX(\"\\\\alpha\"))\n  ) %>% \n  config(mathjax = 'cdn')"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-tozeroy","chapter":"第 12 章 交互图形","heading":"12.10 堆积图","text":"","code":"\nplot_ly(\n  data = PlantGrowth, y = ~weight,\n  color = ~group, colors = \"Greys\",\n  type = \"scatter\", line = list(shape = \"spline\"),\n  mode = \"lines\", fill = \"tozeroy\"\n)"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-heatmap","chapter":"第 12 章 交互图形","heading":"12.11 热力图","text":"其他基础图形","code":"\nplot_ly(z = volcano, type = 'heatmap', colors = \"Greys\")"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-map","chapter":"第 12 章 交互图形","heading":"12.12 地图 I","text":"plot_mapbox() 使用 Mapbox 提供的地图服务，因此，需要注册一个账户，获取 MAPBOX_TOKEN\n图 12.10: 斐济地震数据\n\n图 12.11: 斐济地震带分布\n\n图 12.12: 美国各州收入\n","code":"\ndata(\"quakes\")\nplot_mapbox(\n  data = quakes, colors = \"Greys\",\n  lon = ~long, lat = ~lat,\n  color = ~mag, size = 2,\n  type = \"scattermapbox\", \n  mode = \"markers\",\n  marker = list(opacity = 0.5)\n) %>%\n  layout(\n    title = \"Fiji Earthquake\",\n    mapbox = list(\n      zoom = 3,\n      center = list(\n        lat = ~ median(lat - 5),\n        lon = ~ median(long)\n      )\n    )\n  ) %>%\n  config(\n    mapboxAccessToken = Sys.getenv(\"MAPBOX_TOKEN\")\n  )\nplotly::plot_ly(\n  data = quakes,\n  lon = ~long, lat = ~lat,\n  type = \"scattergeo\", mode = \"markers\",\n  text = ~ paste0(\n    \"站点：\", stations, \"<br>\",\n    \"震级：\", mag\n  ),\n  marker = list(\n    color = ~mag, \n    size = 10, opacity = 0.8,\n    line = list(color = \"white\", width = 1)\n  )\n) %>%\n  plotly::layout(geo = list(\n    showland = TRUE,\n    landcolor = plotly::toRGB(\"gray95\"),\n    subunitcolor = plotly::toRGB(\"gray85\"),\n    countrycolor = plotly::toRGB(\"gray85\"),\n    countrywidth = 0.5,\n    subunitwidth = 0.5,\n    lonaxis = list(\n      showgrid = TRUE,\n      gridwidth = 0.5,\n      range = c(160, 190),\n      dtick = 5\n    ),\n    lataxis = list(\n      showgrid = TRUE,\n      gridwidth = 0.5,\n      range = c(-40, -10),\n      dtick = 5\n    )\n  ))\ndat <- data.frame(state.x77,\n  stats = rownames(state.x77),\n  stats_abbr = state.abb\n)\n\nplotly::plot_ly(\n  data = dat,\n  type = \"choropleth\",\n  locations = ~stats_abbr,\n  locationmode = \"USA-states\",\n  colorscale = \"Viridis\",\n  z = ~Income\n) |>\n  plotly::layout(\n    geo = list(scope = \"usa\"),\n    title = \"1974年美国各州的人均收入\",\n    legend = list(title = \"收入\")\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-fitted","chapter":"第 12 章 交互图形","heading":"12.13 拟合图","text":"\n图 12.13: 拟合曲线\n","code":"\nplot_ly(economics,\n  type = \"scatter\",\n  x = ~date,\n  y = ~uempmed,\n  name = \"observed unemployment\",\n  mode = \"markers+lines\",\n  marker = list(\n    color = \"red\"\n  ),\n  line = list(\n    color = \"red\",\n    dash = \"dashed\"\n  )\n) %>%\n  add_trace(\n    x = ~date,\n    y = ~fitted(loess(uempmed ~ as.numeric(date))),\n    name = \"fitted unemployment\",\n    mode = \"markers+lines\",\n    marker = list(\n      color = \"orange\"\n    ),\n    line = list(\n      color = \"orange\"\n    )\n  ) %>%\n  layout(\n    title = \"失业时间\",\n    xaxis = list(\n      title = \"日期\",\n      showgrid = F\n    ),\n    yaxis = list(\n      title = \"失业时间（周）\"\n    ),\n    legend = list(\n      x = 0, y = 1, orientation = \"v\",\n      title = list(text = \"\")\n    )\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-rasterly","chapter":"第 12 章 交互图形","heading":"12.14 轨迹图","text":"rasterly 百万量级的散点图\n图 12.14: 散点图\n\n图 12.14: 散点图\n\n图 12.15: 轨迹数据\n","code":"\nlibrary(rasterly)\nplot_ly(quakes, x = ~long, y = ~lat) %>%\n  add_rasterly_heatmap()\nquakes %>%\n  rasterly(mapping = aes(x = long, y = lat)) %>%\n  rasterly_points()\nlibrary(plotly)\n# 读取数据\n# uber 轨迹数据来自 https://github.com/plotly/rasterly\nridesDf <- readRDS(file = 'data/uber.rds')\n\nridesDf %>%\n  rasterly(mapping = aes(x = Lat, y = Lon)) %>%\n  rasterly_points()"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-3d","chapter":"第 12 章 交互图形","heading":"12.15 三维图 (plotly)","text":"\n图 12.16: 三维图形\n\n图 12.16: 三维图形\n\n图 12.16: 三维图形\n","code":"\nplot_ly(z = ~volcano) %>%\n  add_surface()\nplot_ly(x = c(0, 0, 1), y = c(0, 1, 0), z = c(0, 0, 0)) %>%\n  add_mesh()\n# https://plot.ly/r/reference/#scatter3d\ntransform(mtcars, am = ifelse(am == 0, \"Automatic\", \"Manual\")) %>%\n  plot_ly(x = ~wt, y = ~hp, z = ~qsec, \n          color = ~am, colors = c(\"#BF382A\", \"#0C4B8E\")) %>%\n  add_markers() %>%\n  layout(scene = list(\n    xaxis = list(title = \"Weight\"),\n    yaxis = list(title = \"Gross horsepower\"),\n    zaxis = list(title = \"1/4 mile time\")\n  ))"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-gantt-charts","chapter":"第 12 章 交互图形","heading":"12.16 甘特图","text":"项目管理必备，如图所示，本项目拆分成7个任务，一共使用3种项目资源\n图 12.17: 甘特图\n","code":"\n# https://plotly.com/r/gantt/\n# 项目拆解为一系列任务，每个任务的开始时间，持续时间和资源类型\ndf <- data.frame(\n  task = paste(\"Task\", 1:8),\n  start = as.Date(c(\n    \"2016-01-01\", \"2016-02-20\", \"2016-01-01\",\n    \"2016-04-10\", \"2016-06-09\", \"2016-04-10\",\n    \"2016-09-07\", \"2016-11-26\"\n  )),\n  duration = c(50, 25, 100, 60, 30, 150, 80, 10),\n  resource = c(\"A\", \"B\", \"C\", \"C\", \"C\", \"A\", \"B\", \"B\")\n) %>%\n  transform(end = start + duration) %>%\n  transform(y = 1:nrow(.))\n\nplot_ly(data = df) %>%\n  add_segments(\n    x = ~start, xend = ~end,\n    y = ~y, yend = ~y,\n    color = ~resource,\n    mode = \"lines\",\n    colors = \"Greys\", \n    line = list(width = 20),\n    showlegend = F,\n    hoverinfo = \"text\",\n    text = ~ paste(\n      \" 任务: \", task, \"<br>\",\n      \"启动时间: \", start, \"<br>\",\n      \"周期: \", duration, \"天<br>\",\n      \"资源: \", resource\n    )\n  ) %>%\n  layout(\n    xaxis = list(\n      showgrid = F,\n      title = list(text = \"\")\n    ),\n    yaxis = list(\n      showgrid = F,\n      title = list(text = \"\"),\n      tickmode = \"array\",\n      tickvals = 1:nrow(df),\n      ticktext = unique(df$task),\n      domain = c(0, 0.9)\n    ),\n    annotations = list(\n      list(\n        xref = \"paper\", yref = \"paper\",\n        x = 0.80, y = 0.1,\n        text = paste0(\n          \"项目周期: \", sum(df$duration), \" 天<br>\",\n          \"资源类型: \", length(unique(df$resource)), \" 个<br>\"\n        ),\n        font = list(size = 12),\n        ax = 0, ay = 0,\n        align = \"left\"\n      ),\n      list(\n        xref = \"paper\", yref = \"paper\",\n        x = 0.1, y = 1,\n        xanchor = \"left\",\n        text = \"项目资源管理\",\n        font = list(size = 20),\n        ax = 0, ay = 0,\n        align = \"left\",\n        showarrow = FALSE\n      )\n    )\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-pareto-charts","chapter":"第 12 章 交互图形","heading":"12.17 帕雷托图","text":"帕雷托图 20/80 法则\n图 12.18: 帕雷托图\nreorder() 对 complaint 按照降序还是升序由 FUN 函数的单调性决定，单调增对应升序，单调减对应降序","code":"\n# 数据来自 https://github.com/plotly/datasets \ndat <- data.frame(\n  complaint = c(\n    \"Small portions\", \"Overpriced\",\n    \"Wait time\", \"Food is tasteless\", \"No atmosphere\", \"Not clean\",\n    \"Too noisy\", \"Food is too salty\", \"Unfriendly staff\", \"Food not fresh\"\n  ),\n  count = c( 621L, 789L, 109L, 65L, 45L, 30L, 27L, 15L, 12L, 9L)\n)\n\ndat <- dat[order(-dat$count), ] %>%\n  transform(cumulative = round(100 * cumsum(count) / sum(count), digits = 2))\n\n# complaint 按 count 降序排列\ndat$complaint <- reorder(x = dat$complaint, X = dat$count, FUN = function(x) 1/(1 + x))\n\nplot_ly(data = dat) %>%\n  add_bars(\n    x = ~complaint, y = ~count,\n    showlegend = F, color = I(\"gray60\")\n  ) %>%\n  add_lines(\n    x = ~complaint, y = ~cumulative, yaxis = \"y2\",\n    showlegend = F, color = I(\"gray40\")\n  ) %>%\n  layout(\n    yaxis2 = list(\n      tickfont = list(color = \"black\"),\n      overlaying = \"y\",\n      side = \"right\",\n      title = \"累积百分比（%）\",\n      showgrid = F\n    ),\n    xaxis = list(title = \"投诉类型\", showgrid = F, showline = F),\n    yaxis = list(title = \"数量\", showgrid = F, showline = F)\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-vistime","chapter":"第 12 章 交互图形","heading":"12.18 时间线","text":"\n图 12.19: 时间线图\n","code":"\nlibrary(vistime)\n\npres <- data.frame(\n  Position = rep(c(\"President\", \"Vice\"), each = 3),\n  Name = c(\"Washington\", rep(c(\"Adams\", \"Jefferson\"), 2), \"Burr\"),\n  start = c(\"1789-03-29\", \"1797-02-03\", \"1801-02-03\"),\n  end = c(\"1797-02-03\", \"1801-02-03\", \"1809-02-03\"),\n  color = c(\"#cbb69d\", \"#603913\", \"#c69c6e\"),\n  fontcolor = c(\"black\", \"white\", \"black\")\n)\n\nvistime(pres, col.event = \"Position\", col.group = \"Name\")"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-funnel","chapter":"第 12 章 交互图形","heading":"12.19 漏斗图","text":"\n图 12.20: 漏斗图\n\n图 12.21: 漏斗图\n","code":"\ndat <- data.frame(\n  category = c(\"访问\", \"下载\", \"潜客\", \"报价\", \"下单\"),\n  value = c(39, 27.4, 20.6, 11, 2)\n) %>% \n  transform(percent = value / cumsum(value))\n\nplot_ly(data = dat) %>%\n  add_trace(\n    type = \"funnel\",\n    y = ~category,\n    x = ~value,\n    color = ~category, \n    colors = \"Set2\", \n    text = ~ paste0(value, \"<br>\", sprintf(\"%.2f%%\", 100*percent)) ,\n    hoverinfo = \"text\",\n    showlegend = FALSE\n  ) %>%\n  layout(yaxis = list(\n    categoryarray = ~category,\n    title = \"\"\n  ))\nplotly::plot_ly(data = dat) %>%\n  plotly::add_trace(\n    type = \"funnel\",\n    y = ~category,\n    x = ~value,\n    marker = list(color = RColorBrewer::brewer.pal(n = 5, name = \"Set2\")),\n    textposition = \"auto\",\n    textinfo = \"value+percent previous\",\n    hoverinfo = \"none\"\n  ) %>%\n  plotly::layout(yaxis = list(categoryarray = ~category, title = \"\"))"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-radar","chapter":"第 12 章 交互图形","heading":"12.20 雷达图","text":"\n图 12.22: 雷达图\n","code":"\nplot_ly(\n  type = \"scatterpolar\", mode = \"markers\", fill = \"toself\"\n) %>%\n  add_trace(\n    r = c(39, 28, 8, 7, 28, 39), color = I(\"gray40\"),\n    theta = c(\"数学\", \"物理\", \"化学\", \"英语\", \"生物\", \"数学\"),\n    name = \"学生 A\"\n  ) %>%\n  add_trace(\n    r = c(1.5, 10, 39, 31, 15, 1.5), color = I(\"gray80\"),\n    theta = c(\"数学\", \"物理\", \"化学\", \"英语\", \"生物\", \"数学\"),\n    name = \"学生 B\"\n  ) %>%\n  layout(\n    polar = list(\n      radialaxis = list(\n        visible = T,\n        range = c(0, 50)\n      )\n    )\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-waterfall","chapter":"第 12 章 交互图形","heading":"12.21 瀑布图","text":"盈亏图\n图 11.98: 瀑布图\n","code":"\nlibrary(plotly)\nlibrary(dplyr)\n\ndat <- data.frame(\n  x = c(\n    \"销售\", \"咨询\", \"净收入\",\n    \"购买\", \"其他费用\", \"税前利润\"\n  ),\n  y = c(60, 80, 10, -40, -20, 0),\n  measure = c(\n    \"relative\", \"relative\", \"relative\",\n    \"relative\", \"relative\", \"total\"\n  )\n) %>%\n  mutate(text = case_when(\n    y > 0 ~ paste0(\"+\", y),\n    y == 0 ~ \"\",\n    y < 0 ~ as.character(y)\n  )) %>%\n  mutate(x = factor(x, levels = c(\n    \"销售\", \"咨询\", \"净收入\",\n    \"购买\", \"其他费用\", \"税前利润\"\n  )))\n\nn_rows <- nrow(dat)\ndat[nrow(dat), \"text\"] <- \"累计\"\n\n# measure 取值为 'relative'/'total'/'absolute'\nplotly::plot_ly(dat,\n  x = ~x, y = ~y, measure = ~measure, type = \"waterfall\",\n  text = ~text, textposition = \"outside\", \n  name = \"收支\", hoverinfo = \"final\", \n  connector = list(line = list(color = \"gray\")),\n  increasing = list(marker = list(color = \"#66C2A5\")),\n  decreasing = list(marker = list(color = \"#FC8D62\")),\n  totals = list(marker = list(color = \"#8DA0CB\"))\n) %>%\n  plotly::layout(\n    title = \"2018 年收支状态\",\n    xaxis = list(title = \"业务\"),\n    yaxis = list(title = \"金额\"),\n    showlegend = FALSE\n  )"},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-treemap","chapter":"第 12 章 交互图形","heading":"12.22 树状图","text":"plotly 绘制 treemap 和 sunburst 图比较复杂，接口不友好， plotme 正好弥补不足。","code":""},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-sunburst","chapter":"第 12 章 交互图形","heading":"12.23 旭日图","text":"plotme","code":""},{"path":"chap-interactive-web-graphics.html","id":"sec-plotly-color-palette","chapter":"第 12 章 交互图形","heading":"12.24 调色板","text":"构造 20 个类别 超出 Set1 调色板的范围，会触发警告说 Set1 没有那么多色块，但还是返回足够多的色块，也可以使用 viridis、plasma、magma 或 inferno 调色板\n图 12.23: 调色板\n","code":"\nplot_ly(iris,\n  x = ~Petal.Length, y = ~Petal.Width,\n  mode = \"markers\", type = \"scatter\",\n  color = ~ Sepal.Length > 6, colors = c(\"#132B43\", \"#56B1F7\")\n)\nplot_ly(iris,\n  x = ~Petal.Length, y = ~Petal.Width, color = ~ Sepal.Length > 6,\n  mode = \"markers\", type = \"scatter\"\n)\nplot_ly(iris,\n  x = ~Petal.Length, y = ~Petal.Width, color = ~ Sepal.Length > 6,\n  mode = \"markers\", type = \"scatter\", colors = \"Set2\"\n)\nplot_ly(iris,\n  x = ~Petal.Length, y = ~Petal.Width, color = ~ Sepal.Length > 6,\n  mode = \"markers\", type = \"scatter\", colors = \"Set1\"\n)\ndat <- data.frame(\n  dt = rep(seq(\n    from = as.Date(\"2021-01-01\"),\n    to = as.Date(\"2021-01-31\"), by = \"day\"\n  ), each = 20),\n  bu = rep(LETTERS[1:20], 31),\n  qv = rbinom(n = 20 * 31, size = 10000, prob = runif(20 * 31))\n)\n# viridis\nplot_ly(dat,\n  x = ~dt, y = ~qv, color = ~bu, \n  mode = \"markers\", type = \"scatter\", colors = \"viridis\"\n)"},{"path":"chap-interactive-web-graphics.html","id":"sec-export","chapter":"第 12 章 交互图形","heading":"12.25 导出静态图形","text":"orca (Open-source Report Creator App) 软件针对 plotly.js 库渲染的图形具有很强的导出功能，安装 orca 后，plotly::orca() 函数可以将基于 htmlwidgets 的 plotly 图形对象导出为 PNG、PDF 和 SVG 等格式的高质量静态图片。","code":"\np <- plot_ly(x = 1:10, y = 1:10, color = 1:10)\norca(p, \"plot.svg\")"},{"path":"chap-interactive-web-graphics.html","id":"sec-ggplotly","chapter":"第 12 章 交互图形","heading":"12.26 静态图形转交互图形","text":"函数 ggplotly() 将 ggplot 对象转化为交互式 plotly 对象静态图形转化为 plotly 对象添加动态点的注释，比如点横纵坐标、坐标文本，整个注释标签的样式（如背景色）","code":"\ngg <- ggplot(faithful, aes(x = eruptions, y = waiting)) +\n  stat_density_2d(aes(fill = ..level..), geom = \"polygon\") +\n  xlim(1, 6) +\n  ylim(40, 100)\ngg\nggplotly(gg)\nggplotly(gg, dynamicTicks = \"y\") %>%\n  style(., hoveron = \"points\", hoverinfo = \"x+y+text\", \n        hoverlabel = list(bgcolor = \"white\"))"},{"path":"chap-interactive-web-graphics.html","id":"sec-echarts4r-map","chapter":"第 12 章 交互图形","heading":"12.27 地图 II","text":"leaflet 包制作地图，斐济是太平洋上的一个岛国，处于板块交界处，经常发生地震，如下图所示，展示 1964 年来 1000 次震级大于 4 级的地震活动。\n图 12.24: 斐济地震带\n将上面的绘图部分保存为独立的 HTML 网页文件\n图 12.25: 斐济地震带热力图\nleafletCN 提供汉化","code":"\nlibrary(leaflet)\ndata(quakes)\n# Pop 提示\nquakes$popup_text <- lapply(paste(\n  \"编号:\", \"<strong>\", quakes$stations, \"<\/strong>\", \"<br>\",\n  \"震深:\", quakes$depth, \"<br>\",\n  \"震级:\", quakes$mag\n), htmltools::HTML)\n# 构造调色板\npal <- colorBin(\"Spectral\", bins = pretty(quakes$mag), reverse = TRUE)\np <- leaflet(quakes) |>\n  addProviderTiles(providers$CartoDB.Positron) |>\n  addCircles(lng = ~long, lat = ~lat, color = ~ pal(mag), label = ~popup_text) |>\n  addLegend(\"bottomright\",\n    pal = pal, values = ~mag,\n    title = \"地震震级\"\n  ) |>\n  addScaleBar(position = c(\"bottomleft\"))\np\nlibrary(htmlwidgets)\n# p 就是绘图部分的数据对象\nsaveWidget(p, \"fiji-map.html\", selfcontained = T)\nlibrary(leaflet)\nlibrary(leaflet.extras)\n\nquakes |>\n  leaflet() |>\n  addTiles() |>\n  addProviderTiles(providers$OpenStreetMap.DE) |>\n  addHeatmap(\n    lng = ~long, lat = ~lat, intensity = ~mag,\n    max = 100, radius = 20, blur = 10\n  )\n# 地图默认放大倍数\nzoom         <- 4\n# 地图可以放大的倍数区间\nminZoom      <- 1\nmaxZoom      <- 18\n\nlibrary(leaflet)\nlibrary(leafletCN)\nlibrary(maptools)\nlibrary(leaflet.extras)\n\n# 热力图 heatmap\nleaflet(res, options = leafletOptions(minZoom = minZoom, maxZoom = maxZoom)) |>\n  amap() |>\n  # setView(lng = mean(data$long), lat = mean(data$lat), zoom = zoom) |>\n  setView(lng = 109, lat = 38, zoom = 4) |>\n  addHeatmap(\n    lng = ~long2, lat = ~lat2, intensity = ~uv, max = max(res$uv),\n    blur = blur, minOpacity = minOpacity, radius = radius\n  )\n\nquakes$popup_text <- lapply(paste(\n  \"编号:\", \"<strong>\", quakes$stations, \"<\/strong>\", \"<br>\",\n  \"震深:\", quakes$depth, \"<br>\",\n  \"震级:\", quakes$mag\n), htmltools::HTML)\n# 构造调色板\npal <- colorBin(\"Spectral\", bins = pretty(quakes$mag), reverse = TRUE)\n\nleaflet(quakes) |>\n  addProviderTiles(providers$CartoDB.Positron) |>\n  addCircles(\n    lng = ~long, lat = ~lat,\n    color = ~ pal(mag), label = ~popup_text\n  ) |>\n  setView(178, -20, 5) |>\n  addHeatmap(\n    lng = ~long, lat = ~lat, intensity = ~mag,\n    blur = 20, max = 0.05, radius = 15\n  ) |>\n  addLegend(\"bottomright\",\n    pal = pal, values = ~mag,\n    title = \"地震震级\"\n  ) |>\n  addScaleBar(position = c(\"bottomleft\"))"},{"path":"chap-interactive-web-graphics.html","id":"sec-echarts4r-animation","chapter":"第 12 章 交互图形","heading":"12.28 动画","text":"","code":"\n# https://d.cosx.org/d/422311\nlibrary(echarts4r)\n\ndata(\"gapminder\", package = \"gapminder\")\n\ntitles <- lapply(unique(gapminder$year), function(x) {\n  list(\n    text = \"Gapminder\",\n    left = \"center\"\n  )\n})\n\nyears <- lapply(unique(gapminder$year), function(x) {\n  list(\n    subtext = x,\n    left = \"center\",\n    top = \"center\",\n    z = 0,\n    subtextStyle = list(\n      fontSize = 100,\n      color = \"rgb(170, 170, 170, 0.5)\",\n      fontWeight = \"bolder\"\n    )\n  )\n})\n\n# 添加一列颜色，各大洲和颜色的对应关系可自定义，调整 levels 或 labels 里面的顺序即可，也可不指定 levels ，调用其它调色板\ngapminder <- within(gapminder, {\n  color <- factor(\n    continent,\n    levels = c(\"Asia\", \"Africa\", \"Americas\", \"Europe\", \"Oceania\"),\n    labels = RColorBrewer::brewer.pal(n = 5, name = \"Spectral\")\n  )\n})\n\ngapminder |>\n  group_by(year) |>\n  e_charts(x = gdpPercap, timeline = TRUE) |>\n  e_scatter(\n    serie = lifeExp, size = pop, bind = country,\n    symbol_size = 5, name = \"\"\n  ) |>\n  e_add(\"itemStyle\", color) |>\n  e_y_axis(\n    min = 20, max = 85, nameGap = 30,\n    name = \"Life Exp\", nameLocation = \"center\"\n  ) |>\n  e_x_axis(\n    type = \"log\", min = 100, max = 100000,\n    nameGap = 30, name = \"GDP / Cap\", nameLocation = \"center\"\n  ) |>\n  e_timeline_serie(title = titles) |>\n  e_timeline_serie(title = years, index = 2) |>\n  e_timeline_opts(playInterval = 1000) |>\n  e_grid(bottom = 100) |>\n  e_tooltip()"},{"path":"chap-interactive-web-graphics.html","id":"sec-network-analysis","chapter":"第 12 章 交互图形","heading":"12.29 网络图","text":"gephi 探索和可视化网络图 GraphViz","code":"\n# library(igraph)"},{"path":"chap-interactive-web-graphics.html","id":"subsec-networkD3","chapter":"第 12 章 交互图形","heading":"12.29.1 networkD3","text":"networkD3 D3 非常适合绘制网络图，如网络、树状、桑基图构造网络图","code":"\nlibrary(networkD3)\ndata(MisLinks, MisNodes) # 加载数据\nhead(MisLinks) # 边##   source target value\n## 1      1      0     1\n## 2      2      0     8\n## 3      3      0    10\n## 4      3      2     6\n## 5      4      0     1\n## 6      5      0     1\nhead(MisNodes) # 节点##              name group size\n## 1          Myriel     1   15\n## 2        Napoleon     1   20\n## 3 Mlle.Baptistine     1   23\n## 4    Mme.Magloire     1   30\n## 5    CountessdeLo     1   11\n## 6        Geborand     1    9\nforceNetwork(\n  Links = MisLinks, Nodes = MisNodes, Source = \"source\",\n  Target = \"target\", Value = \"value\", NodeID = \"name\",\n  Group = \"group\", opacity = 0.4\n)"},{"path":"chap-interactive-web-graphics.html","id":"subsec-visNetwork","chapter":"第 12 章 交互图形","heading":"12.29.2 visNetwork","text":"visNetwork 使用 vis-network.js 库绘制网络关系图 https://datastorm-open.github.io/visNetwork调用函数 visTree() 可视化分类模型结果节点、边的属性都可以映射数据指标","code":"\nlibrary(visNetwork)\nlibrary(rpart)\nlibrary(sparkline) # 函数 visTree 需要导入 sparkline 包\nres <- rpart(Species~., data=iris)\nvisTree(res, main = \"鸢尾花分类树\", width = \"100%\")"},{"path":"chap-interactive-web-graphics.html","id":"subsec-r2d3","chapter":"第 12 章 交互图形","heading":"12.29.3 r2d3","text":"D3 是非常流行的 JavaScript 库，r2d3 提供了 R 接口更加具体的使用介绍，一个复杂的案例，如何从简单配置过来，以条形图为例， D3 是一个相当强大且成熟的库，提供的案例功能要覆盖 plotlyr2d3 提供了两个样例 JS 库 baranims.js 和 barchart.js\n图 12.26: D3 图形\n\n图 12.27: D3 图形\n","code":"\nlibrary(r2d3)\nlist.files(system.file(\"examples/\", package = \"r2d3\"))## [1] \"baranims.js\" \"barchart.js\"\nlibrary(r2d3)\nr2d3(\n  data = c(0.3, 0.6, 0.8, 0.95, 0.40, 0.20),\n  script = system.file(\"examples/barchart.js\", package = \"r2d3\")\n)\nr2d3(\n  data = c(0.3, 0.6, 0.8, 0.95, 0.40, 0.20),\n  script = system.file(\"examples/baranims.js\", package = \"r2d3\")\n)"},{"path":"chap-interactive-web-graphics.html","id":"sec-web-graphics-session","chapter":"第 12 章 交互图形","heading":"12.30 运行环境","text":"","code":"\nsessionInfo()## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-pc-linux-gnu (64-bit)\n## Running under: Ubuntu 20.04.4 LTS\n## \n## Matrix products: default\n## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\n## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n## \n## locale:\n##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n## \n## attached base packages:\n## [1] stats     graphics  grDevices utils     datasets  methods   base     \n## \n## other attached packages:\n##  [1] sparkline_2.0     rpart_4.1.16      visNetwork_2.1.0  networkD3_0.4    \n##  [5] echarts4r_0.4.3   dplyr_1.0.9       vistime_1.2.1     rasterly_0.2.0   \n##  [9] Rcpp_1.0.8.3      data.table_1.14.2 r2d3_0.2.6        plotly_4.10.0    \n## [13] ggplot2_3.3.6    \n## \n## loaded via a namespace (and not attached):\n##  [1] httr_1.4.3                 sass_0.4.1                \n##  [3] tidyr_1.2.0                jsonlite_1.8.0            \n##  [5] viridisLite_0.4.0          bslib_0.3.1               \n##  [7] shiny_1.7.1                assertthat_0.2.1          \n##  [9] highr_0.9                  yaml_2.3.5                \n## [11] ggrepel_0.9.1              pillar_1.7.0              \n## [13] glue_1.6.2                 digest_0.6.29             \n## [15] assertive.types_0.0-3      RColorBrewer_1.1-3        \n## [17] promises_1.2.0.1           colorspace_2.0-3          \n## [19] htmltools_0.5.2            httpuv_1.6.5              \n## [21] pkgconfig_2.0.3            assertive.properties_0.0-5\n## [23] bookdown_0.26              sysfonts_0.8.8            \n## [25] purrr_0.3.4                xtable_1.8-4              \n## [27] scales_1.2.0               later_1.3.0               \n## [29] downlit_0.4.0              tibble_3.1.7              \n## [31] generics_0.1.2             farver_2.1.0              \n## [33] ellipsis_0.3.2             cachem_1.0.6              \n## [35] withr_2.5.0                lazyeval_0.2.2            \n## [37] cli_3.3.0                  magrittr_2.0.3            \n## [39] crayon_1.5.1               mime_0.12                 \n## [41] memoise_2.0.1              evaluate_0.15             \n## [43] fs_1.5.2                   fansi_1.0.3               \n## [45] MASS_7.3-57                xml2_1.3.3                \n## [47] tools_4.2.0                lifecycle_1.0.1           \n## [49] stringr_1.4.0              munsell_0.5.0             \n## [51] isoband_0.2.5              compiler_4.2.0            \n## [53] jquerylib_0.1.4            rlang_1.0.2               \n## [55] grid_4.2.0                 rstudioapi_0.13           \n## [57] htmlwidgets_1.5.4          crosstalk_1.2.0           \n## [59] assertive.base_0.0-9       igraph_1.3.1              \n## [61] labeling_0.4.2             rmarkdown_2.14            \n## [63] gtable_0.3.0               codetools_0.2-18          \n## [65] DBI_1.1.2                  curl_4.3.2                \n## [67] R6_2.5.1                   knitr_1.39                \n## [69] fastmap_1.1.0              utf8_1.2.2                \n## [71] stringi_1.7.6              vctrs_0.4.1               \n## [73] png_0.1-7                  tidyselect_1.1.2          \n## [75] xfun_0.31"},{"path":"chap-statistical-computation.html","id":"chap-statistical-computation","chapter":"介绍","heading":"介绍","text":"统计计算","code":""},{"path":"chap-numerical-optimization.html","id":"chap-numerical-optimization","chapter":"第 13 章 数值优化","heading":"第 13 章 数值优化","text":"R 语言提供了相当多的优化求解器，比较完整的概览见优化视图。 本章介绍一些常用的优化算法及其R实现，涵盖线性规划、整数规划、二次规划、非线性规划等。商业优化求解器的能力都覆盖非线性规划（NLP），线性（LP）、二次（QP）和锥规划（SOCP），混合整数线性规划（MILP），多目标优化，最小二乘和方程求解。此外，还有很多文档介绍，\nLINGO提供用户手册，\nMatlab 优化工具箱 提供 Optimization 工具箱使用指南，\nMOSEK (https://www.mosek.com/) 提供 MOSEK 建模食谱，LocalSolver 提供基本使用手册，\nGurobi 提供 Gurobi 参考手册，CPLEX Optimization Studio。开源社区有不少工具，也能求解常见的优化问题，如 Julia 的 JuMP (https://jump.dev/)，Octave (https://www.gnu.org/software/octave/) 内置的优化函数，Python 模块 SciPy 提供 Optimization 优化求解器，cvxopt 凸优化求解器，主要基于内点法，提供 Julia、Python、Matlab 接口，算法介绍见\n锥优化\n机器学习优化。\n课程见 Optimization Machine Learning，书籍见Convex Optimization，相关综述见Convex Optimization: Algorithms Complexity。Berwin . Turlach 开发的 quadprog 主要用于求解二次规划问题。Anqi Fu 开发的 CVXR 可解很多凸优化问题 [27]，详见网站 https://cvxr.rbind.io/，Jelmer Ypma 开发的 nloptr 可解无约束和有约束的非线性规划问题 [28]，GPareto 求解多目标优化问题，帕雷托前沿优化和估计[29]。igraph 可以用来解决最短路径、最大网络流、最小生成树等图优化相关的问题。 https://palomar.home.ece.ust.hk/MAFS6010R_lectures/Rsession_solvers.html 提供了一般的求解器介绍。ROI 包力图统一各个求解器的调用接口，打造一个优化算法的基础设施平台。[30] 详细介绍了目前优化算法发展情况及 R 社区提供的优化能力。GA 包实现了遗传算法，支持连续和离散的空间搜索，可以并行 [31], [32]，是求解 TSP 问题的重要方法。NMOF 包实现了差分进化、遗传算法、粒子群算法、模拟退火算法等启发式优化算法，还提供网格搜索和贪婪搜索工具，[33] 提供了详细的介绍。[34] 总结了 R 语言环境下最优化问题的最佳实践。RcppEnsmallen 数值优化\n通用标准的优化方法，前沿最新的优化方法，包含小批量/全批量梯度下降技术、无梯度优化器，约束优化技术。RcppNumerical 无约束数值优化，一维/多维数值积分。谷歌开源的运筹优化工具 -tools 提供了约束优化、线性优化、混合整数优化、装箱和背包算法、TSP（Traveling Salesman Problem）、VRP（Vehicle Routing Problem）、图算法（最短路径、最小成本流、最大流等）等算法和求解器。「运筹OR帷幄」社区开源的 线性规划 一书值得一看。表 13.1 对目前的优化器按优化问题做了分类\n表 13.1: ROI 插件按优化问题分类\n","code":"\n# 加载 ROI 时不要自动加载插件\nSys.setenv(ROI_LOAD_PLUGINS = FALSE)\nlibrary(lpSolve)    # 线性规划求解器\nlibrary(ROI)        # 优化工具箱\nlibrary(ROI.plugin.alabama)  # 注册 alabama 求解非线性规划\nlibrary(ROI.plugin.nloptr)   # 注册 nloptr 求解非线性规划\nlibrary(ROI.plugin.lpsolve)  # 注册 lpsolve 求解线性规划\nlibrary(ROI.plugin.quadprog) # 注册 quadprog 求解二次规划\nlibrary(ROI.plugin.scs)      # 注册 scs 求解凸锥规划\nlibrary(lattice)    # 图形绘制\nlibrary(kernlab)    # 优化问题和机器学习的关系\n\nlibrary(rootSolve)       # 非线性方程\nlibrary(BB)              # 非线性方程组\nlibrary(deSolve)         # ODE 常微分方程\nlibrary(scatterplot3d)   # 三维曲线图\n\nlibrary(shape)\nlibrary(ReacTran)        # PDE 偏微分方程\nlibrary(PBSddesolve)     # DAE 延迟微分方程\n\nlibrary(nlme)              # 混合效应模型\n# library(nlmeODE)         # ODE 应用于混合效应模型\n# library(Sim.DiffProc)    # SDE 随机微分方程 种群 ODE 建模\n# library(nlmixr)          # Population ODE modeling"},{"path":"chap-numerical-optimization.html","id":"sec-linear-programming","chapter":"第 13 章 数值优化","heading":"13.1 线性规划","text":"clpAPI 线性规划求解器。glpk 的两个 R 接口 – glpkAPI 和\nRglpk 提供线性规划和混合整数规划的求解能力。lp_solve 的两个 R 接口 –\nlpSolveAPI 和 lpSolve 也提供类似的能力。ompr 求解混合整数线性规划问题。举个例子，如下\\[\\begin{equation*}\n\\begin{array}{l}\n  \\min_x \\quad -6x_1 -5x_2 \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n    x_1  + 4x_2 \\leq 16\\\\\n    6x_1 + 4x_2 \\leq 28\\\\\n    2x_1 - 5x_2 \\leq 6\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]写成矩阵形式\\[\\begin{equation*}\n\\begin{array}{l}\n\\min_x \\quad\n  \\begin{bmatrix}\n  -6  \\\\\n  -5\n  \\end{bmatrix}\n  ^{T} x \\\\\ns.t.\\left\\{ \n \\begin{array}{l}\n  \\begin{bmatrix}\n  1 & 4  \\\\\n  6 & 4  \\\\\n  2 & -5 \n  \\end{bmatrix}\n  x \\leq\n  \\begin{bmatrix}\n   16 \\\\\n   28 \\\\\n   6\n  \\end{bmatrix}\n \\end{array} \\right.\n\\end{array} \n\\end{equation*}\\]对应成 R 代码如下","code":"\n# lpSolve 添加约束条件\nlibrary(lpSolve)\n# 目标\nf.obj <- c(-6, -5)\n# 约束\nf.con <- matrix(c(1, 4, 6, 4, 2, -5), nrow = 3, byrow = TRUE)\n# 方向\nf.dir <- c(\"<=\", \"<=\", \"<=\")\n# 右手边\nf.rhs <- c(16, 28, 6)\nres <- lp(\"min\", f.obj, f.con, f.dir, f.rhs)\nres$objval## [1] -31.4\nres$solution## [1] 2.4 3.4"},{"path":"chap-numerical-optimization.html","id":"sec-integer-programming","chapter":"第 13 章 数值优化","heading":"13.2 整数规划","text":"","code":""},{"path":"chap-numerical-optimization.html","id":"common-integer-programming","chapter":"第 13 章 数值优化","heading":"13.2.1 一般整数规划","text":"\\[\\begin{equation*}\n\\begin{array}{l}\n  \\max_x \\quad 0.2x_1 + 0.6x_2 \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n    5x_1  + 3x_2 \\leq 250\\\\\n    -3x_1 + 2x_2 \\leq 4\\\\\n    x_1,x_2 \\geq 0, \\quad x_1,x_2 \\\\mathbb{Z}\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]","code":"\n# 目标\nf.obj <- c(0.2, 0.6)\n# 约束\nf.con <- matrix(c(5, 3, -3, 2), nrow = 2, byrow = TRUE)\n# 方向\nf.dir <- c(\"<=\", \"<=\")\n# 右手边\nf.rhs <- c(250, 4)\n# 限制两个变量都是整数\nres <- lp(\"max\", f.obj, f.con, f.dir, f.rhs, int.vec=1:2)\nres$objval## [1] 29.2\nres$solution## [1] 26 40"},{"path":"chap-numerical-optimization.html","id":"binary-integer-programming","chapter":"第 13 章 数值优化","heading":"13.2.2 0-1 整数规划","text":"\\[\\begin{equation*}\n\\begin{array}{l}\n  \\max_x \\quad 0.2x_1 + 0.6x_2 \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n    5x_1  + 3x_2 \\leq 250\\\\\n    -3x_1 + 2x_2 \\leq 4\\\\\n    x_1,x_2 \\\\{0,1\\}\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]","code":"\n# 目标\nf.obj <- c(0.2, 0.6)\n# 约束\nf.con <- matrix(c(5, 3, -3, 2), nrow = 2, byrow = TRUE)\n# 方向\nf.dir <- c(\"<=\", \"<=\")\n# 右手边\nf.rhs <- c(250, 4)\n# 限制两个变量都是0-1整数\nres <- lp(\"max\", f.obj, f.con, f.dir, f.rhs, int.vec=1:2, all.bin = TRUE)\nres$objval## [1] 0.8\nres$solution## [1] 1 1"},{"path":"chap-numerical-optimization.html","id":"mixed-integer-programming","chapter":"第 13 章 数值优化","heading":"13.2.3 混合整数规划","text":"Rsymphony 是混合整数规划求解器 SYMPHONY 的 R 语言接口50。一部分变量要求是整数\\[\\begin{equation*}\n\\begin{array}{l}\n  \\max_x \\quad 3x_1 + 7x_2 - 12x_3 \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n    5x_1 + 7x_2 + 2x_3 \\leq 61\\\\\n    3x_1 + 2x_2 - 9x_3 \\leq 35\\\\\n    x_1 + 3x_2 + x_3 \\leq 31\\\\\n    x_1,x_2 \\geq 0, \\quad x_2, x_3 \\\\mathbb{Z}, \\quad x_3 \\[-10, 10]\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]矩阵形式如下\\[\\begin{equation*}\n\\begin{array}{l}\n\\min_x \\quad\n  \\begin{bmatrix}\n  3  \\\\\n  7  \\\\\n  -12\n  \\end{bmatrix}\n  ^{T} x \\\\\ns.t.\\left\\{ \n \\begin{array}{l}\n  \\begin{bmatrix}\n  5 & 7 & 2 \\\\\n  3 & 2 & -9\\\\\n  1 & 3 & 1\n  \\end{bmatrix}\n  x \\leq\n  \\begin{bmatrix}\n   61 \\\\\n   35 \\\\\n   31\n  \\end{bmatrix}\n \\end{array} \\right.\n\\end{array} \n\\end{equation*}\\]","code":"\nlibrary(Rsymphony)\n## Simple linear program.\n## maximize: 2 x_1 + 4 x_2 + 3 x_3\n## subject to: 3 x_1 + 4 x_2 + 2 x_3 <= 60\n## 2 x_1 + x_2 + x_3 <= 40\n## x_1 + 3 x_2 + 2 x_3 <= 80\n## x_1, x_2, x_3 are non-negative real numbers\n\n# 简单线性规划\nobj <- c(2, 4, 3)\nmat <- matrix(c(3, 2, 1, 4, 1, 3, 2, 1, 2), nrow = 3)\ndir <- c(\"<=\", \"<=\", \"<=\")\nrhs <- c(60, 40, 80)\nmax <- TRUE\nRsymphony_solve_LP(obj, mat, dir, rhs, max = max)\n\n# 混合整数规划\nobj <- c(3, 1, 3)\nmat <- matrix(c(-1, 0, 1, 2, 4, -3, 1, -3, 2), nrow = 3)\ndir <- c(\"<=\", \"<=\", \"<=\")\nrhs <- c(4, 2, 3)\nmax <- TRUE\ntypes <- c(\"I\", \"C\", \"I\")\nRsymphony_solve_LP(obj, mat, dir, rhs, types = types, max = max)\n\n# 有边界约束的混合整数规划\n## Same as before but with bounds replaced by\n## -Inf < x_1 <= 4\n## 0 <= x_2 <= 100\n## 2 <= x_3 < Inf\nbounds <- list(\n  lower = list(ind = c(1L, 3L), val = c(-Inf, 2)),\n  upper = list(ind = c(1L, 2L), val = c(4, 100))\n)\nRsymphony_solve_LP(obj, mat, dir, rhs,\n  types = types, max = max,\n  bounds = bounds\n)\nop <- OP(\n  objective = L_objective(c(3, 7, -12)),\n  # 指定变量类型：第1个变量是连续值，第2、3个变量是整数\n  types = c(\"C\", \"I\", \"I\"),\n  constraints = L_constraint(\n    L = matrix(c(\n      5, 7, 2,\n      3, 2, -9,\n      1, 3, 1\n    ), ncol = 3, byrow = TRUE),\n    dir = c(\"<=\", \"<=\", \"<=\"),\n    rhs = c(61, 35, 31)\n  ),\n  # 添加约束：第3个变量的下、上界分别是 -10 和 10\n  bounds = V_bound(li = 3, ui = 3, lb = -10, ub = 10, nobj = 3),\n  maximum = TRUE\n)\nop## ROI Optimization Problem:\n## \n## Maximize a linear objective function of length 3 with\n## - 1 continuous objective variable,\n## - 2 integer objective variables,\n## \n## subject to\n## - 3 constraints of type linear.\n## - 1 lower and 1 upper non-standard variable bound.\nres <- ROI_solve(op, solver = \"lpsolve\")\nres$solution## [1]  0.3333333  8.0000000 -2.0000000\nres$objval## [1] 81"},{"path":"chap-numerical-optimization.html","id":"sec-quadratic-programming","chapter":"第 13 章 数值优化","heading":"13.3 二次规划","text":"","code":""},{"path":"chap-numerical-optimization.html","id":"sec-strictly-convex-quadratic-program","chapter":"第 13 章 数值优化","heading":"13.3.1 凸二次规划","text":"在 R 中使用 quadprog [35] 包求解二次规划51，quadprogXT 包用来求解带绝对值约束的二次规划，pracma [36]包提供 quadprog() 函数就是对 quadprog 包的 solve.QP() 进行封装，调用风格更像 Matlab。quadprog 包实现了 Goldfarb Idnani (1982, 1983) 提出的对偶方法，主要用来求解带线性约束的严格凸二次规划问题。quadprog 求解的二次型的形式如下：\\[\\min_b - d^{\\top}b +\\frac{1}{2}b^{\\top}Db , \\quad ^{\\top}b \\geq b_{0}\\]参数 Dmat、dvec、Amat、bvec 分别对应二次规划问题中的 \\(D,d,,b_{0}\\)。下面举个二次规划的具体例子\\[\nD = \\begin{bmatrix}2 & -1\\\\\n-1 & 2\n\\end{bmatrix}, \\quad\nd = (-3,2), \\quad\n= \\begin{bmatrix}1 & 1\\\\\n-1 & 1 \\\\\n0  & -1\n\\end{bmatrix}, \\quad\nb_{0} = (2,-2,-3)\n\\]\n即目标函数 \\[Q(x,y) = x^2 + y^2 -xy+3x-2y+4\\]\n它的可行域如图13.1所示\n图 13.1: 可行域\n调用 quadprog 包的 solve.QP() 函数求解此二次规划问题ROI 默认的二次规划的标准形式为 \\(\\frac{1}{2}x^{\\top}Qx + ^{\\top}x\\)，在传递参数值的时候注意和上面的区别。对变量 \\(x\\) 添加整型约束，原二次规划即变成混合整数二次规划 （Mixed Integer Quadratic Programming，简称 MIQP）在可行域上画出等高线，标记目标解的位置，图中红点表示无约束下的解，黄点表示线性约束下的解\n图 13.2: 无约束和有约束条件下的解\n","code":"\nsolve.QP(Dmat, dvec, Amat, bvec, meq = 0, factorized = FALSE)\nplot(0, 0,\n  xlim = c(-2, 5.5), ylim = c(-1, 3.5), type = \"n\",\n  xlab = \"x\", ylab = \"y\", main = \"Feasible Region\"\n)\npolygon(c(2, 5, -1), c(0, 3, 3), border = TRUE, lwd = 2, col = \"gray\")\nlibrary(quadprog)\nDmat <- matrix(c(2, -1, -1, 2), nrow = 2, byrow = TRUE)\ndvec <- c(-3, 2)\nA <- matrix(c(1, 1, -1, 1, 0, -1), ncol = 2, byrow = TRUE)\nbvec <- c(2, -2, -3)\nAmat <- t(A)\nsol <- solve.QP(Dmat = Dmat, dvec = dvec, Amat = Amat, bvec = bvec)\nsol## $solution\n## [1] 0.1666667 1.8333333\n## \n## $value\n## [1] -0.08333333\n## \n## $unconstrained.solution\n## [1] -1.3333333  0.3333333\n## \n## $iterations\n## [1] 2 0\n## \n## $Lagrangian\n## [1] 1.5 0.0 0.0\n## \n## $iact\n## [1] 1\nlibrary(ROI)\nop <- OP(\n  objective = Q_objective(Q = Dmat, L = -dvec),\n  constraints = L_constraint(A, rep(\">=\", 3), bvec),\n  maximum = FALSE # 默认求最小\n)\nnlp <- ROI_solve(op, solver = \"nloptr.slsqp\", start = c(1, 2))\nnlp$objval## [1] -0.08333333\nnlp$solution## [1] 0.1666667 1.8333333\n# 目前开源的求解器都不能处理 MIQP 问题\nop <- OP(\n  objective = Q_objective(Q = Dmat, L = -dvec),\n  constraints = L_constraint(A, rep(\">=\", 3), bvec),\n  types = c(\"I\", \"C\"),\n  maximum = FALSE # 默认求最小\n)\nnlp <- ROI_solve(op, solver = \"nloptr.slsqp\", start = c(1, 2))\nnlp$objval\nnlp$solution\nqp_sol <- sol$solution # 二次规划的解\nuc_sol <- sol$unconstrained.solution # 无约束情况下的解\n# 画图\nlibrary(lattice)\nx <- seq(-2, 5.5, length.out = 500)\ny <- seq(-1, 3.5, length.out = 500)\ngrid <- expand.grid(x = x, y = y)\n# 二次规划的目标函数\ngrid$z <- with(grid, x^2 + y^2 - x * y + 3 * x - 2 * y + 4)\nlevelplot(z ~ x * y, grid,\n  cuts = 40,\n  panel = function(...) {\n    panel.levelplot(...)\n    panel.polygon(c(2, 5, -1), c(0, 3, 3),\n      border = TRUE,\n      lwd = 2, col = \"transparent\"\n    )\n    panel.points(\n      c(uc_sol[1], qp_sol[1]),\n      c(uc_sol[2], qp_sol[2]),\n      lwd = 5, col = c(\"red\", \"yellow\"), pch = 19\n    )\n  },\n  colorkey = TRUE,\n  col.regions = terrain.colors(40)\n)"},{"path":"chap-numerical-optimization.html","id":"subsec-semidefinite-optimization","chapter":"第 13 章 数值优化","heading":"13.3.2 半正定二次优化","text":"kernlab 提供基于核的机器学习方法，可用于分类、回归、聚类、异常检测、分位回归、降维等场景，包含支撑向量机、谱聚类、核PCA、高斯过程和二次规划求解器，将优化方法用于机器学习，展示二者的关系。R 包 kernlab 的函数 ipop() 实现内点法可以求解半正定的二次规划问题，对应到上面的例子，就是要求 \\(\\geq 0\\)，而 R 包 quadprog 只能求解正定的二次规划问题，即要求 \\(> 0\\)。以二分类问题为例，采用 SMO (Sequential Minimization Optimization) 求解器，将 SVM 的二次优化问题分解。\n图 13.3: 二分类问题\n","code":"\nlibrary(kernlab)\nset.seed(123)\nx <- rbind(matrix(rnorm(120), 60, 2), matrix(rnorm(120, mean = 3), 60, 2))\ny <- matrix(c(rep(1, 60), rep(-1, 60)))\nsvp <- ksvm(x, y, type = \"C-svc\")\nplot(svp, data = x)"},{"path":"chap-numerical-optimization.html","id":"sec-nonlinear-programming","chapter":"第 13 章 数值优化","heading":"13.4 非线性规划","text":"开源的非线性优化求解器，推荐使用 nloptr，它支持全局优化，同时推荐 ROI，它有统一的接口函数。","code":""},{"path":"chap-numerical-optimization.html","id":"sec-one-dimensional-optimization","chapter":"第 13 章 数值优化","heading":"13.4.1 一元非线性优化","text":"下面考虑一个稍微复杂的一元函数优化问题，求复合函数的极值\\[\ng(x) = \\int_{0}^{x} -\\sqrt{t}\\exp(-t^2) \\mathrm{dt}, \\quad f(y) = \\int_{0}^{y} g(s) \\exp(-s) \\mathrm{ds}\n\\]计算积分的时候，输入了一系列 s 值，参数是向量，而函数 g 只支持输入参数是单个值，g(c(1,2)) 会报错，因此上面对函数 g() 用了向量化函数 Vectorize() 操作。类似地，同时计算多个目标函数 f(y) 的值，也需要Vectorize() 实现向量化操作。","code":"\ng <- function(x) {\n  integrate(function(t) {\n    -sqrt(t) * exp(-t^2)\n  }, lower = 0, upper = x)$value\n}\n\nf <- function(y) {\n  integrate(function(s) {\n    Vectorize(g, \"x\")(s) * exp(-s)\n  }, lower = 0, upper = y)$value\n}\n\noptimize(f, interval = c(10, 100), maximum = FALSE)## $minimum\n## [1] 66.84459\n## \n## $objective\n## [1] -0.3201572\ng(1)## [1] -0.453392\nVectorize(f, \"y\")(c(1, 2))## [1] -0.1103310 -0.2373865"},{"path":"chap-numerical-optimization.html","id":"sec-nonlinear-unconstrained-optimization","chapter":"第 13 章 数值优化","heading":"13.4.2 多元非线性无约束优化","text":"下面这些用来测试优化算法的函数来自维基百科","code":""},{"path":"chap-numerical-optimization.html","id":"himmelblau","chapter":"第 13 章 数值优化","heading":"13.4.2.1 Himmelblau 函数","text":"Himmelblau 函数是一个多摸函数，常用于比较优化算法的优劣。\\[f(x_1,x_2) = (x_1^2 + x_2 -11)^2 + (x_1 + x_2^2 -7)^2\\]\n它在四个位置取得一样的极小值，分别是 \\(f(-3.7793, -3.2832) = 0\\)，\\(f(-2.8051, 3.1313) = 0\\)，\\(f(3, 2) = 0\\)，\\(f(3.5844, -1.8481) = 0\\)。函数图像见图 13.4。\n图 13.4: Himmelblau 函数图像\n","code":"\n# 目标函数\nfn <- function(x) {\n   (x[1]^2 + x[2] - 11)^2 + (x[1] + x[2]^2 - 7)^2\n}\n\ndf <- expand.grid(\n  x = seq(-5, 5, length = 101),\n  y = seq(-5, 5, length = 101)\n)\n\ndf$fnxy = apply(df, 1, fn)\n\nlibrary(lattice)\n# 减少三维图形的边空\nlattice.options(\n  layout.widths = list(\n    left.padding = list(x = -.6, units = \"inches\"),\n    right.padding = list(x = -1.0, units = \"inches\")\n  ),\n  layout.heights = list(\n    bottom.padding = list(x = -.8, units = \"inches\"),\n    top.padding = list(x = -1.0, units = \"inches\")\n  )\n)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = -240, x = -70, y = 0)\n)\n# 梯度函数\ngr <- function(x) {\n  numDeriv::grad(fn, c(x[1], x[2])) \n}\noptim(par = c(-1.2, 1), fn = fn, gr = gr, method = \"BFGS\")## $par\n## [1] -2.805118  3.131313\n## \n## $value\n## [1] 2.069971e-27\n## \n## $counts\n## function gradient \n##       42       15 \n## \n## $convergence\n## [1] 0\n## \n## $message\n## NULL"},{"path":"chap-numerical-optimization.html","id":"peaks","chapter":"第 13 章 数值优化","heading":"13.4.2.2 Peaks 函数","text":"测试函数\\[\nf(x,y) = 3*(1-x)*\\mathrm{e}^{-x^2 - (y+1)^2} - 10*(\\frac{x}{5} - x^3 - y^5)*\\mathrm{e}^{-x^2-y^2} - \\frac{1}{3}*\\mathrm{e}^{-(x+1)^2-y^2}\n\\]在 \\((-1.3473958, 0.2045192)\\) 处取得极小值\n图 13.5: Peaks 多峰图像\n函数来自 Octave 内置的 peaks() 函数，它有很多的局部极大值和极小值，可在 Octave Online 上输入命令 help peaks 查看其帮助文档。","code":"\npeaks <- expression(3*(1-x)*exp^(-x^2 - (y+1)^2) - 10*(x/5 - x^3 - y^5)*exp^(-x^2-y^2) -1/3*exp^(-(x+1)^2-y^2))\nD(peaks, \"x\")## -(3 * (1 - x) * (exp^(-x^2 - (y + 1)^2) * (log(exp) * (2 * x))) + \n##     3 * exp^(-x^2 - (y + 1)^2) + (10 * (1/5 - 3 * x^2) * exp^(-x^2 - \n##     y^2) - 10 * (x/5 - x^3 - y^5) * (exp^(-x^2 - y^2) * (log(exp) * \n##     (2 * x)))) - 1/3 * (exp^(-(x + 1)^2 - y^2) * (log(exp) * \n##     (2 * (x + 1)))))\nD(peaks, \"y\")## -(3 * (1 - x) * (exp^(-x^2 - (y + 1)^2) * (log(exp) * (2 * (y + \n##     1)))) - (10 * (x/5 - x^3 - y^5) * (exp^(-x^2 - y^2) * (log(exp) * \n##     (2 * y))) + 10 * (5 * y^4) * exp^(-x^2 - y^2)) - 1/3 * (exp^(-(x + \n##     1)^2 - y^2) * (log(exp) * (2 * y))))\nlibrary(Deriv)\nSimplify(D(peaks, \"x\"))## -(10 * ((0.2 - 3 * x^2)/exp^(x^2 + y^2)) + 3/exp^((1 + y)^2 + \n##     x^2) + log(exp) * (x * (6 * ((1 - x)/exp^((1 + y)^2 + x^2)) - \n##     20 * ((x * (0.2 - x^2) - y^5)/exp^(x^2 + y^2))) - 0.666666666666667 * \n##     ((1 + x)/exp^((1 + x)^2 + y^2))))\nSimplify(D(peaks, \"y\"))## -((6 * ((1 - x) * (1 + y)/exp^((1 + y)^2 + x^2)) - 0.666666666666667 * \n##     (y/exp^((1 + x)^2 + y^2))) * log(exp) - y * (20 * (log(exp) * \n##     (x * (0.2 - x^2) - y^5)/exp^(x^2 + y^2)) + 50 * (y^3/exp^(x^2 + \n##     y^2))))\nfn <- function(x) {\n  3 * (1 - x[1])^2 * exp(-x[1]^2 - (x[2] + 1)^2) -\n    10 * (x[1] / 5 - x[1]^3 - x[2]^5) * exp(-x[1]^2 - x[2]^2) -\n    1 / 3 * exp(-(x[1] + 1)^2 - x[2]^2)\n}\n# 梯度函数\ngr <- function(x) {\n  numDeriv::grad(fn, c(x[1], x[2]))\n}\n\noptim(par = c(-1.2, 1), fn = fn, gr = gr, method = \"BFGS\")## $par\n## [1] -1.3473958  0.2045192\n## \n## $value\n## [1] -3.049849\n## \n## $counts\n## function gradient \n##       28       10 \n## \n## $convergence\n## [1] 0\n## \n## $message\n## NULL\ndf <- expand.grid(\n  x = seq(-3, 3, length = 101),\n  y = seq(-3, 3, length = 101)\n)\n\ndf$fnxy = apply(df, 1, fn)\n\nlibrary(lattice)\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]),\n  ylab = expression(x[2]),\n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = -240, x = -70, y = 0)\n)"},{"path":"chap-numerical-optimization.html","id":"rosenbrock","chapter":"第 13 章 数值优化","heading":"13.4.2.3 Rosenbrock 函数","text":"香蕉函数 定义如下：\\[f(x_1,x_2) = 100 (x_2 -x_1^2)^2 + (1 - x_1)^2\\]\n图 13.6: 香蕉函数图像\n","code":"\nfn <- function(x) {\n  (100 * (x[2] - x[1]^2)^2 + (1 - x[1])^2)\n}\n\ndf <- expand.grid(\n  x = seq(-2.5, 2.5, length = 101),\n  y = seq(-2.5, 2.5, length = 101)\n)\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -70, y = 0)\n)\nr <- raster::rasterFromXYZ(df, crs = CRS(\"+proj=longlat +datum=WGS84\"))\nrasterVis::vectorplot(r, par.settings = RdBuTheme())\n# 梯度函数\ngr <- function(x) {\n  numDeriv::grad(fn, c(x[1], x[2])) \n}\noptim(par = c(-1.2, 1), fn = fn, gr = gr, method = \"BFGS\")## $par\n## [1] 1 1\n## \n## $value\n## [1] 9.595012e-18\n## \n## $counts\n## function gradient \n##      110       43 \n## \n## $convergence\n## [1] 0\n## \n## $message\n## NULL\nop <- OP(\n  objective = F_objective(fn, n = 2L, G = gr),\n  bounds = V_bound(ld = -3, ud = 3, nobj = 2L)\n)\nnlp <- ROI_solve(op, solver = \"nloptr.lbfgs\", start = c(-1.2, 1))\nnlp$objval## [1] 1.364878e-17\nnlp$solution## [1] 1 1"},{"path":"chap-numerical-optimization.html","id":"ackley","chapter":"第 13 章 数值优化","heading":"13.4.2.4 Ackley 函数","text":"Ackley 函数是一个非凸函数，有大量局部极小值点，获取全局极小值点是一个比较有挑战的事。它的 \\(n\\) 维形式如下：\n\\[f(\\mathbf{x}) = - \\mathrm{e}^{-b\\sqrt{\\frac{1}{n}\\sum_{=1}^{n}x_{}^{2}}} - \\mathrm{e}^{\\frac{1}{n}\\sum_{=1}^{n}\\cos(cx_i)} + + \\mathrm{e}\\]\n其中，\\(= 20, b = 0.2, c = 2\\pi\\)，对 \\(\\forall = 1,2,\\cdots, n\\)，\\(x_i \\[-10, 10]\\)，\\(f(\\mathbf{x})\\) 在 \\(\\mathbf{x}^{\\star} = (0,0,\\cdot,0)\\) 取得全局最小值 \\(f(\\mathbf{x}^{\\star}) = 0\\)，二维图像如图 13.7。\n图 13.7: 二维 Ackley 函数图像\n以 10 维的 Ackley 函数为例，先试一下普通的局部优化算法 — Nelder–Mead 算法，选择初值 \\((2,2,\\cdots,2)\\) ，看下效果，再与全局优化算法比较。可以说完全没有优化效果，已经陷入局部极小值。根据nloptr 全局优化算法的介绍，这里采用 directL 算法，因为是全局优化，不用选择初值。","code":"\nfn <- function(x, a = 20, b = 0.2, c = 2 * pi) {\n  mean1 <- mean(x^2)\n  mean2 <- mean(cos(c * x))\n  -a * exp(-b * sqrt(mean1)) - exp(mean2) + a + exp(1)\n}\n\ndf <- expand.grid(\n  x = seq(-10, 10, length.out = 201),\n  y = seq(-10, 10, length.out = 201)\n)\n\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -70, y = 0)\n)\nop <- OP(\n  objective = F_objective(fn, n = 10L),\n  bounds = V_bound(ld = -10, ud = 10, nobj = 10L)\n)\n\nnlp <- ROI_solve(op, solver = \"nloptr.neldermead\", start = rep(2, 10))\nnlp$solution##  [1] 2 2 2 2 2 2 2 2 2 2\nnlp$objval## [1] 6.593599\n# 调全局优化器\nnlp <- ROI_solve(op, solver = \"nloptr.directL\")\nnlp$solution##  [1] 0 0 0 0 0 0 0 0 0 0\nnlp$objval## [1] 4.440892e-16\nfn(x = c(2, 2))## [1] 6.593599\nfn(x = rep(2, 10))## [1] 6.593599"},{"path":"chap-numerical-optimization.html","id":"radistrigin","chapter":"第 13 章 数值优化","heading":"13.4.2.5 Radistrigin 函数","text":"这里，还有另外一个例子，Radistrigin 函数也是多摸函数\\[f(\\mathbf{x})= \\sum_{=1}^{n}\\big(x_i^2 - 10 \\cos(2\\pi x_i) + 10\\big)\\]\n图 13.8: Radistrigin 函数\n设置 10 维 的优化调全局优化器求解非凸优化问题","code":"\nfn <- function(x) {\n  sum(x^2 - 10 * cos(2 * pi * x) + 10)\n}\n\ndf <- expand.grid(\n  x = seq(-4, 4, length.out = 201),\n  y = seq(-4, 4, length.out = 201)\n)\n\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -65, y = 0)\n)\nop <- OP(\n  objective = F_objective(fn, n = 10L),\n  bounds = V_bound(ld = -50, ud = 50, nobj = 10L)\n)\nnlp <- ROI_solve(op, solver = \"nloptr.directL\")\nnlp$solution##  [1] 0 0 0 0 0 0 0 0 0 0\nnlp$objval## [1] 0"},{"path":"chap-numerical-optimization.html","id":"schaffer","chapter":"第 13 章 数值优化","heading":"13.4.2.6 Schaffer 函数","text":"\\[\nf(x_1,x_2) = 0.5 + \\frac{\\sin^2(x_1^2 - x_2^2) - 0.5}{ [1 + 0.001(x_1^2 + x_2^2)]^2}\n\\]\n在 \\(\\mathbf{x}^\\star = (0,0)\\) 处取得全局最小值 \\(f(\\mathbf{x}^\\star) = 0\\)\n图 13.9: Schaffer 函数\n\n图 13.10: Schaffer 函数\n","code":"\nfn <- function(x) {\n  0.5 + ((sin(x[1]^2 - x[2]^2))^2 - 0.5) / (1 + 0.001*(x[1]^2 + x[2]^2))^2\n}\n\ndf <- expand.grid(\n  x = seq(-50, 50, length = 201),\n  y = seq(-50, 50, length = 201)\n)\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -70, y = 0)\n)\ndf <- expand.grid(\n  x = seq(-2, 2, length = 101),\n  y = seq(-2, 2, length = 101)\n)\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -70, y = 0)\n)"},{"path":"chap-numerical-optimization.html","id":"holder","chapter":"第 13 章 数值优化","heading":"13.4.2.7 Hölder 函数","text":"Hölder 桌面函数\\[\nf(x_1,x_2) = - | \\sin(x_1)\\cos(x_2)\\exp\\big(| 1 - \\frac{\\sqrt{x_1^2 + x_2^2}}{\\pi}|\\big) |\n\\]在 \\((8.05502, 9.66459)\\)、\\((-8.05502, 9.66459)\\)、\\((8.05502, -9.66459)\\)、\\((-8.05502, -9.66459)\\) 同时取得最小值 \\(-19.2085\\)。\n图 13.11: Hölder 函数\n","code":"\nfn <- function(x) {\n  -abs(sin(x[1]) * cos(x[2])) * exp(abs(1 - sqrt(x[1]^2 + x[2]^2) / pi))\n}\n\ndf <- expand.grid(\n  x = seq(-10, 10, length = 101),\n  y = seq(-10, 10, length = 101)\n)\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -60, y = 0)\n)"},{"path":"chap-numerical-optimization.html","id":"trid","chapter":"第 13 章 数值优化","heading":"13.4.2.8 Trid 函数","text":"\\(n \\geq 2\\) 维 Trid 函数\\[\nf(x) = \\sum_{=1}^{n}(x_i - 1)^2 - \\sum_{=2}^{n}x_i x_{-1}\n\\]\n\\(\\forall = 1,2,\\cdots, n\\)，\\(f(x)\\) 在 \\(x_i = (n+1-)\\) 处取得全局极小值 \\(f(\\mathbf{x}^\\star)=-n(n+4)(n-1)/6\\)，取值区间 \\(x \\[-n^2, n^2], \\forall = 1,2,\\cdots,n\\)\n图 13.12: Trid 函数\n","code":"\nfn <- function(x) {\n  n <- length(x)\n  sum((x - 1)^2) - sum(x[-1] * x[-n])\n}\n\ndf <- expand.grid(\n  x = seq(-4, 4, length = 101),\n  y = seq(-4, 4, length = 101)\n)\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = -60, x = -70, y = 0)\n)"},{"path":"chap-numerical-optimization.html","id":"super-complex-function","chapter":"第 13 章 数值优化","heading":"13.4.2.9 超级复杂函数","text":"有如下复杂的目标函数\\[\\begin{equation*}\n\\begin{array}{l}\n  \\min_x \\quad \\cos(x_1)\\cos(x_2) - \\sum_{=1}^{5}\\Big( (-1)^\\cdot \\cdot 2 \\cdot \\exp\\big(-500 \\cdot ( (x_1 - \\cdot 2)^2 + (x_2 - \\cdot 2)^2 ) \\big) \\Big) \\\\\n    s.t. \\quad -50 \\leq x_1, x_2 \\leq 50\n\\end{array}\n\\end{equation*}\\]目标函数的图像见图 13.13，搜索区域 \\([-50, 50] \\times [-50, 50]\\) 内几乎没有变化的梯度，给寻优过程带来很大困难。\n图 13.13: 函数图像\n将区域 \\([0, 12] \\times [0, 12]\\) 的图像绘制出来，不难发现，有不少局部陷阱。\n图 13.14: 局部放大函数图像\n最优解在 \\((7.999982, 7.999982)\\) 取得，目标函数值为 -7.978832。面对如此复杂的函数，调用全局优化器实际上，还是陷入局部最优解。Lingo 18.0 启用全局优化求解器后，在 \\((x_1 = 7.999982, x_2 = 7.999982)\\) 取得最小值 -7.978832。而默认未启用全局优化求解器的情况下，在 \\((x_1 = 18.84956, x_2 = -40.84070)\\) 取得局部极小值 -1.000000。","code":"\nsubfun <- function(i, m) {\n  (-1)^i * i * 2 * exp(-500 * ((m[1] - i * 2)^2 + (m[2] - i * 2)^2))\n}\n\nfn <- function(x) {\n  cos(x[1]) * cos(x[2]) -\n    sum(mapply(FUN = subfun, i = 1:5, MoreArgs = list(m = x)))\n}\ndf <- expand.grid(\n  x = seq(-50, 50, length.out = 101),\n  y = seq(-50, 50, length.out = 101)\n)\n\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -65, y = 0)\n)\ndf <- expand.grid(\n  x = seq(0, 12, length.out = 201),\n  y = seq(0, 12, length.out = 201)\n)\n\ndf$fnxy = apply(df, 1, fn)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(x[1]), \n  ylab = expression(x[2]), \n  zlab = list(expression(italic(f) ~ group(\"(\", list(x[1], x[2]), \")\")), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -65, y = 0)\n)\nfn(x = c(7.999982, 7.999982))## [1] -7.978832\nop <- OP(\n  objective = F_objective(fn, n = 2L),\n  bounds = V_bound(ld = -50, ud = 50, nobj = 2L)\n)\nnlp <- ROI_solve(op, solver = \"nloptr.directL\")\nnlp$solution## [1]  0.00000 22.22222\nnlp$objval## [1] -0.9734211SETS:\nP/1..5/;\nEndsets\nMin=@cos(x1) * @cos(x2) - @Sum(P(j): (-1)^j * j * 2 * @exp(-500 * ((x1 - j * 2)^2 + (x2 - j * 2)^2)));\n@Bnd(-50, x1, 50);\n@Bnd(-50, x2, 50);"},{"path":"chap-numerical-optimization.html","id":"sec-nonlinear-constrained-optimization","chapter":"第 13 章 数值优化","heading":"13.4.3 多元非线性约束优化","text":"R 自带的函数 nlminb() 可求解无约束、箱式约束优化问题，constrOptim() 还可求解线性不等式约束优化，其中包括带线性约束的二次规划。optim() 提供一大类优化算法，且包含随机优化算法—模拟退火算法，可求解无约束、箱式约束优化问题。","code":""},{"path":"chap-numerical-optimization.html","id":"box-constrained-optimization","chapter":"第 13 章 数值优化","heading":"13.4.3.1 普通箱式约束","text":"有如下箱式约束优化问题，目标函数和香蕉函数有些相似。\\[\\begin{equation*}\n\\begin{array}{l}\n  \\min_x \\quad (x_1 - 1)^2 + 4\\sum_{=1}^{n -1}(x_{+1} -x_i^2)^2  \\\\\n    s.t. \\quad 2 \\leq x_1,x_2,\\cdots,x_n \\leq 4\n\\end{array}\n\\end{equation*}\\]\\(n\\) 维目标函数是非线性的，给定初值 \\((3, 3, \\cdots, 3)\\)，下面求解 25 维的箱式约束，nlminb() 出于历史兼容性的原因尚且存在，最优解的第24个分量没有在可行域的边界上。使用 constrOptim() 函数求解，默认求极小，需将箱式或线性不等式约束写成矩阵形式，即 \\(Ax \\geq b\\) 的形式，参数 ui 是 \\(k \\times n\\) 的约束矩阵 \\(\\)，ci 是右侧 \\(k\\) 维约束向量 \\(b\\)。以上面的优化问题为例，将箱式约束 \\(2 \\leq x_1,x_2 \\leq 4\\) 转化为矩阵形式，约束矩阵和向量分别为：\\[\n= \\begin{bmatrix}\n1  & 0  \\\\\n0  & 1 \\\\\n-1 & 0 \\\\\n0  & -1\n\\end{bmatrix}, \\quad\nb = (2, 2, -4, -4)\n\\]从求解的结果来看，convergence = 1 意味着迭代次数到达默认的极限 maxit = 500，结合 nlminb() 函数的求解结果来看，实际上还没有收敛。如果没有提供梯度，则必须用 Nelder-Mead 方法，下面增加迭代次数到 1000。还是没有收敛，可见 Nelder-Mead 方法在这个优化问题上收敛速度比较慢。下面考虑调用基于梯度的优化算法 — BFGS 方法。相比于 Nelder-Mead 方法，目标值 373 更大，可见已陷入局部最优解，下面通过 ROI 包，分别调用求解器 L-BFGS 和 directL，发现前者同样陷入局部最优解，而后者可以获得与 nlminb() 函数一致的结果。下面再与函数 optim() 提供的 L-BFGS-B 算法比较值得注意的是，当提供梯度信息的时候，虽然求解速度提升了，但是最优解变差了。","code":"\nfn <- function(x) {\n  n <- length(x)\n  sum(c(1, rep(4, n - 1)) * (x - c(1, x[-n])^2)^2)\n}\nnlminb(start = rep(3, 25), objective = fn, lower = rep(2, 25), upper = rep(4, 25))## $par\n##  [1] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000\n##  [9] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000\n## [17] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.109093\n## [25] 4.000000\n## \n## $objective\n## [1] 368.1059\n## \n## $convergence\n## [1] 0\n## \n## $iterations\n## [1] 6\n## \n## $evaluations\n## function gradient \n##       10      177 \n## \n## $message\n## [1] \"relative convergence (4)\"\nconstrOptim(\n  theta = rep(3, 25), # 初始值\n  f = fn, # 目标函数\n  method = \"Nelder-Mead\", # 没有提供梯度，则必须用 Nelder-Mead 方法\n  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),\n  ci = c(rep(2, 25), rep(-4, 25))\n)## $par\n##  [1] 2.006142 2.002260 2.003971 2.003967 2.004143 2.004255 2.001178 2.002990\n##  [9] 2.003883 2.006029 2.017345 2.009236 2.000949 2.007793 2.025831 2.007896\n## [17] 2.004514 2.004381 2.008771 2.015695 2.005803 2.009127 2.017988 2.257782\n## [25] 3.999846\n## \n## $value\n## [1] 378.4208\n## \n## $counts\n## function gradient \n##    12048       NA \n## \n## $convergence\n## [1] 1\n## \n## $message\n## NULL\n## \n## $outer.iterations\n## [1] 25\n## \n## $barrier.value\n## [1] -0.003278963\nconstrOptim(\n  theta = rep(3, 25), # 初始值\n  f = fn, # 目标函数\n  method = \"Nelder-Mead\", \n  control = list(maxit = 1000),\n  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),\n  ci = c(rep(2, 25), rep(-4, 25))\n)## $par\n##  [1] 2.000081 2.000142 2.001919 2.000584 2.000007 2.000003 2.001097 2.001600\n##  [9] 2.000207 2.000042 2.000250 2.000295 2.000580 2.002165 2.000453 2.000932\n## [17] 2.000456 2.000363 2.000418 2.000474 2.009483 2.001156 2.003173 2.241046\n## [25] 3.990754\n## \n## $value\n## [1] 370.8601\n## \n## $counts\n## function gradient \n##    18036       NA \n## \n## $convergence\n## [1] 1\n## \n## $message\n## NULL\n## \n## $outer.iterations\n## [1] 19\n## \n## $barrier.value\n## [1] -0.003366467\n# 输入 n 维向量，输出 n 维向量\ngr <- function(x) {\n  n <- length(x)\n  c(2 * (x[1] - 2), rep(0, n - 1))\n  +8 * c(0, x[-1] - x[-n]^2)\n  -16 * c(x[-n], 0) * c(x[-1] - x[-n]^2, 0)\n}\n\nconstrOptim(\n  theta = rep(3, 25), # 初始值\n  f = fn, # 目标函数\n  grad = gr,\n  method = \"BFGS\", \n  control = list(maxit = 1000),\n  ui = rbind(diag(rep(1, 25)), diag(rep(-1, 25))),\n  ci = c(rep(2, 25), rep(-4, 25))\n)## $par\n##  [1] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000\n##  [9] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000\n## [17] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000001\n## [25] 3.000000\n## \n## $value\n## [1] 373\n## \n## $counts\n## function gradient \n##     3721      464 \n## \n## $convergence\n## [1] 0\n## \n## $message\n## NULL\n## \n## $outer.iterations\n## [1] 3\n## \n## $barrier.value\n## [1] -0.003327104\n# 调用改进的 BFGS 算法\nop <- OP(\n  objective = F_objective(fn, n = 25L, G = gr),\n  bounds = V_bound(ld = 2, ud = 4, nobj = 25L)\n)\nnlp <- ROI_solve(op, solver = \"nloptr.lbfgs\", start = rep(3, 25))\nnlp$objval## [1] 373\nnlp$solution##  [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3\n# 调全局优化算法\nnlp <- ROI_solve(op, solver = \"nloptr.directL\")\nnlp$objval## [1] 368.1061\nnlp$solution##  [1] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000\n##  [9] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000\n## [17] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.109093\n## [25] 4.000000\noptim(\n  par = rep(3, 25), fn = fn, gr = NULL, method = \"L-BFGS-B\",\n  lower = rep(2, 25), upper = rep(4, 25)\n)## $par\n##  [1] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000\n##  [9] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000\n## [17] 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.000000 2.109093\n## [25] 4.000000\n## \n## $value\n## [1] 368.1059\n## \n## $counts\n## function gradient \n##        6        6 \n## \n## $convergence\n## [1] 0\n## \n## $message\n## [1] \"CONVERGENCE: REL_REDUCTION_OF_F <= FACTR*EPSMCH\"\noptim(\n  par = rep(3, 25), fn = fn, gr = gr, method = \"L-BFGS-B\",\n  lower = rep(2, 25), upper = rep(4, 25)\n)## $par\n##  [1] 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 3\n## \n## $value\n## [1] 373\n## \n## $counts\n## function gradient \n##        2        2 \n## \n## $convergence\n## [1] 0\n## \n## $message\n## [1] \"CONVERGENCE: NORM OF PROJECTED GRADIENT <= PGTOL\""},{"path":"chap-numerical-optimization.html","id":"nonlinear-strictly-inequality-constraints","chapter":"第 13 章 数值优化","heading":"13.4.3.2 非线性严格不等式约束","text":"第一个例子，目标函数是非线性的，约束条件也是非线性的，非线性不等式约束不包含等号。\\[\\begin{equation*}\n\\begin{array}{l}\n  \\min_x \\quad (x_1 + 3x_2 + x_3)^2 + 4(x_1 - x_2)^2 \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n     x_1 + x_2 + x_3 = 1 \\\\\n     6 x_2 + 4 x_3 - x_1^3 > 3 \\\\\n     x_1, x_2, x_3 > 0\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]调用 alabama 包的求解器ans 是 constrOptim.nl() 返回的一个 list， convergence = 0 表示迭代成功收敛，value 表示目标函数在迭代终止时的取直，par 表示满足约束条件，成功收敛的情况下，目标函数的参数值，counts 表示迭代过程中目标函数及其梯度计算的次数。等式和不等式约束的雅可比矩阵必须以 matrix 数据类型存储，而不能以 vector 类型存储。要注意和后面 ROI 包的调用形式区别。实际上，可以用 ROI 调用 alabama 求解器的方式，这种方式可以简化目标函数梯度和约束条件的表示通过 ROI 调用 alabama 求解器","code":"\n# 目标函数\nfn <- function(x) (x[1] + 3 * x[2] + x[3])^2 + 4 * (x[1] - x[2])^2\n# 目标函数的梯度\ngr <- function(x) {\n  c(\n    2 * (x[1] + 3 * x[2] + x[3]) + 8 * (x[1] - x[2]), # 对 x[1] 求偏导\n    6 * (x[1] + 3 * x[2] + x[3]) - 8 * (x[1] - x[2]), # 对 x[2] 求偏导\n    2 * (x[1] + 3 * x[2] + x[3]) # 对 x[3] 求偏导\n  )\n}\n# 等式约束\nheq <- function(x) {\n  x[1] + x[2] + x[3] - 1 \n}\n# 等式约束的雅可比矩阵\n# 这里只有一个等式约束，所以雅可比矩阵行数为 1\nheq.jac <- function(x) {\n  matrix(c(1, 1, 1), ncol = 3, byrow = TRUE)\n}\n# 不等式约束\n# 要求必须是严格不等式，不能带等号，方向是 x > 0 \nhin <- function(x) {\n  c(6 * x[2] + 4 * x[3] - x[1]^3 - 3, x[1], x[2], x[3])\n}\n# 不等式约束的雅可比矩阵\n# 其实是有 4 个不等式约束，3 个目标变量约束，雅可比矩阵行数是 4\nhin.jac <- function(x) {\n  matrix(c(\n    -3 * x[1]^2, 6, 4,\n    1, 0, 0,\n    0, 1, 0,\n    0, 0, 1\n  ), ncol = 3, byrow = TRUE)\n}\nset.seed(12)\n# 初始值\np0 <- runif(3)\n# 求目标函数的极小值\nans <- alabama::constrOptim.nl(\n  par = p0,\n  # 目标函数\n  fn = fn,\n  gr = gr,\n  # 等式约束\n  heq = heq,\n  heq.jac = heq.jac,\n  # 不等式约束\n  hin = hin,\n  hin.jac = hin.jac,\n  # 不显示迭代过程\n  control.outer = list(trace = FALSE)\n)\nans## $par\n## [1] 7.390292e-04 4.497160e-12 9.992610e-01\n## \n## $value\n## [1] 1.000002\n## \n## $counts\n## function gradient \n##     1230      163 \n## \n## $convergence\n## [1] 0\n## \n## $message\n## NULL\n## \n## $hessian\n##           [,1]      [,2]      [,3]\n## [1,] 120517098 120517087 120517091\n## [2,] 120517087 120517115 120517095\n## [3,] 120517091 120517095 120517091\n## \n## $outer.iterations\n## [1] 13\n## \n## $lambda\n## [1] 4.481599\n## \n## $sigma\n## [1] 120517089\n## \n## $barrier.value\n## [1] 0.003472071\n## \n## $K\n## [1] 4.269112e-08\n# 不提供梯度函数，照样可以求解\nans <- alabama::constrOptim.nl(par = p0, fn = fn, heq = heq, hin = hin)\n# 目标函数\nfn <- function(x) (x[1] + 3 * x[2] + x[3])^2 + 4 * (x[1] - x[2])^2\n# 目标函数的梯度\ngr <- function(x) {\n  c(\n    2 * (x[1] + 3 * x[2] + x[3]) + 8 * (x[1] - x[2]),\n    6 * (x[1] + 3 * x[2] + x[3]) - 8 * (x[1] - x[2]),\n    2 * (x[1] + 3 * x[2] + x[3])\n  )\n}\nheq <- function(x) {\n  x[1] + x[2] + x[3]\n}\nheq.jac <- function(x) {\n  c(1, 1, 1)\n}\nhin <- function(x) {\n  6 * x[2] + 4 * x[3] - x[1]^3\n}\nhin.jac <- function(x) {\n   c(-3 * x[1]^2, 6, 4)\n}\nset.seed(2020)\n# 初始值\np0 <- runif(3)\n# 定义目标规划\nop <- OP(\n  objective = F_objective(F = fn, n = 3L, G = gr), # 4 个目标变量\n  constraints = F_constraint(\n    F = list(heq = heq, hin = hin),\n    dir = c(\"==\", \">\"),\n    rhs = c(1, 3),\n    # 等式和不等式约束的雅可比\n    J = list(heq.jac = heq.jac, hin.jac = hin.jac)\n  ),\n  bounds = V_bound(ld = 0, ud = +Inf, nobj = 3L),\n  maximum = FALSE # 求最小\n)\nnlp <- ROI_solve(op, solver = \"alabama\", start = p0)\nnlp$solution## [1] 1.674812e-06 9.994336e-08 9.999982e-01\nnlp$objval## [1] 1"},{"path":"chap-numerical-optimization.html","id":"nonlinear-and-box-constrained","chapter":"第 13 章 数值优化","heading":"13.4.3.3 非线性和箱式约束","text":"与上面的例子不同，下面这个例子的不等式约束包含等号，还有箱式约束，优化问题来源于Ipopt 官网，提供的初始值为 \\(x_0 = (1,5,5,1)\\)，最优解为 \\(x_{\\star} = (1.00000000,4.74299963,3.82114998,1.37940829)\\)。优化问题的具体内容如下：\\[\\begin{equation*}\n\\begin{array}{l}\n  \\min_x \\quad x_1 x_4 (x_1 + x_2 + x_3) + x_3 \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n     x_1^2 + x_2^2 + x_3^2 + x_4^2 = 40 \\\\\n     x_1 x_2 x_3 x_4 \\geq 25 \\\\\n     1 \\leq x_1, x_2, x_3, x_4 \\leq 5\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]考虑用 ROI 调 nloptr 实现，看结果是否和例子一致，nloptr 支持不等式约束包含等号，支持箱式约束。求解一般的非线性约束问题，求解器 nloptr.mma / nloptr.cobyla 仅支持非线性不等式约束，不支持等式约束，而 nlminb 只支持等式约束，因此，下面分别调用 nloptr.auglag、nloptr.slsqp 和 nloptr.isres 来求解上述优化问题。可以看出，nloptr 提供的优化能力可以覆盖Ipopt 求解器，推荐使用 nloptr.slsqp 求解器。","code":"\n# 一个 4 维的目标函数\nfn <- function(x) {\n  x[1] * x[4] * (x[1] + x[2] + x[3]) + x[3]\n}\n# 目标函数的梯度\ngr <- function(x) {\n  c(\n    x[4] * (2 * x[1] + x[2] + x[3]), x[1] * x[4],\n    x[1] * x[4] + 1, x[1] * (x[1] + x[2] + x[3])\n  )\n}\n# 等式约束\nheq <- function(x) {\n  sum(x^2)\n}\n# 等式约束的雅可比\nheq.jac <- function(x) {\n  2 * c(x[1], x[2], x[3], x[4])\n}\n# 不等式约束\nhin <- function(x) {\n  prod(x)\n}\n# 不等式约束的雅可比\nhin.jac <- function(x) {\n  c(prod(x[-1]), prod(x[-2]), prod(x[-3]), prod(x[-4]))\n}\n# 定义目标规划\nop <- OP(\n  objective = F_objective(F = fn, n = 4L, G = gr), # 4 个目标变量\n  constraints = F_constraint(\n    F = list(heq = heq, hin = hin),\n    dir = c(\"==\", \">=\"),\n    rhs = c(40, 25),\n    # 等式和不等式约束的雅可比\n    J = list(heq.jac = heq.jac, hin.jac = hin.jac)\n  ),\n  bounds = V_bound(ld = 1, ud = 5, nobj = 4L),\n  maximum = FALSE # 求最小\n)\n# 目标函数初始值\nfn(c(1, 5, 5, 1))## [1] 16\n# 目标函数最优值\nfn(c(1.00000000, 4.74299963, 3.82114998, 1.37940829))## [1] 17.01402\nnlp <- ROI_solve(op, solver = \"nloptr.auglag\", start = c(1, 5, 5, 1))\nnlp$solution## [1] 1.000000 4.743174 3.820922 1.379440\nnlp$objval## [1] 17.01402\nnlp <- ROI_solve(op, solver = \"nloptr.slsqp\", start = c(1, 5, 5, 1))\nnlp$solution## [1] 1.000000 4.742996 3.821155 1.379408\nnlp$objval## [1] 17.01402\nnlp <- ROI_solve(op, solver = \"nloptr.isres\", start = c(1, 5, 5, 1))\nnlp$solution## [1] 1.119455 4.492583 4.113057 1.284566\nnlp$objval## [1] 18.09788"},{"path":"chap-numerical-optimization.html","id":"nonlinear-mixed-integer-constrained","chapter":"第 13 章 数值优化","heading":"13.4.3.4 非线性混合整数约束","text":"\\[\\begin{equation*}\n\\begin{array}{l}\n  \\max_x \\quad 1.5(x_1 - \\sin(x_1 - x_2))^2 + 0.5x_2^2 + x_3^2 - x_1 x_2 - 2x_1 + x_2 x_3 \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n     -20 < x_1 < 20 \\\\\n     -20 < x_2 < 20 \\\\\n     -10 < x_3 < 10 \\\\\n     x_1, x_2 \\\\mathbb{R}, \\quad x_3 \\\\mathbb{Z}\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]目前 ROI 还解不了目标函数在 \\((4.49712, 9.147501, -4)\\) 取得最小值 -86.72165","code":"\nfn <- function(x) {\n  1.5 * (x[1] - sin(x[1] - x[2]))^2 + 0.5 * x[2]^2 + x[3]^2\n  -x[1] * x[2] - 2 * x[1] + x[2] * x[3]\n}\ngr <- function(x) {\n  c(\n    3 * (x[1] - sin(x[1] - x[2])) * (1 - cos(x[1] - x[2])) - x[2] - 2,\n    3 * (x[1] - sin(x[1] - x[2])) * cos(x[1] - x[2]) - x[2] - x[1] + x[3],\n    2 * x[3] + x[2]\n  )\n}\n# 初始值\np0 <- c(2.1, 5.1, 5)\n# 定义目标规划\nop <- OP(\n  objective = F_objective(F = fn, n = 3L, G = gr), # 3 个目标变量\n  types = c(\"C\", \"C\", \"I\"), # 目标变量的类型\n  bounds = V_bound(lb = c(-20, -20, -10), ub = c(20, 20, 10), nobj = 3L),\n  maximum = FALSE # 求最小\n)\nnlp <- ROI_solve(op, solver = \"auto\", start = p0)\nnlp$solution\nfn(x = c(4.49712, 9.147501, -4))## [1] -86.72165"},{"path":"chap-numerical-optimization.html","id":"complex-object-function","chapter":"第 13 章 数值优化","heading":"13.4.3.5 含复杂目标函数","text":"下面这个目标函数比较复杂，约束条件也是非线性的\\[\\begin{equation*}\n\\begin{array}{l}\n  \\max_x \\quad \\frac{(\\sin(2\\pi x_1))^3 \\sin(2\\pi x_2)}{x_1^3 (x_1 + x_2)} \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n     x_1^2 - x_2 + 1 \\leq 0 \\\\\n     1 - x_1 + (x_2 - 4)^2 \\geq 0 \\\\\n     0 \\leq x_1, x_2 \\leq 10\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]下面再给一个来自 Octave 优化文档 的示例，该优化问题包含多个非线性的等式约束。\\[\\begin{equation*}\n\\begin{array}{l}\n  \\min_x \\quad \\mathrm{e}^{\\prod_{=1}^{5} x_i} - \\frac{1}{2}(x_1^3 + x_2^3 + 1)^2 \\\\\n    s.t.\\left\\{ \n    \\begin{array}{l}\n     \\sum_{=1}^{5}x_i^2 - 10 = 0 \\\\\n     x_2 x_3 - 5x_4 x_5 = 0 \\\\\n     x_1^3 + x_2^3 + 1 = 0\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]调用 SQP（序列二次规划） 求解器计算结果和 Octave 的示例一致。","code":"\n# 目标函数\nfn <- function(x) (sin(2*pi*x[1]))^3 * sin(2*pi*x[2])/(x[1]^3*(x[1] + x[2]))\n# 目标函数的梯度\ngr <- function(x) {\n  numDeriv::grad(fn, c(x[1], x[2]))\n}\n\nhin <- function(x) {\n  c(\n    x[1]^2 - x[2] + 1,\n    1 - x[1] + (x[2] - 4)^2\n  )\n}\n\nhin.jac <- function(x) {\n  matrix(c(\n    2 * x[1], -1,\n    -1, 2 * x[2]\n  ),\n  ncol = 2, byrow = TRUE\n  )\n}\n\n# 初始值\np0 <- c(2, 5)\n# 定义目标规划\nop <- OP(\n  objective = F_objective(F = fn, n = 2L, G = gr), # 2 个目标变量\n  constraints = F_constraint(\n    F = list(hin = hin),\n    dir = c(\"<=\", \"<=\"),\n    rhs = c(0, 0),\n    # 不等式约束的雅可比\n    J = list(hin.jac = hin.jac)\n  ),\n  bounds = V_bound(ld = 0, ud = 10, nobj = 2L),\n  maximum = TRUE # 求最大\n)\nnlp <- ROI_solve(op, solver = \"nloptr.isres\", start = p0)\nnlp$solution## [1] 1.227962 4.245367\nnlp$objval## [1] 0.09582504\n# 一个 5 维的目标函数\nfn <- function(x) {\n  exp(prod(x)) - 0.5 * (x[1]^3 + x[2]^3 + 1)^2\n}\n# 目标函数的梯度\ngr <- function(x) {\n  c(\n    exp(prod(x))*prod(x[-1]) - 3*(x[1]^3 + x[2]^3 + 1)*x[1]^2,\n    exp(prod(x))*prod(x[-2]) - 3*(x[1]^3 + x[2]^3 + 1)*x[2]^2,\n    exp(prod(x))*prod(x[-3]), \n    exp(prod(x))*prod(x[-4]),\n    exp(prod(x))*prod(x[-5])\n  )\n}\n# 等式约束\nheq <- function(x) {\n  c(\n    sum(x^2) - 10,\n    x[2] * x[3] - 5 * x[4] * x[5],\n    x[1]^3 + x[2]^3 + 1\n  )\n}\n# 等式约束的雅可比\nheq.jac <- function(x) {\n  matrix(c(2 * x[1], 2 * x[2], 2 * x[3], 2 * x[4], 2 * x[5],\n    0, x[3], x[2], -5 * x[5], -5 * x[4],\n    3 * x[1]^2, 3 * x[2]^2, 0, 0, 0),\n    ncol = 5, byrow = TRUE\n  )\n}\n# 定义目标规划\nop <- OP(\n  objective = F_objective(F = fn, n = 5L, G = gr), # 5 个目标变量\n  constraints = F_constraint(\n    F = list(heq = heq),\n    dir = \"==\",\n    rhs = 0,\n    # 等式的雅可比\n    J = list(heq.jac = heq.jac)\n  ),\n  bounds = V_bound(ld = -Inf, ud = Inf, nobj = 5L),\n  maximum = FALSE # 求最小\n)\nnlp <- ROI_solve(op, solver = \"nloptr.slsqp\", start = c(-1.8, 1.7, 1.9, -0.8,-0.8))\nnlp$solution## [1] -1.7171435  1.5957096  1.8272458 -0.7636431 -0.7636431"},{"path":"chap-numerical-optimization.html","id":"complex-constrained-function","chapter":"第 13 章 数值优化","heading":"13.4.3.6 含复杂约束条件","text":"\\[\\begin{equation*}\n\\begin{array}{l}\n  \\min_x \\quad \\exp(\\sin(50\\cdot x)) + \\sin(60\\cdot \\exp(y)) + \\sin(70\\cdot\\sin(x)) \\\\\n         \\qquad + \\sin(\\sin(80\\cdot y)) - \\sin(10\\cdot (x +y)) + \\frac{(x^2 + y^2)^{\\sin(y)}}{4} \\\\\n    s.t. \\quad \\left\\{ \n    \\begin{array}{l}\n     x - \\big((\\cos(y))^x - x\\big)^y = 0 \\\\\n    -50 \\leq x_1,x_2 \\leq 50\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]Lingo 代码如下：启用全局优化求解器，求解 14 分钟，在 \\((0.08256372, 24.56510)\\) 取得极小值 -2.863497。不启用全局优化器就没法解，Lingo 会报错，找不到最优解，勉强找到一个可行解 \\((0.06082750, 44.12793)\\)，目标值为 -1.29816。nloptr.auglag 无法求解此优化问题调 nloptr.isres 求解器，每次执行都会得到不同的局部最优解比如下面三组","code":"Min = @exp(@sin(50 * x)) + @sin(60 * @exp(y)) + @sin(70 * @sin(x)) \n      + @sin(@sin(80 * y)) - @sin(10 * (x + y)) + (x^2 + y^2)^@sin(y) / 4;\n\nx - (( @cos(y) )^x - x)^y = 0;\n\n@bnd(-50, x, 50);\n@bnd(-50, y, 50);\nfn <- function(x) {\n  exp(sin(50 * x[1])) + sin(60 * exp(x[2])) +\n    sin(70 * sin(x[1])) + sin(sin(80 * x[2])) -\n    sin(10 * (x[1] + x[2])) + (x[1]^2 + x[2]^2)^(sin(x[2])) / 4\n}\ngr <- function(x){\n  numDeriv::grad(fn, c(x[1], x[2]))\n}\nheq <- function(x){\n  x[1] - ( (cos(x[2]))^x[1] - x[1] )^x[2]\n}\nheq.jac <- function(x){\n  numDeriv::grad(heq, c(x[1], x[2]))\n}\n\nfn(x = c(0.06082750, 44.12793))## [1] -1.29816\nfn(x = c(1, 0))## [1] 1.966877\nheq(x = c(0.06082750, 44.12793))## [1] 1.923673e-08\nheq(x = c(1, 0))## [1] 0\n# 定义目标规划\nop <- OP(\n  objective = F_objective(F = fn, n = 2L, G = gr), # 2 个目标变量\n  constraints = F_constraint(\n    F = list(heq = heq),\n    dir = \"==\",\n    rhs = 0,\n    J = list(heq.jac = heq.jac)\n  ),\n  bounds = V_bound(ld = -50, ud = 50, nobj = 2L),\n  maximum = FALSE # 求最小\n)\nnlp <- ROI_solve(op, solver = \"nloptr.auglag\", start = c(1, 0))\nnlp$solution\nnlp <- ROI_solve(op, solver = \"nloptr.isres\", start = c(1, 0))\nnlp$solution## [1]  3.860027 -2.453287\nnlp$objval## [1] -3.193337\nfn(x = c(40.95941, 41.52914))## [1] -1.025926\nheq(x = c(40.95941, 41.52914))## [1] NaN\nfn(x = c(-21.88091, 28.96994))## [1] -1.467513\nheq(x = c(-21.88091, 28.96994))## [1] NaN\nfn(x = c(-49.921967437, 4.8499336803))## [1] -3.466596\nheq(x = c(-49.921967437, 4.8499336803))## [1] -8.515447e+208"},{"path":"chap-numerical-optimization.html","id":"sec-nonlinear-equations","chapter":"第 13 章 数值优化","heading":"13.5 非线性方程","text":"","code":""},{"path":"chap-numerical-optimization.html","id":"subsec-equation","chapter":"第 13 章 数值优化","heading":"13.5.1 一元非线性方程","text":"牛顿-拉弗森方法","code":"\nlibrary(rootSolve)"},{"path":"chap-numerical-optimization.html","id":"subsec-equations","chapter":"第 13 章 数值优化","heading":"13.5.2 非线性方程组","text":"二项混合泊松分布的参数最大似然估计计算最大似然处的黑塞矩阵以及参数的标准差从不同初始值出发尝试寻找全局最大值，实际找的是一系列局部最大值用一个具体的参数估计问题，求极大似然点，混合正态分布\n隐函数方程组\n求解非线性方程组 [37]","code":"\nlibrary(BB)\npoissmix.loglik <- function(p, y) {\n  # Log-likelihood for a binary Poisson mixture distribution\n  i <- 0:(length(y) - 1)\n  \n  loglik <- y * log(p[1] * exp(-p[2]) * p[2]^i / exp(lgamma(i + 1)) +\n    (1 - p[1]) * exp(-p[3]) * p[3]^i / exp(lgamma(i + 1)))\n\n  sum(loglik)\n}\n# Data from Hasselblad (JASA 1969)\n# 介绍实际应用场景\npoissmix.dat <- data.frame(death = 0:9, \n                           freq = c(162, 267, 271, 185, 111, 61, 27, 8, 3, 1))\nlo <- c(0, 0, 0) # lower limits for parameters\nhi <- c(1, Inf, Inf) # upper limits for parameters\np0 <- runif(3, c(0.2, 1, 1), c(0.8, 5, 8)) \n# a randomly generated vector of length 3\ny <- c(162, 267, 271, 185, 111, 61, 27, 8, 3, 1)\n\nans1 <- spg(\n  par = p0, fn = poissmix.loglik, y = y, lower = lo, upper = hi,\n  control = list(maximize = TRUE, trace = FALSE)\n)\nans2 <- BBoptim(\n  par = p0, fn = poissmix.loglik, y = y,\n  lower = lo, upper = hi, control = list(maximize = TRUE)\n)## iter:  0  f-value:  -2136.431  pgrad:  236.9752 \n## iter:  10  f-value:  -1995.89  pgrad:  2.961353 \n## iter:  20  f-value:  -2041.139  pgrad:  2.57697 \n## iter:  30  f-value:  -1989.974  pgrad:  0.4742151 \n## iter:  40  f-value:  -1989.949  pgrad:  0.2614752 \n## iter:  50  f-value:  -1989.946  pgrad:  0.01959506 \n## iter:  60  f-value:  -1989.946  pgrad:  0.002494289 \n##   Successful convergence.\nans2## $par\n## [1] 0.3598829 1.2560906 2.6634011\n## \n## $value\n## [1] -1989.946\n## \n## $gradient\n## [1] 0.0001000444\n## \n## $fn.reduction\n## [1] -146.4848\n## \n## $iter\n## [1] 68\n## \n## $feval\n## [1] 170\n## \n## $convergence\n## [1] 0\n## \n## $message\n## [1] \"Successful convergence\"\n## \n## $cpar\n## method      M \n##      2     50\nhess <- numDeriv::hessian(x = ans2$par, func = poissmix.loglik, y = y)\n# Note that we have to supplied data vector 'y'\nhess##           [,1]      [,2]      [,3]\n## [1,] -907.1105  270.2287  341.2543\n## [2,]  270.2287 -113.4794  -61.6819\n## [3,]  341.2543  -61.6819 -192.7822\nse <- sqrt(diag(solve(-hess)))\nse## [1] 0.1946836 0.3500308 0.2504769\n# 3 randomly generated starting values\np0 <- matrix(runif(30, c(0.2, 1, 1), c(0.8, 8, 8)), 10, 3, byrow = TRUE)\nans <- multiStart(\n  par = p0, fn = poissmix.loglik, action = \"optimize\",\n  y = y, lower = lo, upper = hi, control = list(maximize = TRUE)\n)## Parameter set :  1 ... \n## iter:  0  f-value:  -2076.377  pgrad:  266.5811 \n## iter:  10  f-value:  -1991.788  pgrad:  3.394882 \n## iter:  20  f-value:  -1990.932  pgrad:  8.266675 \n## iter:  30  f-value:  -1989.958  pgrad:  0.2441652 \n## iter:  40  f-value:  -1989.946  pgrad:  0.001411991 \n##   Successful convergence.\n## Parameter set :  2 ... \n## iter:  0  f-value:  -3999.343  pgrad:  6.350898 \n## iter:  10  f-value:  -2015.457  pgrad:  2.400803 \n##   Successful convergence.\n## Parameter set :  3 ... \n## iter:  0  f-value:  -2526.385  pgrad:  3.959104 \n## iter:  10  f-value:  -1997.785  pgrad:  4.651176 \n## iter:  20  f-value:  -2041.124  pgrad:  130.6335 \n## iter:  30  f-value:  -1989.979  pgrad:  0.4133676 \n## iter:  40  f-value:  -1989.953  pgrad:  0.2001525 \n## iter:  50  f-value:  -1989.946  pgrad:  0.02953584 \n##   Successful convergence.\n## Parameter set :  4 ... \n## iter:  0  f-value:  -4036.966  pgrad:  7.725057 \n## iter:  10  f-value:  -1993.146  pgrad:  3.356279 \n## iter:  20  f-value:  -1992.445  pgrad:  3.162911 \n## iter:  30  f-value:  -1999.964  pgrad:  3.124857 \n## iter:  40  f-value:  -1990.201  pgrad:  0.9762675 \n## iter:  50  f-value:  -1989.962  pgrad:  0.3950169 \n## iter:  60  f-value:  -1989.946  pgrad:  0.0507498 \n## iter:  70  f-value:  -1989.946  pgrad:  0.0001978151 \n##   Successful convergence.\n## Parameter set :  5 ... \n## iter:  0  f-value:  -2048.809  pgrad:  2.862445 \n## iter:  10  f-value:  -1992.344  pgrad:  2.68979 \n## iter:  20  f-value:  -1990.604  pgrad:  7.2791 \n## iter:  30  f-value:  -1989.978  pgrad:  0.3772993 \n## iter:  40  f-value:  -1989.946  pgrad:  0.004172307 \n## iter:  50  f-value:  -1989.946  pgrad:  0.004260983 \n##   Successful convergence.\n## Parameter set :  6 ... \n## iter:  0  f-value:  -4777.283  pgrad:  7.596832 \n## iter:  10  f-value:  -1991.838  pgrad:  11.02078 \n## iter:  20  f-value:  -1990.272  pgrad:  0.5307333 \n## iter:  30  f-value:  -1989.963  pgrad:  2.230793 \n## iter:  40  f-value:  -1989.946  pgrad:  0.008421921 \n## iter:  50  f-value:  -1989.946  pgrad:  0.0001841727 \n##   Successful convergence.\n## Parameter set :  7 ... \n## iter:  0  f-value:  -2019.928  pgrad:  3.485709 \n## iter:  10  f-value:  -1990.626  pgrad:  1.833378 \n## iter:  20  f-value:  -1989.999  pgrad:  1.098717 \n## iter:  30  f-value:  -1989.947  pgrad:  0.3092782 \n## iter:  40  f-value:  -1989.946  pgrad:  0.007039489 \n##   Successful convergence.\n## Parameter set :  8 ... \n## iter:  0  f-value:  -2764.625  pgrad:  4.891128 \n## iter:  10  f-value:  -2001.398  pgrad:  2.273737e-06 \n##   Successful convergence.\n## Parameter set :  9 ... \n## iter:  0  f-value:  -2167.165  pgrad:  195.5499 \n## iter:  10  f-value:  -2001.54  pgrad:  2.194864 \n## iter:  20  f-value:  -2000.825  pgrad:  0.6559458 \n## iter:  30  f-value:  -1992.777  pgrad:  7.064828 \n## iter:  40  f-value:  -1991.747  pgrad:  3.357115 \n## iter:  50  f-value:  -1989.983  pgrad:  2.772795 \n## iter:  60  f-value:  -1989.946  pgrad:  0.03392643 \n## iter:  70  f-value:  -1989.946  pgrad:  0.0003728928 \n##   Successful convergence.\n## Parameter set :  10 ... \n## iter:  0  f-value:  -2100.94  pgrad:  317.5313 \n## iter:  10  f-value:  -1991.327  pgrad:  2.7843 \n## iter:  20  f-value:  -1990.415  pgrad:  1.435174 \n## iter:  30  f-value:  -1990.046  pgrad:  3.248585 \n## iter:  40  f-value:  -1989.946  pgrad:  0.06813025 \n## iter:  50  f-value:  -1989.946  pgrad:  0.001450644 \n##   Successful convergence.\n# selecting only converged solutions\npmat <- round(cbind(ans$fvalue[ans$conv], ans$par[ans$conv, ]), 4)\ndimnames(pmat) <- list(NULL, c(\"fvalue\", \"parameter 1\", \"parameter 2\", \"parameter 3\"))\npmat[!duplicated(pmat), ]##         fvalue parameter 1 parameter 2 parameter 3\n## [1,] -1989.946      0.6401      2.6634      1.2561\n## [2,] -1997.263      0.4922      2.4559      1.8567\n## [3,] -1989.946      0.3599      1.2561      2.6634\n## [4,] -2000.039      0.7931      2.0681      2.4778\n## [5,] -1989.946      0.3599      1.2560      2.6634"},{"path":"chap-numerical-optimization.html","id":"sec-multi-objective-optimization","chapter":"第 13 章 数值优化","heading":"13.6 多目标规划","text":"多目标规划的基本想法是将多目标问题转化为单目标问题，常见方法有理想点法、线性加权法、非劣解集法、极大极小法。理想点法是先在给定约束条件下分别求解单个目标的最优值，构造新的单目标函数。线性加权法是给每个目标函数赋予权重系数，各个权重系数之和等于1。非劣解集法是先求解其中一个单目标函数的最优值，然后将其设为等式约束，将其最优值从最小值开始递增，然后求解另一个目标函数的最小值。极大极小法是采用标准的简面体爬山法和通用全局优化法求解多目标优化问题。R 环境中，GPareto 主要用来求解多目标规划问题。试验设计和过程优化与R语言 的 约束优化 章节，优化和解方程。另外，《Search Methodologies: Introductory Tutorials Optimization Decision Support Techniques》[38] 多目标优化方法\\[\\begin{equation*}\n\\begin{array}{l}\n  \\min_x \\left\\{\n      \\begin{array}{l}  \n        f_1(x) = 0.5x_1 + 0.6x_2 + 0.7 \\exp(\\frac{x_1 + x_3}{10}) \\\\\n        f_2(x) = (x_1 - 2x_2)^2 + (2x_2 - 3x_3)^2 + (5x_3 -x_1)^2\n      \\end{array} \\right. \\\\\n    s.t. \\quad x_1 \\[10, 80], x_2 \\[20, 90], x_3 \\[15, 100]\n\\end{array}\n\\end{equation*}\\]","code":"\nlibrary(DiceKriging)\nlibrary(emoa)\nlibrary(GPareto)\nlibrary(DiceDesign)\nlibrary(Ternary)\nTernaryPlot(\n  atip = \"Top\", btip = \"Bottom\", ctip = \"Right\", \n  axis.col = \"red\", col = rgb(0.8, 0.8, 0.8)\n)\nHorizontalGrid(grid.lines = 2, grid.col = \"blue\", grid.lty = 1)"},{"path":"chap-numerical-optimization.html","id":"sec-classic-optimization","chapter":"第 13 章 数值优化","heading":"13.7 经典优化问题","text":"旅行商问题、背包问题、指派问题、选址问题、网络流量问题规划快递员送餐的路线：从快递员出发地到各个取餐地，再到顾客家里，如何规划路线使得每个顾客下单到拿到餐的时间间隔小于 50 分钟，完成送餐，快递员的总时间最少？","code":""},{"path":"chap-numerical-optimization.html","id":"sec-regression-optimization","chapter":"第 13 章 数值优化","heading":"13.8 回归与优化","text":"简单线性回归nlsr是否能给大家提供一些思路？Lasso [39]Least Angle Regression [40]为了解决Lasso的有偏估计问题，自适应 Lasso、松弛 Lasso\nSCAD (Smoothly Clipped Absolute Deviation)[41]\nMCP (Minimax Concave Penalty)[42]由于缺少高效的求解算法，Lasso 在高维小样本特征选择研究中没有广泛流行，最小角回归(Least Angle Regression, LAR)算法 [40] 的出现有力促进了Lasso在高维小样本数据中的应用bestsubset 最优子集回归经典的普通最小二乘、广义最小二乘、岭回归、逐步回归、Lasso 回归、最优子集回归都可转化为优化问题，一般形式如下\\[\n\\underbrace{\\hat{\\theta}_{\\lambda_n}}_{\\text{待估参数}} \\\\arg \\min_{\\theta \\\\Omega} \\left\\{ \\underbrace{\\mathcal{L}(\\theta;Z_{1}^{n})}_{\\text{损失函数}} + \\lambda_n \\underbrace{\\mathcal{R}(\\theta)}_{\\text{正则化项}} \\right\\}.\n\\]下面尝试以 nloptr 包的优化器来展示求解过程，并与 Base R、glmnet 和 MASS 实现的回归模型比较。\\[\n\\arg \\min_{\\beta,\\lambda} ~~ \\frac{1}{2} || \\mathbf{y} - \\mathbf{X} \\beta ||_2^2 +  \\lambda ||\\beta||_1\n\\]\n其中，\\(X \\\\mathbb{R}^{m\\times n}\\)， \\(y \\\\mathbb{R}^m\\)，\\(\\beta \\\\mathbb{R}^n\\)， \\(0 < \\lambda \\\\mathbb{R}\\)\\[y = X\\beta + \\epsilon\\]\\(\\hat{\\beta} = (X^{\\top}X)^{-1}X^{\\top}y, \\quad \\hat{Y} = X(X^{\\top}X)^{-1}X^{\\top}y\\)QR 分解 \\(X_{n\\times p} = Q_{n\\times p} R_{p\\times p}\\)，\\(n > p\\)，\\(Q^{\\top}Q = \\)，\\(R\\) 是上三角矩阵，\\(\\hat{Y} = X(X^{\\top}X)^{-1}X^{\\top}y = QQ^{\\top}y\\)若 \\(= X^{\\top}X\\) 是正定矩阵，则 \\(= LL^{\\top}\\)，\\(L\\) 是下三角矩阵","code":"\nset.seed(123)\nn <- 200\np <- 50\nx <- matrix(rnorm(n * p), n)\ny <- rnorm(n)\nlm(y ~ x + 0)\n# y 的估计\n# 教科书版\nfit_base = function(x, y) {\n  x %*% solve(t(x) %*% x) %*% t(x) %*% y\n}\n# 先向量计算，然后矩阵计算\nfit_vector = function(x, y) {\n  x %*% (solve(t(x) %*% x) %*% (t(x) %*% y))\n}\n# X'X 是对称的，防止求逆\nfit_inv = function(x, y) {\n  x %*% solve(crossprod(x), crossprod(x, y))\n}\nfit_qr <- function(x, y) {\n  decomp <- qr(x)\n  qr.qy(decomp, qr.qty(decomp, y))\n}\nlm.fit(x, y)\nfit_chol <- function(x, y) {\n  decomp <- chol(crossprod(x))\n  lxy <- backsolve(decomp, crossprod(x, y), transpose = TRUE)\n  b <- backsolve(decomp, lxy)\n  x %*% b\n}\n## Using C/C++\nsystem.time(RcppEigen::fastLmPure(x, y, method = 1)) ## QR\nsystem.time(RcppEigen::fastLmPure(x, y, method = 2)) ## Cholesky\nsystem.time(RcppArmadillo::fastLmPure(x, y, method = 1)) ## QR\nsystem.time(RcppArmadillo::fastLmPure(x, y, method = 2)) ## Cholesky"},{"path":"chap-numerical-optimization.html","id":"sec-log-likelihood","chapter":"第 13 章 数值优化","heading":"13.9 对数似然","text":"随机变量 X 服从参数为 \\(\\lambda > 0\\) 的指数分布，密度函数 \\(p(x)\\) 为\\[\\begin{equation*}\n\\begin{array}{l}\n p(x) = \\left\\{ \n    \\begin{array}{l}\n    \\lambda\\mathrm{e}^{-\\lambda x},  x \\geq 0\\\\\n    0, \\quad x < 0\n    \\end{array} \\right.\n\\end{array}\n\\end{equation*}\\]其中，\\(\\lambda > 0\\)，下面给定一系列模拟样本观察值 \\(x_1, x_2, \\cdots, x_n\\)，估计参数 \\(\\lambda\\)。对数似然函数 \\(\\ell(\\lambda) = \\log \\prod_{=1}^{n} f(x_i) = n \\log \\lambda - \\lambda \\sum_{=1}^{n}x_i\\)。解此方程即可得到 \\(\\lambda\\) 的极大似然估计 \\(\\lambda_{mle} = \\frac{1}{\\bar{X}}\\)，极大值 \\(\\ell(\\lambda_{mle}) = - n(1 + \\log \\bar{X})\\)。根据上述样本，计算样本均值 \\((\\mu - 1.5*\\sigma/\\sqrt{n}, \\mu + 1.5*\\sigma/\\sqrt{n})\\) 和方差 \\((0.8\\sigma, 1.5\\sigma)\\)。\n已知正态分布 \\(f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}\\mathrm{e}^{- \\frac{(x - \\mu)^2}{2\\sigma^2}}\\) 的对数似然形式 \\(\\ell(\\mu,\\sigma^2) = \\log \\prod_{=1}^{n} f(x_i) = \\sum_{=1}^{n}\\log f(x_i)\\)。正态分布的密度函数的对数可用 dnorm(..., log = TRUE) 计算。生成服从指数分布的样本，计算样本的均值和方差，依据均值和方差构造区间，然后将区间网格化，在此网格上绘制正态分布的对数似然函数。绕那么大一个圈子，其实就是绘制正态分布的对数似然函数。\n图 13.15: 正态分布参数的负对数似然函数\n","code":"\nset.seed(2021)\nn <- 20 # 随机数的个数\nx <- rexp(n, rate = 5) # 服从指数分布的随机数\nm <- 40 # 网格数\n\nmu <- seq(\n  mean(x) - 1.5 * sd(x) / sqrt(n),\n  mean(x) + 1.5 * sd(x) / sqrt(n),\n  length.out = m\n)\nsigma <- seq(0.8 * sd(x), 1.5 * sd(x), length.out = m)\ndf <- expand.grid(x = mu, y = sigma)\n# 正态分布的对数似然\nloglik <- function(b, x0) -sum(dnorm(x0, b[1], b[2], log = TRUE))\n\ndf$fnxy = apply(df, 1, loglik, x0 = x)\n\nwireframe(\n  data = df, fnxy ~ x * y,\n  shade = TRUE, drape = FALSE,\n  xlab = expression(mu), \n  ylab = expression(sigma), \n  zlab = list(expression(-loglik(mu, sigma)), rot = 90),\n  scales = list(arrows = FALSE, col = \"black\"),\n  par.settings = list(axis.line = list(col = \"transparent\")),\n  screen = list(z = 120, x = -70, y = 0)\n)"},{"path":"chap-numerical-optimization.html","id":"sec-non-linear-tseries","chapter":"第 13 章 数值优化","heading":"13.10 微分方程","text":"ode45 求解偏微分方程pracma 实现了 ode23, ode23s, ode45 等几个自适应的 Runge-Kutta 求解器，deSolve 包求解 ODE（常微分方程）, DAE（微分代数方程）, DDE（延迟微分方程，包含刚性和非刚性方程）和 PDE（偏微分方程），bvpSolve包求解 DAE/ODE 方程的边值问题。ReacTran [43] 可将偏微分方程转为常微分方程组，解决反应运输问题，在笛卡尔、极坐标、圆柱形和球形网格上离散偏微分方程。 sundials 提供一系列非线性方程、常微分方程、微分代数方程求解器，Satyaprakash Nayak 开发了相应的 sundialr 包。","code":""},{"path":"chap-numerical-optimization.html","id":"subsec-ordinary-differential-equations","chapter":"第 13 章 数值优化","heading":"13.10.1 常微分方程","text":"洛伦兹系统是一个常微分方程组，系统参数的默认值为 \\((\\sigma = 10, \\rho = 28, \\beta = 8/3)\\)，初值为 \\((-13, -14, 47)\\)。\\[\\begin{equation*}\n\\left\\{ \n  \\begin{array}{l}\n    \\frac{\\partial x}{\\partial t} = \\sigma (y - x) \\\\\n    \\frac{\\partial y}{\\partial t} = x(\\rho -z) - y \\\\\n    \\frac{\\partial x}{\\partial t} = xy - \\beta z\n  \\end{array} \\right.\n\\end{equation*}\\]调用 scatterplot3d 绘制三维曲线图，如图13.16 所示\n图 13.16: 洛伦兹曲线\n","code":"\nlibrary(deSolve)\n# 参数\npars <- c(a = -8 / 3, b = -10, c = 28)\n# 初值\nstate <- c(X = 1, Y = 1, Z = 1)\n# 时间间隔\ntimes <- seq(0, 100, by = 0.01)\n# 定义方程组\nlorenz_fun <- function(t, state, parameters) {\n  with(as.list(c(state, parameters)), {\n    dX <- a * X + Y * Z\n    dY <- b * (Y - Z)\n    dZ <- -X * Y + c * Y - Z\n    list(c(dX, dY, dZ))\n  })\n}\nout <- ode(\n  y = state, times = times,\n  func = lorenz_fun, parms = pars\n)\nlibrary(scatterplot3d)\n\nscatterplot3d(\n  x = out[, \"X\"], y = out[, \"Y\"], z = out[, \"Z\"],\n  col.axis = \"black\", type = \"l\", color = \"gray\",\n  xlab = expression(x), ylab = expression(y), zlab = expression(z),\n  col.grid = \"gray\", main = \"Lorenz\"\n)"},{"path":"chap-numerical-optimization.html","id":"subsec-partial-differential-equations","chapter":"第 13 章 数值优化","heading":"13.10.2 偏微分方程","text":"ReacTran 的几个关键函数介绍一维热传导方程\\[\\begin{equation*}\n\\left\\{ \n  \\begin{array}{l}\n    \\frac{\\partial y}{\\partial t} = D \\frac{\\partial^2 y}{\\partial x^2}\n  \\end{array} \\right.\n\\end{equation*}\\]参数 \\(D = 0.01\\)，边界条件 \\(y_{t,x=0} = 0, y_{t, x = 1} = 1\\)，初始条件 \\(y_{t=0,x} = \\sin(\\pi x)\\)。\n图 13.17: 一维热传导方程的数值解热力图\n二维拉普拉斯方程\\[\\begin{equation*}\n\\left\\{ \n  \\begin{array}{l}\n    \\frac{\\partial^2 u}{\\partial^2 x} + \\frac{\\partial^2 u}{\\partial y^2} = 0\n  \\end{array} \\right.\n\\end{equation*}\\]边界条件\\[\\begin{equation*}\n\\left\\{ \n  \\begin{array}{l}\n    u_{x=0,y} = u_{x=1,y} = 0 \\\\\n    \\frac{\\partial u_{x, y=0}}{\\partial y} = 0 \\\\\n    \\frac{\\partial u_{x,y=1}}{\\partial y} = \\pi\\sinh(\\pi)\\sin(\\pi x)\n  \\end{array} \\right.\n\\end{equation*}\\]它有解析解\\[\nu(x,y) = \\sin(\\pi x)\\cosh(\\pi y)\n\\]其中 \\(x \\[0,1], y\\[0,1]\\)\n图 13.18: 解析解的二维图像\n\n图 13.19: 解析解的三维透视图像\n求解 PDE","code":"\nlibrary(ReacTran)\n\nN <- 100\nxgrid <- setup.grid.1D(x.up = 0, x.down = 1, N = N)\nx <- xgrid$x.mid\nD.coeff <- 0.01\nDiffusion <- function(t, Y, parms) {\n  tran <- tran.1D(\n    C = Y, C.up = 0, C.down = 1,\n    D = D.coeff, dx = xgrid\n  )\n  list(\n    dY = tran$dC, \n    flux.up = tran$flux.up,\n    flux.down = tran$flux.down\n  )\n}\nyini <- sin(pi * x)\ntimes <- seq(from = 0, to = 5, by = 0.01)\nout <- ode.1D(\n  y = yini, times = times, func = Diffusion,\n  parms = NULL, dimens = N\n)\nimage(out,\n  grid = xgrid$x.mid, xlab = \"times\",\n  ylab = \"Distance\", main = \"PDE\", add.contour = TRUE\n)\nfn <- function(x, y) {\n  sin(pi * x) * cosh(pi * y)\n}\nx <- seq(0, 1, length.out = 101)\ny <- seq(0, 1, length.out = 101)\nz <- outer(x, y, fn)\nimage(z, col = terrain.colors(20))\ncontour(z, method = \"flattest\", add = TRUE, lty = 1)\npersp(z, \n  theta = 30, phi = 20, \n  r = 50, d = 0.1, expand = 0.5, ltheta = 90, lphi = 180,\n  shade = 0.1, ticktype = \"detailed\", nticks = 5, box = TRUE,\n  col = drapecol(z, col = terrain.colors(20)),\n  border = \"transparent\",\n  xlab = \"X\", ylab = \"Y\", zlab = \"Z\", \n  main = \"\"\n)\ndx <- 0.2\nxgrid <- setup.grid.1D(-100, 100, dx.1 = dx)\nx <- xgrid$x.mid\nN <- xgrid$N\n\nuini <- exp(-0.05 * x^2)\nvini <- rep(0, N)\nyini <- c(uini, vini)\ntimes <- seq(from = 0, to = 50, by = 1)\n\nwave <- function(t, y, parms) {\n  u1 <- y[1:N]\n  u2 <- y[-(1:N)]\n  du1 <- u2\n  du2 <- tran.1D(C = u1, C.up = 0, C.down = 0, D = 1, dx = xgrid)$dC\n  return(list(c(du1, du2)))\n}\n\nout <- ode.1D(\n  func = wave, y = yini, times = times, parms = NULL,\n  nspec = 2, method = \"ode45\", dimens = N, names = c(\"u\", \"v\")\n)"},{"path":"chap-numerical-optimization.html","id":"subsec-delay-differential-equations","chapter":"第 13 章 数值优化","heading":"13.10.3 延迟微分方程","text":"PBSddesolve [44]\nPBSmodelling\nPBSmappingnlmeODE 通过微分方程整合用于混合效应模型的 odesolve 和 nlme 包。","code":"\nlibrary(PBSddesolve)    # DAE 延迟微分方程"},{"path":"chap-numerical-optimization.html","id":"subsec-stochastic-differential-equations","chapter":"第 13 章 数值优化","heading":"13.10.4 随机微分方程","text":"Sim.DiffProc随机微分方程入门：基于 R 语言的模拟和推断nlmixr 借助 RxODE 求解基于常微分方程的非线性混合效应模型","code":"\n# library(Sim.DiffProc)"},{"path":"chap-numerical-optimization.html","id":"sec-numerical-optimization-session","chapter":"第 13 章 数值优化","heading":"13.11 运行环境","text":"","code":"\nsessionInfo()## R version 4.2.0 (2022-04-22)\n## Platform: x86_64-pc-linux-gnu (64-bit)\n## Running under: Ubuntu 20.04.4 LTS\n## \n## Matrix products: default\n## BLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.9.0\n## LAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.9.0\n## \n## locale:\n##  [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n##  [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n##  [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n##  [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n##  [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n## [11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n## \n## attached base packages:\n## [1] stats     graphics  grDevices utils     datasets  methods   base     \n## \n## other attached packages:\n##  [1] Deriv_4.1.3               quadprog_1.5-8           \n##  [3] kableExtra_1.3.4          tibble_3.1.7             \n##  [5] nlme_3.1-157              PBSddesolve_1.12.6       \n##  [7] ReacTran_1.4.3.1          shape_1.4.6              \n##  [9] scatterplot3d_0.3-41      deSolve_1.32             \n## [11] BB_2019.10-1              rootSolve_1.8.2.3        \n## [13] kernlab_0.9-30            lattice_0.20-45          \n## [15] ROI.plugin.scs_1.1-1      ROI.plugin.quadprog_1.0-0\n## [17] ROI.plugin.lpsolve_1.0-1  ROI.plugin.nloptr_1.0-0  \n## [19] ROI.plugin.alabama_1.0-0  ROI_1.0-0                \n## [21] lpSolve_5.6.15           \n## \n## loaded via a namespace (and not attached):\n##  [1] svglite_2.1.0           sysfonts_0.8.8          digest_0.6.29          \n##  [4] utf8_1.2.2              slam_0.1-50             R6_2.5.1               \n##  [7] alabama_2022.4-1        evaluate_0.15           highr_0.9              \n## [10] httr_1.4.3              pillar_1.7.0            rlang_1.0.2            \n## [13] curl_4.3.2              rstudioapi_0.13         nloptr_2.0.1           \n## [16] jquerylib_0.1.4         rmarkdown_2.14          webshot_0.5.3          \n## [19] stringr_1.4.0           munsell_0.5.0           compiler_4.2.0         \n## [22] numDeriv_2016.8-1.1     xfun_0.31               systemfonts_1.0.4      \n## [25] pkgconfig_2.0.3         htmltools_0.5.2         downlit_0.4.0          \n## [28] bookdown_0.26           viridisLite_0.4.0       fansi_1.0.3            \n## [31] crayon_1.5.1            grid_4.2.0              jsonlite_1.8.0         \n## [34] lifecycle_1.0.1         registry_0.5-1          magrittr_2.0.3         \n## [37] scales_1.2.0            cli_3.3.0               stringi_1.7.6          \n## [40] cachem_1.0.6            fs_1.5.2                xml2_1.3.3             \n## [43] bslib_0.3.1             ellipsis_0.3.2          vctrs_0.4.1            \n## [46] lpSolveAPI_5.5.2.0-17.7 tools_4.2.0             glue_1.6.2             \n## [49] fastmap_1.1.0           yaml_2.3.5              colorspace_2.0-3       \n## [52] scs_3.0-0               rvest_1.0.2             memoise_2.0.1          \n## [55] knitr_1.39              sass_0.4.1"},{"path":"chap-linux-command-bash.html","id":"chap-linux-command-bash","chapter":"附录 A 命令行操作","heading":"附录 A 命令行操作","text":"Bash 文件查找、查看（内容、大小）、移动（重命名）、删除、创建、修改权限Linux 命令行工具是非常强大的，命令行中的数据科学 https://www.datascienceatthecommandline.com/，Linux 命令行 https://github.com/jaywcjlove/linux-commandoptparse、docopt 、littler 包提供了很多便捷的命令行工具，sys， fs 在 R 中运行操作系统命令如表A.1所示，总结了 R 和 Shell 命令的等价表示，下面以 list.files() 和 ls 为例，介绍其等价的内容表 .1:  R 和 Shell 命令的等价表示 52","code":""},{"path":"chap-linux-command-bash.html","id":"sec-ls","chapter":"附录 A 命令行操作","heading":"A.1 查看文件","text":"ls/mkdir/mv/du查看文件","code":"```bash\nls -a\n```\n\n列出目录下所有文件\n\n```bash\nls -1 \n```\n\n一行显示一个文件或文件夹\n\n```bash\nls -l \n```\n\n按从 aA-zZ 的顺序列出所有文件以及所属权限\n\n```bash\nls -rl \n```\n\n相比于 `ls -l` 文件是逆序排列\n\n```bash\nls -lh\n```\n\n列出文件或文件夹（不包含子文件夹）的大小 \n\n```bash\nls -ld \n```\n\n列出当前目录本身，而不是其所包含的内容"},{"path":"chap-linux-command-bash.html","id":"sec-mkdir","chapter":"附录 A 命令行操作","heading":"A.2 创建文件夹","text":"","code":"```bash\nmkdir images\n```\n\n创建文件用 `touch` 如 `touch .Rprofile` \n\n```bash\n# 删除文件夹及子文件夹，递归删除\nrm -rf images/\n# 删除文件\nrm .Rprofile\n```"},{"path":"chap-linux-command-bash.html","id":"sec-mv","chapter":"附录 A 命令行操作","heading":"A.3 移动文件","text":"","code":"在当前目录下\n\n```bash\n# 移动文件夹 images 下的所有文件到 figures 文件夹下\nmv images/* figures/\n# images 文件夹移动到 figures 文件夹下\nmv images/ figures/\n# 移动特定的文件\nmv images/*.png figures/\n```\n\n同一目录下有两个文件 `R-3.5.1.tar.gz` 未下载完整 和 `R-3.5.1.tar.gz.1` 完全下载\n\n```bash\n# 删除 R-3.5.1.tar.gz\nrm R-3.5.1.tar.gz\n# 重命名 R-3.5.1.tar.gz.1 \nmv R-3.5.1.tar.gz.1  R-3.5.1.tar.gz\n```"},{"path":"chap-linux-command-bash.html","id":"sec-du","chapter":"附录 A 命令行操作","heading":"A.4 查看文件大小","text":"","code":"当前目录下各文件夹的大小， `-h` 表示人类（相对于机器来说）可读的方式显示，如 Kb、Mb、Gb，`-d` 表示目录深度 `du --human-readable --max-depth=1 ./`\n\n```bash\ndu -h -d 1 ./\n```\n\n```bash\n# 对当前目录下的文件/夹 按大小排序\ndu -sh * | sort -nr\n```"},{"path":"chap-linux-command-bash.html","id":"sec-shell","chapter":"附录 A 命令行操作","heading":"A.5 终端模拟器","text":"oh--zsh 是 Z Shell 扩展，开发在 Github 上 https://github.com/ohmyzsh/ohmyzsh。zsh 相比于 bash， 在语法高亮、自动补全等方面有优势RStudio 集成的终端支持 Zsh，操作路径 Tools -> Global Options -> Terminal， 见图 .1图 .1:  RStudio IDE 集成的 Zsh 终端模拟器","code":"sudo dnf install -y zsh\nsh -c \"$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\""},{"path":"chap-linux-command-bash.html","id":"sec-tar","chapter":"附录 A 命令行操作","heading":"A.6 压缩和解压缩","text":"最常见的压缩文件格式有 .tar、.tar.gz、.tar.bz2、.zip 和 .rar，分别对应于 Tar https://www.gnu.org/software/tar/、 Gzip https://www.gzip.org/ 、 Bzip2 https://www.bzip.org/ 、 UnZip/Zip http://www.info-zip.org 和 WinRAR https://www.rarlab.com/。 Tar 提供了基本的打包和解包工具，Gzip 和 Bzip2 在 Tar 打包的基础上提供了压缩功能， UnZip/Zip 是兼容 Windows 原生压缩/解压缩功能的程序，WinRAR 是广泛流行于 Windows 系统的压缩/解压缩收费软件，除了 WinRAR，其它都是免费甚至开源软件。 下面以 .tar.gz 和.tar.bz2 两种格式的压缩文件为例，介绍文件压缩和解压缩的操作，其它文件格式的操作类似53。WinRAR https://www.rarlab.com/ 是收费的压缩和解压缩工具，也支持 Linux 和 macOS 系统，鉴于它是收费软件，这里就不多展开介绍了，详情请见官网。 \n解压不带 tar 的 .gz 文件，比如 tex.eps.gz 解压后变成 tex.eps","code":"sudo dnf install -y tar gzip zip unzip \n# 将目录 ~/tmp 压缩成文件 filename.tar.gz\ntar -czf **.tar.gz ~/tmp\n# 将文件 filename.tar.gz 解压到目录 ~/tmp\ntar -xzf **.tar.gz -C ~/tmpsudo dnf install -y bzip2\n# 将目录 ~/tmp 压缩成文件 filename.tar.bz2\ntar -cjf filename.tar.bz2 ~/tmp\n# 将文件 filename.tar.bz2 解压到目录 ~/tmp\ntar -xjf filename.tar.bz2 -C ~/tmpgzip filename.gz -d ~/tmp"},{"path":"chap-linux-command-bash.html","id":"repo-install","chapter":"附录 A 命令行操作","heading":"A.7 从仓库安装 R","text":"","code":""},{"path":"chap-linux-command-bash.html","id":"ubuntu","chapter":"附录 A 命令行操作","heading":"A.7.1 Ubuntu","text":"安装 openssh zsh 和 Git只考虑最新的 Ubuntu 18.04 因为本书写成的时候，该版本应该已经大规模使用了，默认版本的安装和之前版本的安装就不再展示了。安装最新版 R-3.5.x，无论安装哪个版本，都要先导入密钥Ubuntu 14.04.5 提供的默认版本 R 3.0.2，安装 R 3.5.x 系列之前的版本，如 R 3.4.4\nsudo apt-add-repository -y \"deb http://cran.rstudio.com/bin/linux/ubuntu `lsb_release -cs`/\"\nsudo apt-get install r-base-dev\n添加完仓库后，都需要更新源sudo apt-get update，安装 R 3.5.x 系列最新版\nsudo apt-add-repository -y \"deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu trusty-cran35/\"Ubuntu 14.04.5 提供的默认版本 R 3.0.2，安装 R 3.5.x 系列之前的版本，如 R 3.4.4添加完仓库后，都需要更新源sudo apt-get update，安装 R 3.5.x 系列最新版Ubuntu 16.04.5 提供的默认版本 R 3.4.4，这是 R 3.4.x 系列的最新版，安装目前最新的 R 3.5.x 版本需要\nsudo apt-add-repository -y \"deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu xenial-cran35/\"Ubuntu 16.04.5 提供的默认版本 R 3.4.4，这是 R 3.4.x 系列的最新版，安装目前最新的 R 3.5.x 版本需要Ubuntu 18.04.1 提供的默认版本 R 3.4.4，安装目前的最新版本需要\nsudo apt-add-repository -y \"deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu bionic-cran35/\"\n接下来安装 R，详细安装指导见 CRAN 官网。\nsudo apt-get install -y r-base-dev\nMichael Rutter 维护了编译好的二进制版本 https://launchpad.net/~marutter，比如 rstan 包可以通过安装 r-cran-rstan 完成\n# R packages Ubuntu LTS. Based CRAN Task Views.\nsudo add-apt-repository -y ppa:marutter/c2d4u3.5\nsudo apt-get install r-cran-rstanUbuntu 18.04.1 提供的默认版本 R 3.4.4，安装目前的最新版本需要接下来安装 R，详细安装指导见 CRAN 官网。Michael Rutter 维护了编译好的二进制版本 https://launchpad.net/~marutter，比如 rstan 包可以通过安装 r-cran-rstan 完成","code":"sudo apt-get install zsh openssh-server\nsudo add-apt-repository -y ppa:git-core/ppa\nsudo apt update && sudo apt install git\nsh -c \"$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)\"sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv E084DAB9sudo apt-add-repository -y \"deb http://cran.rstudio.com/bin/linux/ubuntu `lsb_release -cs`/\"\nsudo apt-get install r-base-devsudo apt-add-repository -y \"deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu trusty-cran35/\"sudo apt-add-repository -y \"deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu xenial-cran35/\"sudo apt-add-repository -y \"deb https://mirrors.tuna.tsinghua.edu.cn/CRAN/bin/linux/ubuntu bionic-cran35/\"sudo apt-get install -y r-base-dev# R packages for Ubuntu LTS. Based on CRAN Task Views.\nsudo add-apt-repository -y ppa:marutter/c2d4u3.5\nsudo apt-get install r-cran-rstan"},{"path":"chap-linux-command-bash.html","id":"centos","chapter":"附录 A 命令行操作","heading":"A.7.2 CentOS","text":"同样适用于 Fedora安装指导54","code":""},{"path":"chap-linux-command-bash.html","id":"source-install","chapter":"附录 A 命令行操作","heading":"A.8 源码安装","text":"","code":""},{"path":"chap-linux-command-bash.html","id":"ubuntu-1","chapter":"附录 A 命令行操作","heading":"A.8.1 Ubuntu","text":"首先启用源码仓库，否则执行 sudo apt-get build-dep r-base 会报如下错误安装编译 R 所需的系统依赖编译安装 R自定义编译选项","code":"E: You must put some 'source' URIs in your sources.listsudo sed -i -- 's/#deb-src/deb-src/g' /etc/apt/sources.list && sudo sed -i -- 's/# deb-src/deb-src/g' /etc/apt/sources.list\nsudo apt-get updatesudo apt-get build-dep r-base-dev./configure\nmake && make install ./configure --help"},{"path":"chap-linux-command-bash.html","id":"centos-1","chapter":"附录 A 命令行操作","heading":"A.8.2 CentOS","text":"基于 CentOS 7 和 GCC 4.8.5，参考 R-admin 手册下载源码包\n最新发布的稳定版\ncurl -fLo ./R-latest.tar.gz https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-latest.tar.gz\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n 10 28.7M   10 3232k    0     0   107k      0  0:04:34  0:00:30  0:04:04  118k下载源码包最新发布的稳定版安装依赖\nsudo yum install -y yum-utils epel-release && sudo yum-builddep R-devel\nsudo dnf update && sudo dnf builddep R-devel # Fedora 30安装依赖解压配置\nmkdir R-latest && tar -xzf ./R-latest.tar.gz -C ./R-latest && cd R-3.5.2\n\n./configure --enable-R-shlib --enable-byte-compiled-packages \\\n  --enable-BLAS-shlib --enable-memory-profiling\nR now configured x86_64-pc-linux-gnu\n\n  Source directory:          .\n  Installation directory:    /usr/local\n\n  C compiler:                gcc -std=gnu99  -g -O2\n  Fortran 77 compiler:       gfortran  -g -O2\n\n  Default C++ compiler:      g++   -g -O2\n  C++98 compiler:            g++ -std=gnu++98 -g -O2\n  C++11 compiler:            g++ -std=gnu++11 -g -O2\n  C++14 compiler:\n  C++17 compiler:\n  Fortran 90/95 compiler:    gfortran -g -O2\n  Obj-C compiler:            gcc -g -O2 -fobjc-exceptions\n\n  Interfaces supported:      X11, tcltk\n  External libraries:        readline, curl\n  Additional capabilities:   PNG, JPEG, TIFF, NLS, cairo, ICU\n  Options enabled:           shared R library, shared BLAS, R profiling, memory profiling\n\n  Capabilities skipped:\n  Options enabled:\n\n  Recommended packages:      yes解压配置编译安装\nmake -j 2 \nsudo make install编译安装BLAS 加持（可选）\nBLAS 对于加快矩阵计算至关重要，编译 R 带 BLAS 支持，添加 OpenBLAS 支持 ---blas=\"-lopenblas\" 或 ATLAS 支持 ---blas=\"-L/usr/lib64/atlas -lsatlas\"\nsudo yum install -y openblas openblas-threads openblas-openmp \n\n./configure --enable-R-shlib --enable-byte-compiled-packages \\\n  --enable-BLAS-shlib --enable-memory-profiling \\\n  ---blas=\"-lopenblas\"\nR now configured x86_64-pc-linux-gnu\n\nSource directory:          .\nInstallation directory:    /usr/local\n\nC compiler:                gcc -std=gnu99  -g -O2\nFortran 77 compiler:       gfortran  -g -O2\n\nDefault C++ compiler:      g++   -g -O2\nC++98 compiler:            g++ -std=gnu++98 -g -O2\nC++11 compiler:            g++ -std=gnu++11 -g -O2\nC++14 compiler:\nC++17 compiler:\nFortran 90/95 compiler:    gfortran -g -O2\nObj-C compiler:            gcc -g -O2 -fobjc-exceptions\n\nInterfaces supported:      X11, tcltk\nExternal libraries:        readline, **BLAS(OpenBLAS)**, curl\nAdditional capabilities:   PNG, JPEG, TIFF, NLS, cairo, ICU\nOptions enabled:           shared R library, shared BLAS, R profiling, memory profiling\n\nCapabilities skipped:\nOptions enabled:\n\nRecommended packages:      yes\n配置成功的标志，如 OpenBLAS\nchecking dgemm_ -lopenblas... yes\nchecking whether double complex BLAS can used... yes\nchecking whether BLAS complete... yes\nATLAS 加持\nsudo yum install -y atlas\n./configure --enable-R-shlib --enable-byte-compiled-packages \\\n  --enable-BLAS-shlib --enable-memory-profiling \\\n  ---blas=\"-L/usr/lib64/atlas -lsatlas\"\nR now configured x86_64-pc-linux-gnu\n\nSource directory:          .\nInstallation directory:    /usr/local\n\nC compiler:                gcc -std=gnu99  -g -O2\nFortran 77 compiler:       gfortran  -g -O2\n\nDefault C++ compiler:      g++   -g -O2\nC++98 compiler:            g++ -std=gnu++98 -g -O2\nC++11 compiler:            g++ -std=gnu++11 -g -O2\nC++14 compiler:\nC++17 compiler:\nFortran 90/95 compiler:    gfortran -g -O2\nObj-C compiler:            gcc -g -O2 -fobjc-exceptions\n\nInterfaces supported:      X11, tcltk\nExternal libraries:        readline, **BLAS(generic)**, curl\nAdditional capabilities:   PNG, JPEG, TIFF, NLS, cairo, ICU\nOptions enabled:           shared R library, shared BLAS, R profiling, memory profiling\n\nCapabilities skipped:\nOptions enabled:\n\nRecommended packages:      yes\nATLAS 配置成功\nchecking dgemm_ -L/usr/lib64/atlas -lsatlas... yes\nchecking whether double complex BLAS can used... yes\nchecking whether BLAS complete... yesBLAS 加持（可选）BLAS 对于加快矩阵计算至关重要，编译 R 带 BLAS 支持，添加 OpenBLAS 支持 ---blas=\"-lopenblas\" 或 ATLAS 支持 ---blas=\"-L/usr/lib64/atlas -lsatlas\"配置成功的标志，如 OpenBLASATLAS 加持ATLAS 配置成功后续步骤同上","code":"curl -fLo ./R-latest.tar.gz https://mirrors.tuna.tsinghua.edu.cn/CRAN/src/base/R-latest.tar.gz  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n 10 28.7M   10 3232k    0     0   107k      0  0:04:34  0:00:30  0:04:04  118ksudo yum install -y yum-utils epel-release && sudo yum-builddep R-devel\nsudo dnf update && sudo dnf builddep R-devel # Fedora 30mkdir R-latest && tar -xzf ./R-latest.tar.gz -C ./R-latest && cd R-3.5.2\n\n./configure --enable-R-shlib --enable-byte-compiled-packages \\\n  --enable-BLAS-shlib --enable-memory-profilingR is now configured for x86_64-pc-linux-gnu\n\n  Source directory:          .\n  Installation directory:    /usr/local\n\n  C compiler:                gcc -std=gnu99  -g -O2\n  Fortran 77 compiler:       gfortran  -g -O2\n\n  Default C++ compiler:      g++   -g -O2\n  C++98 compiler:            g++ -std=gnu++98 -g -O2\n  C++11 compiler:            g++ -std=gnu++11 -g -O2\n  C++14 compiler:\n  C++17 compiler:\n  Fortran 90/95 compiler:    gfortran -g -O2\n  Obj-C compiler:            gcc -g -O2 -fobjc-exceptions\n\n  Interfaces supported:      X11, tcltk\n  External libraries:        readline, curl\n  Additional capabilities:   PNG, JPEG, TIFF, NLS, cairo, ICU\n  Options enabled:           shared R library, shared BLAS, R profiling, memory profiling\n\n  Capabilities skipped:\n  Options not enabled:\n\n  Recommended packages:      yesmake -j 2 all\nsudo make installsudo yum install -y openblas openblas-threads openblas-openmp \n\n./configure --enable-R-shlib --enable-byte-compiled-packages \\\n  --enable-BLAS-shlib --enable-memory-profiling \\\n  --with-blas=\"-lopenblas\"R is now configured for x86_64-pc-linux-gnu\n\nSource directory:          .\nInstallation directory:    /usr/local\n\nC compiler:                gcc -std=gnu99  -g -O2\nFortran 77 compiler:       gfortran  -g -O2\n\nDefault C++ compiler:      g++   -g -O2\nC++98 compiler:            g++ -std=gnu++98 -g -O2\nC++11 compiler:            g++ -std=gnu++11 -g -O2\nC++14 compiler:\nC++17 compiler:\nFortran 90/95 compiler:    gfortran -g -O2\nObj-C compiler:            gcc -g -O2 -fobjc-exceptions\n\nInterfaces supported:      X11, tcltk\nExternal libraries:        readline, **BLAS(OpenBLAS)**, curl\nAdditional capabilities:   PNG, JPEG, TIFF, NLS, cairo, ICU\nOptions enabled:           shared R library, shared BLAS, R profiling, memory profiling\n\nCapabilities skipped:\nOptions not enabled:\n\nRecommended packages:      yeschecking for dgemm_ in -lopenblas... yes\nchecking whether double complex BLAS can be used... yes\nchecking whether the BLAS is complete... yessudo yum install -y atlas\n./configure --enable-R-shlib --enable-byte-compiled-packages \\\n  --enable-BLAS-shlib --enable-memory-profiling \\\n  --with-blas=\"-L/usr/lib64/atlas -lsatlas\"R is now configured for x86_64-pc-linux-gnu\n\nSource directory:          .\nInstallation directory:    /usr/local\n\nC compiler:                gcc -std=gnu99  -g -O2\nFortran 77 compiler:       gfortran  -g -O2\n\nDefault C++ compiler:      g++   -g -O2\nC++98 compiler:            g++ -std=gnu++98 -g -O2\nC++11 compiler:            g++ -std=gnu++11 -g -O2\nC++14 compiler:\nC++17 compiler:\nFortran 90/95 compiler:    gfortran -g -O2\nObj-C compiler:            gcc -g -O2 -fobjc-exceptions\n\nInterfaces supported:      X11, tcltk\nExternal libraries:        readline, **BLAS(generic)**, curl\nAdditional capabilities:   PNG, JPEG, TIFF, NLS, cairo, ICU\nOptions enabled:           shared R library, shared BLAS, R profiling, memory profiling\n\nCapabilities skipped:\nOptions not enabled:\n\nRecommended packages:      yeschecking for dgemm_ in -L/usr/lib64/atlas -lsatlas... yes\nchecking whether double complex BLAS can be used... yes\nchecking whether the BLAS is complete... yes"},{"path":"chap-linux-command-bash.html","id":"ninja-install","chapter":"附录 A 命令行操作","heading":"A.9 忍者安装","text":"从源码自定义安装：加速 Intel MKL 和 大文件支持https://software.intel.com/en-us/articles/using-intel-mkl--r","code":""},{"path":"chap-linux-command-bash.html","id":"settings","chapter":"附录 A 命令行操作","heading":"A.10 配置","text":"","code":""},{"path":"chap-linux-command-bash.html","id":"init-session","chapter":"附录 A 命令行操作","heading":"A.10.1 初始会话 .Rprofile","text":".Rprofile 文件位于 ~/ 目录下或者 R 项目的根目录下查看帮助 ?.Rprofile更多配置设置 startup","code":""},{"path":"chap-linux-command-bash.html","id":"environ-vars","chapter":"附录 A 命令行操作","heading":"A.10.2 环境变量 .Renviron","text":".Renviron 文件位于 ~/ 目录下","code":""},{"path":"chap-linux-command-bash.html","id":"make-vars","chapter":"附录 A 命令行操作","heading":"A.10.3 编译选项 Makevars","text":"Makevars 文件位于 ~/.R/ 目录下","code":""},{"path":"chap-linux-command-bash.html","id":"command-line-arguments","chapter":"附录 A 命令行操作","heading":"A.11 命令行参数","text":"commandArgs 从终端命令行中传递参数rdoc 高亮 R 帮助文档中的 R 函数、关键字 NULL。启用需要在R控制台中执行 rdoc::use_rdoc()radian 代码自动补全和语法高亮，进入 R 控制台，终端中输入radiandocopt 提供R命令行工具，如 littler 包，getopt 从终端命令行接受参数optparse 命令行选项参数的解析器安装完 R-littler R-littler-examples (centos) 或 littler r-cran-littler (ubuntu) 后，执行这样可以载终端中安装 R 包了","code":"# centos\nsudo ln -s /usr/lib64/R/library/littler/examples/install.r /usr/bin/install.r \nsudo ln -s /usr/lib64/R/library/littler/examples/install2.r /usr/bin/install2.r\nsudo ln -s /usr/lib64/R/library/littler/examples/installGithub.r /usr/bin/installGithub.r \nsudo ln -s /usr/lib64/R/library/littler/examples/testInstalled.r /usr/bin/testInstalled.r\n# ubuntu\nsudo ln -s /usr/lib/R/site-library/littler/examples/install.r /usr/bin/install.r \nsudo ln -s /usr/lib/R/site-library/littler/examples/install2.r /usr/bin/install2.r\nsudo ln -s /usr/lib/R/site-library/littler/examples/installGithub.r /usr/bin/installGithub.r \nsudo ln -s /usr/lib/R/site-library/littler/examples/testInstalled.r /usr/bin/testInstalled.rinstall.r docopt#!/usr/bin/env Rscript\n# 安装 optparse 提供更加灵活的传参方式\n# 也可参考 littler https://github.com/eddelbuettel/littler\n# if(\"optparse\" %in% .packages(TRUE)) install.packages('optparse',repos = \"https://cran.rstudio.com\")\n# https://cran.r-project.org/doc/manuals/R-intro.html#Invoking-R-from-the-command-line\n# http://www.cureffi.org/2014/01/15/running-r-batch-mode-linux/\nargs = commandArgs(trailingOnly=TRUE)\n\n# 函数功能：在浏览器中同时打开多个 PDF 文档\nopen_pdf <- function(pdf_path = \"./figures/\", n = 1) {\n  # pdf_path:     PDF文件所在目录\n  # n:            默认打开1个PDF文档\n  # PDF文档目录\n  pdfs <- list.files(pdf_path, pattern = '\\\\.pdf$')\n  # PDF 文档路径\n  path_to_pdfs <- paste(pdf_path, pdfs, sep = .Platform$file.sep)\n  # 打开 PDF 文档\n  invisible(lapply(head(path_to_pdfs, n), browseURL))\n}\n\nopen_pdf(pdf_path, n = args[1])\n\n# 使用： Rscript --vanilla code/batch-open-pdf.R 20"},{"path":"chap-linux-command-bash.html","id":"sec-build-source-code","chapter":"附录 A 命令行操作","heading":"A.12 从源码安装 R","text":"从源码编译 R 的需求大概有以下几点：爱折腾的极客：玩配置，学习 make 相关工具和 Linux 世界的依赖追求性能：如 LFS 支持 和 Intel MKL 加速环境限制：CentOS 或者红帽系统，自带的 R 版本比较落后配置好了以后，可以编译安装了flexiblas 支持多种 BLAS 库自由切换","code":"./configure --prefix=/opt/R/R-devel \\\n  --enable-R-shlib --enable-byte-compiled-packages \\\n  --enable-BLAS-shlib --enable-memory-profiling --with-blas=\"-lopenblas\"R is now configured for x86_64-pc-linux-gnu\n\n  Source directory:            .\n  Installation directory:      /opt/R/R-devel\n\n  C compiler:                  gcc  -g -O2\n  Fortran fixed-form compiler: gfortran -fno-optimize-sibling-calls -g -O2\n\n  Default C++ compiler:        g++ -std=gnu++11  -g -O2\n  C++14 compiler:              g++ -std=gnu++14  -g -O2\n  C++17 compiler:              g++ -std=gnu++17  -g -O2\n  C++20 compiler:              g++ -std=gnu++2a  -g -O2\n  Fortran free-form compiler:  gfortran -fno-optimize-sibling-calls -g -O2\n  Obj-C compiler:               \n\n  Interfaces supported:        X11, tcltk\n  External libraries:          pcre2, readline, BLAS(OpenBLAS), curl\n  Additional capabilities:     PNG, JPEG, TIFF, NLS, cairo, ICU\n  Options enabled:             shared R library, shared BLAS, R profiling, memory profiling\n\n  Capabilities skipped:        \n  Options not enabled:         \n\n  Recommended packages:        yesmake && sudo make install"},{"path":"chap-linux-command-bash.html","id":"install-softwares","chapter":"附录 A 命令行操作","heading":"A.13 安装软件","text":"本书在后续章节中陆续用到新的 R 包，其安装过程不会在正文中呈现，下面以在 CentOS 8 上安装 sf 包为例介绍。首先需要安装一些系统依赖，具体安装哪些依赖参见 sf 包开发站点 https://github.com/r-spatial/sf。然后，在 R 命令行窗口中，执行安装命令：至此，安装完成。如遇本地未安装的新 R 包，可从其官方文档中找寻安装方式。如果你完全不知道自己应该安装哪些，考虑把下面的依赖都安装上软件包管理器架构图，各个命令分别担负什么样的功能，每个命令学习的一般路径是什么，而不是详细介绍每个命令、每个参数的使用，只需给出一个命令的完整使用即可，其余给出一个查询命令帮助手册","code":"sudo dnf config-manager --set-disabled PowerTools # openblas-devel\nsudo dnf install -y sqlite-devel gdal-devel \\\n  proj-devel geos-devel udunits2-devel\ninstall.packages('sf')sudo dnf install -y \\\n  # magick\n  ImageMagick-c++-devel \\ \n  # pdftools\n  poppler-cpp-devel \\ \n  # gifski\n  cargo dnf copr\ndnf config-manager"},{"path":"chap-linux-command-bash.html","id":"sec-install-r-pkgs","chapter":"附录 A 命令行操作","heading":"A.14 安装 R 包","text":"Iñaki Ucar 开发的 cran2copr 项目实现在 Fedora 上安装预编译好的二进制 R 包，项目目的类似 Debian 平台上的 cran2debdevtools 是开发 R 包的常用工具，同时具有很重的依赖，请看\n\ntools::package_dependencies('devtools', recursive = TRUE)\n## $devtools\n##  [1] \"usethis\"     \"callr\"       \"cli\"         \"desc\"        \"ellipsis\"   \n##  [6] \"fs\"          \"httr\"        \"lifecycle\"   \"memoise\"     \"pkgbuild\"   \n## [11] \"pkgload\"     \"rcmdcheck\"   \"remotes\"     \"rlang\"       \"roxygen2\"   \n## [16] \"rstudioapi\"  \"rversions\"   \"sessioninfo\" \"stats\"       \"testthat\"   \n## [21] \"tools\"       \"utils\"       \"withr\"       \"processx\"    \"R6\"         \n## [26] \"glue\"        \"rprojroot\"   \"methods\"     \"curl\"        \"jsonlite\"   \n## [31] \"mime\"        \"openssl\"     \"cachem\"      \"crayon\"      \"prettyunits\"\n## [36] \"digest\"      \"xopen\"       \"brew\"        \"commonmark\"  \"knitr\"      \n## [41] \"purrr\"       \"stringi\"     \"stringr\"     \"xml2\"        \"cpp11\"      \n## [46] \"brio\"        \"evaluate\"    \"magrittr\"    \"praise\"      \"ps\"         \n## [51] \"waldo\"       \"clipr\"       \"gert\"        \"gh\"          \"rappdirs\"   \n## [56] \"whisker\"     \"yaml\"        \"graphics\"    \"grDevices\"   \"fastmap\"    \n## [61] \"askpass\"     \"credentials\" \"sys\"         \"zip\"         \"gitcreds\"   \n## [66] \"ini\"         \"highr\"       \"xfun\"        \"diffobj\"     \"fansi\"      \n## [71] \"rematch2\"    \"tibble\"      \"pillar\"      \"pkgconfig\"   \"vctrs\"      \n## [76] \"utf8\"\n其中，依赖关系见表 .2\n表 .2:  devtools 的系统依赖\n\ncurl\ngit2r\nopenssl\nUbuntu\nlibcurl-dev55\nlibgit2-dev\nlibssl-dev\nCentOS\nlibcurl-devel\nlibgit2-devel\nopenssl-devel\ndevtools 是开发 R 包的常用工具，同时具有很重的依赖，请看其中，依赖关系见表 .2表 .2:  devtools 的系统依赖sf 是处理空间数据的常用工具\n\ntools::package_dependencies('sf', recursive = TRUE)\n## $sf\n##  [1] \"methods\"    \"classInt\"   \"DBI\"        \"graphics\"   \"grDevices\" \n##  [6] \"grid\"       \"magrittr\"   \"Rcpp\"       \"s2\"         \"stats\"     \n## [11] \"tools\"      \"units\"      \"utils\"      \"e1071\"      \"class\"     \n## [16] \"KernSmooth\" \"wk\"         \"MASS\"       \"proxy\"\n其主要的系统依赖分别是 GEOS 3.5.1, GDAL 2.2.2, PROJ 4.9.2\nsudo add-apt-repository -y ppa:ubuntugis/ubuntugis-unstable\nsudo apt-get update\nsudo apt-get install -y libudunits2-dev libgdal-dev libgeos-dev libproj-dev \n这样也同时解决了 udunits2、 rgdal 和 rgeos 等 3个 R 包的系统依赖，其中 udunits2 使用如下命令安装\ninstall.packages(’udunits2’, configure.args = '---udunits2-include=/usr/include/udunits2')sf 是处理空间数据的常用工具其主要的系统依赖分别是 GEOS 3.5.1, GDAL 2.2.2, PROJ 4.9.2这样也同时解决了 udunits2、 rgdal 和 rgeos 等 3个 R 包的系统依赖，其中 udunits2 使用如下命令安装图形设备支持 cairo png jpeg tiff\nsudo apt-get install -y libcairo2-dev libjpeg-dev libpng-dev libtiff-dev 图形设备支持 cairo png jpeg tiff图像处理 imager 和 magick\nsudo yum install fftw-devel # CentOS\nsudo apt-get install libfftw3-dev # Ubuntu\n在 Ubuntu 系统上安装最新的 libmagick++-dev 库\nsudo add-apt-repository -y ppa:opencpu/imagemagick\nsudo apt-get update\nsudo apt-get install -y libmagick++-dev \n在 CentOS 系统上\nsudo yum install -y ImageMagick-c++-devel\n然后安装 R 包 install.packages(c('imager', 'magick'))图像处理 imager 和 magick在 Ubuntu 系统上安装最新的 libmagick++-dev 库在 CentOS 系统上然后安装 R 包 install.packages(c('imager', 'magick'))rgl 是绘制真三维图形的重量级 R 包\nsudo apt-get install libcgal-dev libglu1-mesa-dev libx11-dev # Ubuntu\nsudo yum install mesa-libGLU mesa-libGLU-devel # CentOS\n然后安装 R 包\n\ninstall.packages('rgl')\n在 Ubuntu 系统上还可以这样安装\nsudo add-apt-repository ppa:marutter/rrutter3.5\nsudo apt-get update\nsudo apt-get install r-cran-rglrgl 是绘制真三维图形的重量级 R 包然后安装 R 包在 Ubuntu 系统上还可以这样安装rJava 是 Java 语言和 R 语言之间实现通信交流的桥梁\nsudo apt-get install -y default-jdk\nsudo R CMD javareconf\n然后安装 rJava 包 install.packages(’rJava’)rJava 是 Java 语言和 R 语言之间实现通信交流的桥梁然后安装 rJava 包 install.packages(’rJava’)igraph 是网络数据分析的必备 R 包，为了发挥其最大性能，需要安装三个系统依赖\nsudo apt-get install -y libgmp-dev libxml2-dev libglpk-dev\n然后安装 R 包\n\ninstall.packages('igraph')igraph 是网络数据分析的必备 R 包，为了发挥其最大性能，需要安装三个系统依赖然后安装 R 包gpuR 是基于 GPU 进行矩阵计算的扩展包，依赖 RcppEigen 确保安装 OpenCL 和 RViennaCL 或者 安装 Nvidia 驱动和 CUDA，使用 gpuRcuda 和 gputools 扩展包，下面安装指导来自其 Wiki\n# Install OpenCL headers\nsudo apt-get install opencl-headers opencv-dev\n\n# Install NVIDIA Drivers CUDA\nsudo add-apt-repository -y ppa:xorg-edgers/ppa\nsudo apt-get update\nsudo apt-get install nvidia-346 nvidia-settingsgpuR 是基于 GPU 进行矩阵计算的扩展包，依赖 RcppEigen 确保安装 OpenCL 和 RViennaCL 或者 安装 Nvidia 驱动和 CUDA，使用 gpuRcuda 和 gputools 扩展包，下面安装指导来自其 Wikinloptr 是 NLopt 的 R 语言接口，首先安装 NLopt 程序库 sudo apt-get install libnlopt-dev 然后安装 R 包install.packages('nloptr')，nloptr 被 700+ R 包依赖，如 lme4， spaMM， glmmTMB， rstanarm 等。nloptr 是 NLopt 的 R 语言接口，首先安装 NLopt 程序库 sudo apt-get install libnlopt-dev 然后安装 R 包install.packages('nloptr')，nloptr 被 700+ R 包依赖，如 lme4， spaMM， glmmTMB， rstanarm 等。Rmpfr\nsudo apt-get install libmpfr-dev\ninstall.packages(’Rmpfr’)Rmpfrgeojson\nsudo yum install jq-devel protobuf-devel\n\ninstall.packages(c('geojson','geojsonio','jqr','protolite'))geojsonlgcp\nsudo yum install bwidget\n\ninstall.packages(c('rpanel','lgcp'))lgcpijtiff\nsudo yum install jbigkit-devel\n\ninstall.packages('ijtiff')ijtiffwebshot 包用于截图\nsudo apt install phantomjs\ninstall.packages(’webshot’)webshot 包用于截图gifski 包合成 GIF 动图\nsudo apt-get install cargo\n\ninstall.packages('gifski')gifski 包合成 GIF 动图","code":"\ntools::package_dependencies('devtools', recursive = TRUE)## $devtools\n##  [1] \"usethis\"     \"callr\"       \"cli\"         \"desc\"        \"ellipsis\"   \n##  [6] \"fs\"          \"httr\"        \"lifecycle\"   \"memoise\"     \"pkgbuild\"   \n## [11] \"pkgload\"     \"rcmdcheck\"   \"remotes\"     \"rlang\"       \"roxygen2\"   \n## [16] \"rstudioapi\"  \"rversions\"   \"sessioninfo\" \"stats\"       \"testthat\"   \n## [21] \"tools\"       \"utils\"       \"withr\"       \"processx\"    \"R6\"         \n## [26] \"glue\"        \"rprojroot\"   \"methods\"     \"curl\"        \"jsonlite\"   \n## [31] \"mime\"        \"openssl\"     \"cachem\"      \"crayon\"      \"prettyunits\"\n## [36] \"digest\"      \"xopen\"       \"brew\"        \"commonmark\"  \"knitr\"      \n## [41] \"purrr\"       \"stringi\"     \"stringr\"     \"xml2\"        \"cpp11\"      \n## [46] \"brio\"        \"evaluate\"    \"magrittr\"    \"praise\"      \"ps\"         \n## [51] \"waldo\"       \"clipr\"       \"gert\"        \"gh\"          \"rappdirs\"   \n## [56] \"whisker\"     \"yaml\"        \"graphics\"    \"grDevices\"   \"fastmap\"    \n## [61] \"askpass\"     \"credentials\" \"sys\"         \"zip\"         \"gitcreds\"   \n## [66] \"ini\"         \"highr\"       \"xfun\"        \"diffobj\"     \"fansi\"      \n## [71] \"rematch2\"    \"tibble\"      \"pillar\"      \"pkgconfig\"   \"vctrs\"      \n## [76] \"utf8\"\ntools::package_dependencies('sf', recursive = TRUE)## $sf\n##  [1] \"methods\"    \"classInt\"   \"DBI\"        \"graphics\"   \"grDevices\" \n##  [6] \"grid\"       \"magrittr\"   \"Rcpp\"       \"s2\"         \"stats\"     \n## [11] \"tools\"      \"units\"      \"utils\"      \"e1071\"      \"class\"     \n## [16] \"KernSmooth\" \"wk\"         \"MASS\"       \"proxy\"sudo add-apt-repository -y ppa:ubuntugis/ubuntugis-unstable\nsudo apt-get update\nsudo apt-get install -y libudunits2-dev libgdal-dev libgeos-dev libproj-dev install.packages(’udunits2’, configure.args = '--with-udunits2-include=/usr/include/udunits2')sudo apt-get install -y libcairo2-dev libjpeg-dev libpng-dev libtiff-dev sudo yum install fftw-devel # CentOS\nsudo apt-get install libfftw3-dev # Ubuntusudo add-apt-repository -y ppa:opencpu/imagemagick\nsudo apt-get update\nsudo apt-get install -y libmagick++-dev sudo yum install -y ImageMagick-c++-develsudo apt-get install libcgal-dev libglu1-mesa-dev libx11-dev # Ubuntu\nsudo yum install mesa-libGLU mesa-libGLU-devel # CentOS\ninstall.packages('rgl')sudo add-apt-repository ppa:marutter/rrutter3.5\nsudo apt-get update\nsudo apt-get install r-cran-rglsudo apt-get install -y default-jdk\nsudo R CMD javareconfsudo apt-get install -y libgmp-dev libxml2-dev libglpk-dev\ninstall.packages('igraph')# Install OpenCL headers\nsudo apt-get install opencl-headers opencv-dev\n\n# Install NVIDIA Drivers and CUDA\nsudo add-apt-repository -y ppa:xorg-edgers/ppa\nsudo apt-get update\nsudo apt-get install nvidia-346 nvidia-settingssudo apt-get install libmpfr-devinstall.packages(’Rmpfr’)sudo yum install jq-devel protobuf-devel\ninstall.packages(c('geojson','geojsonio','jqr','protolite'))sudo yum install bwidget\ninstall.packages(c('rpanel','lgcp'))sudo yum install jbigkit-devel\ninstall.packages('ijtiff')sudo apt install phantomjsinstall.packages(’webshot’)sudo apt-get install cargo\ninstall.packages('gifski')"},{"path":"chap-linux-command-bash.html","id":"sec-software-manager","chapter":"附录 A 命令行操作","heading":"A.15 软件包管理器","text":"","code":""},{"path":"chap-linux-command-bash.html","id":"subsec-dnf-yum","chapter":"附录 A 命令行操作","heading":"A.15.1 dnf","text":"清理升级后的 CentOS 8 系统内核查找系统安装的内核仅保留一个版本的内核，其它旧的内核都删除掉解决上述模块依赖问题的办法 是重置三个 Perl 模块","code":"rpm -qa | sort | grep kernelkernel-4.18.0-147.8.1.el8_1.x86_64\nkernel-4.18.0-193.6.3.el8_2.x86_64\nkernel-core-4.18.0-147.8.1.el8_1.x86_64\nkernel-core-4.18.0-193.6.3.el8_2.x86_64\nkernel-headers-4.18.0-193.6.3.el8_2.x86_64\nkernel-modules-4.18.0-147.8.1.el8_1.x86_64\nkernel-modules-4.18.0-193.6.3.el8_2.x86_64\nkernel-tools-4.18.0-193.6.3.el8_2.x86_64\nkernel-tools-libs-4.18.0-193.6.3.el8_2.x86_64sudo dnf remove $(dnf repoquery --installonly --latest-limit=-1 -q)模块依赖问题\n\n 问题 1: conflicting requests\n  - nothing provides module(perl:5.26) needed by module perl-DBD-MySQL:4.046:8010020191114030811:073fa5fe-0.x86_64\n 问题 2: conflicting requests\n  - nothing provides module(perl:5.26) needed by module perl-DBI:1.641:8010020191113222731:16b3ab4d-0.x86_64\n 问题 3: conflicting requests\n  - nothing provides module(perl:5.26) needed by module perl-YAML:1.24:8010020191114031501:a5949e2e-0.x86_64\n依赖关系解决。\n=======================================================================================================================\n 软件包                        架构                  版本                                 仓库                    大小\n=======================================================================================================================\n移除:\n kernel                        x86_64                4.18.0-147.8.1.el8_1                 @BaseOS                  0  \n kernel-core                   x86_64                4.18.0-147.8.1.el8_1                 @BaseOS                 58 M\n kernel-modules                x86_64                4.18.0-147.8.1.el8_1                 @BaseOS                 20 M\n\n事务概要\n=======================================================================================================================\n移除  3 软件包\n\n将会释放空间：78 M\n确定吗？[y/N]： y\n运行事务检查\n事务检查成功。\n运行事务测试\n事务测试成功。\n运行事务\n  准备中  :                                                                                                        1/1 \n  删除    : kernel-4.18.0-147.8.1.el8_1.x86_64                                                                     1/3 \n  运行脚本: kernel-4.18.0-147.8.1.el8_1.x86_64                                                                     1/3 \n  删除    : kernel-modules-4.18.0-147.8.1.el8_1.x86_64                                                             2/3 \n  运行脚本: kernel-modules-4.18.0-147.8.1.el8_1.x86_64                                                             2/3 \n  运行脚本: kernel-core-4.18.0-147.8.1.el8_1.x86_64                                                                3/3 \n  删除    : kernel-core-4.18.0-147.8.1.el8_1.x86_64                                                                3/3 \n  运行脚本: kernel-core-4.18.0-147.8.1.el8_1.x86_64                                                                3/3 \n  验证    : kernel-4.18.0-147.8.1.el8_1.x86_64                                                                     1/3 \n  验证    : kernel-core-4.18.0-147.8.1.el8_1.x86_64                                                                2/3 \n  验证    : kernel-modules-4.18.0-147.8.1.el8_1.x86_64                                                             3/3 \n\n已移除:\n  kernel-4.18.0-147.8.1.el8_1.x86_64                          kernel-core-4.18.0-147.8.1.el8_1.x86_64                 \n  kernel-modules-4.18.0-147.8.1.el8_1.x86_64                 \n\n完毕！sudo dnf module reset perl-DBD-MySQL perl-YAML perl-DBI依赖关系解决。\n=======================================================================================================================\n 软件包                      架构                       版本                         仓库                         大小\n=======================================================================================================================\n重置模块:\n perl-DBD-MySQL                                                                                                       \n perl-DBI                                                                                                             \n perl-YAML                                                                                                            \n\n事务概要\n=======================================================================================================================\n\n确定吗？[y/N]： y\n完毕！"},{"path":"chap-linux-command-bash.html","id":"subsec-apt-get","chapter":"附录 A 命令行操作","heading":"A.15.2 apt","text":"添加或删除 PPA (Personal Package Archive)，比如在 Ubuntu 20.04 及之前的版本上安装新版 Inkscape找到并删除旧的内核安装确认 openssh-server 服务","code":"sudo add-apt-repository ppa:inkscape.dev/stable\nsudo add-apt-repository --remove ppa:inkscape.dev/stablesudo apt-get install build-essential # 修复依赖问题\nsudo apt update # 更新资源列表\nsudo apt-get upgrade # 更新软件包\nsudo apt-get autoclean # 删除已卸的软件的备份\nsudo apt-get clean # 删除已装或已卸的软件的备份\nsudo apt-get autoremove --purge * # 推荐卸载软件的方式\napt-get list --upgradable # 列出可升级的包dpkg --list | grep linux-image\nsudo apt-get purge linux-image-3.19.0-{18,20,21,25}\nsudo update-grub2# 搜索\napt-cache search octave | grep octave\n# 查询\napt show octave\n# 安装\nsudo apt install octavesudo apt-get install lsb-core\nlsb_release -aadduser cloud2016 # 添加用户\npasswd cloud2016  # 用户密码设为 cloud\nwhereis sudoers   # 查找文件位置\nchmod -v u+w /etc/sudoers # 给文件 sudoers 添加写权限\nvim /etc/sudoers # 添加 cloud2016 管理员权限\nchmod -v u-w /etc/sudoers # 收回权限sudo apt install openssh-server\nsudo /etc/init.d/ssh start\nps -aux | grep ssh"},{"path":"references.html","id":"references","chapter":"参考文献","heading":"参考文献","text":"","code":""}]
